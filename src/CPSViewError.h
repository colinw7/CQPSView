#ifndef CPSViewError_H
#define CPSViewError_H

enum PSViewErrorType {
  PSVIEW_ERROR_TYPE_CONFIGURATION_ERROR,
  PSVIEW_ERROR_TYPE_DICT_FULL,
  PSVIEW_ERROR_TYPE_DICT_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_DICT_STACK_UNDERFLOW,
  PSVIEW_ERROR_TYPE_EXEC_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_HANDLE_ERROR,
  PSVIEW_ERROR_TYPE_INTERRUPT,
  PSVIEW_ERROR_TYPE_INVALID_ACCESS,
  PSVIEW_ERROR_TYPE_INVALID_EXIT,
  PSVIEW_ERROR_TYPE_INVALID_FILE_ACCESS,
  PSVIEW_ERROR_TYPE_INVALID_FONT,
  PSVIEW_ERROR_TYPE_INVALID_RESTORE,
  PSVIEW_ERROR_TYPE_IO_ERROR,
  PSVIEW_ERROR_TYPE_LIMIT_CHECK,
  PSVIEW_ERROR_TYPE_NO_CURRENT_POINT,
  PSVIEW_ERROR_TYPE_RANGE_CHECK,
  PSVIEW_ERROR_TYPE_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_STACK_UNDERFLOW,
  PSVIEW_ERROR_TYPE_SYNTAX_ERROR,
  PSVIEW_ERROR_TYPE_TIME_OUT,
  PSVIEW_ERROR_TYPE_TYPE_CHECK,
  PSVIEW_ERROR_TYPE_UNDEFINED,
  PSVIEW_ERROR_TYPE_UNDEFINED_FILENAME,
  PSVIEW_ERROR_TYPE_UNDEFINED_RESOURCE,
  PSVIEW_ERROR_TYPE_UNDEFINED_RESULT,
  PSVIEW_ERROR_TYPE_UNMATCHED_MARK,
  PSVIEW_ERROR_TYPE_UNREGISTERED,
  PSVIEW_ERROR_TYPE_VM_ERROR
};

class PSViewErrorMgr {
 public:
  PSViewErrorMgr(CPSView *psview);
 ~PSViewErrorMgr();

  CPSView *getPSView() const { return psview_; }

  void raise(PSViewErrorType type);

  void setError(bool flag);
  bool getError();

  void defaultHandleError();

  void defaultErrorHandler();

 private:
  PSViewErrorMgr(const PSViewErrorMgr &rhs);
  PSViewErrorMgr &operator=(const PSViewErrorMgr &rhs);

 private:
  static std::string error_names_[];

  CPSView*         psview_      { nullptr };
  PSViewToken*     error_token_ { nullptr };
  PSViewNameToken* error_name_  { nullptr };
  bool             error_flag_  { false };
};

#endif
