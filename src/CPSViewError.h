#ifndef PSVIEW_ERROR_H
#define PSVIEW_ERROR_H

enum PSViewErrorType {
  PSVIEW_ERROR_TYPE_CONFIGURATION_ERROR,
  PSVIEW_ERROR_TYPE_DICT_FULL,
  PSVIEW_ERROR_TYPE_DICT_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_DICT_STACK_UNDERFLOW,
  PSVIEW_ERROR_TYPE_EXEC_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_HANDLE_ERROR,
  PSVIEW_ERROR_TYPE_INTERRUPT,
  PSVIEW_ERROR_TYPE_INVALID_ACCESS,
  PSVIEW_ERROR_TYPE_INVALID_EXIT,
  PSVIEW_ERROR_TYPE_INVALID_FILE_ACCESS,
  PSVIEW_ERROR_TYPE_INVALID_FONT,
  PSVIEW_ERROR_TYPE_INVALID_RESTORE,
  PSVIEW_ERROR_TYPE_IO_ERROR,
  PSVIEW_ERROR_TYPE_LIMIT_CHECK,
  PSVIEW_ERROR_TYPE_NO_CURRENT_POINT,
  PSVIEW_ERROR_TYPE_RANGE_CHECK,
  PSVIEW_ERROR_TYPE_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_STACK_UNDERFLOW,
  PSVIEW_ERROR_TYPE_SYNTAX_ERROR,
  PSVIEW_ERROR_TYPE_TIME_OUT,
  PSVIEW_ERROR_TYPE_TYPE_CHECK,
  PSVIEW_ERROR_TYPE_UNDEFINED,
  PSVIEW_ERROR_TYPE_UNDEFINED_FILENAME,
  PSVIEW_ERROR_TYPE_UNDEFINED_RESOURCE,
  PSVIEW_ERROR_TYPE_UNDEFINED_RESULT,
  PSVIEW_ERROR_TYPE_UNMATCHED_MARK,
  PSVIEW_ERROR_TYPE_UNREGISTERED,
  PSVIEW_ERROR_TYPE_VM_ERROR
};

class PSViewErrorMgr {
 private:
  static std::string error_names_[];

  CPSView         *psview_;
  PSViewToken     *error_token_;
  PSViewNameToken *error_name_;
  bool             error_flag_;

 public:
  PSViewErrorMgr(CPSView *psview);
 ~PSViewErrorMgr();

  CPSView *getPSView() const { return psview_; }

  void raise(PSViewErrorType type);

  void setError(bool flag);
  bool getError();

  void defaultHandleError();

  void defaultErrorHandler();

 private:
  PSViewErrorMgr(const PSViewErrorMgr &rhs);
  PSViewErrorMgr &operator=(const PSViewErrorMgr &rhs);
};

#endif
