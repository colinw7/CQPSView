CONCAT_ID=##concat##
##concat##CFreeType.cpp
#include <CFreeType.h>
#include <CFontMgr.h>
#include <CAutoPtr.h>

#include <ft2build.h>
#include <freetype/ftoutln.h>
#include FT_FREETYPE_H

#include <vector>

CFreeTypeMgr *
CFreeTypeMgr::
getInstance()
{
  static CFreeTypeMgr *instance;

  if (! instance)
    instance = new CFreeTypeMgr;

  return instance;
}

CFreeTypeMgr::
CFreeTypeMgr()
{
  free_type_ = new CFreeType;
}

CFreeTypeMgr::
~CFreeTypeMgr()
{
  delete free_type_;
}

CFontPtr
CFreeTypeMgr::
getFont() const
{
  return free_type_->getFont();
}

bool
CFreeTypeMgr::
setFont(const char *fontName, CFontStyle style, double size)
{
  return free_type_->setFont(fontName, style, size);
}

bool
CFreeTypeMgr::
setFont(CFontPtr font)
{
  return free_type_->setFont(font);
}

bool
CFreeTypeMgr::
drawString(CFreeTypeImageRenderer *renderer, const char *s, double *x, double *y)
{
  return free_type_->drawString(renderer, s, x, y);
}

bool
CFreeTypeMgr::
drawChar(CFreeTypeImageRenderer *renderer, char c, double *x, double *y)
{
  return free_type_->drawChar(renderer, c, x, y);
}

bool
CFreeTypeMgr::
imageString(CImagePtr image, const char *s, const CRGBA &color)
{
  return free_type_->imageString(image, s, color);
}

bool
CFreeTypeMgr::
imageChar(CImagePtr image, char c, const CRGBA &color)
{
  return free_type_->imageChar(image, c, color);
}

bool
CFreeTypeMgr::
strokeString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y)
{
  return free_type_->strokeString(renderer, s, x, y);
}

bool
CFreeTypeMgr::
fillString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y)
{
  return free_type_->fillString(renderer, s, x, y);
}

bool
CFreeTypeMgr::
pathString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y)
{
  return free_type_->pathString(renderer, s, x, y);
}

bool
CFreeTypeMgr::
strokeChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y)
{
  return free_type_->strokeChar(renderer, c, x, y);
}

bool
CFreeTypeMgr::
fillChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y)
{
  return free_type_->fillChar(renderer, c, x, y);
}

bool
CFreeTypeMgr::
pathChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y)
{
  return free_type_->pathChar(renderer, c, x, y);
}

//----------------

CFreeType::
CFreeType() :
 config_("CFreeType"), library_(0), face_(0)
{
  init();
}

CFreeType::
~CFreeType()
{
}

bool
CFreeType::
init()
{
  renderer_ = NULL;

  int error = FT_Init_FreeType(&library_);

  if (error) {
    std::cerr << "An error occurred during library initialization" << std::endl;
    return false;
  }

  CFontPtr font = CFontMgrInst->lookupFont("arial", CFONT_STYLE_NORMAL, 14);

  setFont(font);

  return true;
}

bool
CFreeType::
setFont(const char *family, CFontStyle style, double size)
{
  CFontPtr font = CFontMgrInst->lookupFont(family, style, size);

  return setFont(font);
}

bool
CFreeType::
setFont(CFontPtr font)
{
  if (! font.isValid())
    return false;

  font_ = font;

  const std::string &family = font->getFamily();
  CFontStyle        style  = font->getStyle();
  double            size   = font->getSize();

  std::string fontName = encodeFontName(family.c_str(), style);

  int face_index = 0;

  int error = FT_New_Face(library_, fontName.c_str(), face_index, &face_);
  //int error = FT_New_Memory_Face(library_, buffer, size, face_index, &face_);

  if (error) {
    std::cerr << "Can't set font " << fontName << std::endl;

    fontName = encodeFontName("arial", style);

    error = FT_New_Face(library_, fontName.c_str(), face_index, &face_);

    if (error)
      return false;
  }

  int char_width  = 0;
  int char_height = int(64*size);
  int x_res       = 75; // dpi
  int y_res       = 75;

  error = FT_Set_Char_Size(face_, char_width, char_height, x_res, y_res);

  // error = FT_Set_Pixel_Sizes(face_, char_width, char_height);

  return true;
}

std::string
CFreeType::
encodeFontName(const char *family, CFontStyle style)
{
  std::string fontName = family;

  if (style & CFONT_STYLE_BOLD)
    fontName += "-bold";

  if (style & CFONT_STYLE_ITALIC)
    fontName += "-italic";

  std::string fontPath;

  if (! config_.getValue(fontName, fontPath))
    fontPath = fontName;

  return fontPath;
}

bool
CFreeType::
getChar(char c)
{
  if (! face_) return false;

  uint c1 = (c >= 0 ? c : 256 + c);

#if 0
  FT_UInt glyph_index = FT_Get_Char_Index(face_, c1);

  //if (glyph_index == 0) return false;

  // error = FT_Set_Transform(face_, &matrix, &delta);

  int load_flags = FT_LOAD_DEFAULT;

  int error = FT_Load_Glyph(face_, glyph_index, load_flags);

  if (error) return false;

  int render_mode = FT_RENDER_MODE_NORMAL;

  error = FT_Render_Glyph(face_->glyph, render_mode);

  if (error) return false;
#else
  int error = FT_Load_Char(face_, c1, FT_LOAD_RENDER);

  if (error) return false;
#endif

  return true;
}

bool
CFreeType::
drawString(CFreeTypeImageRenderer *renderer, const char *s, double *x, double *y)
{
  uint len = strlen(s);

  for (uint i = 0; i < len; ++i)
    (void) drawChar(renderer, s[i], x, y);

  return true;
}

bool
CFreeType::
drawChar(CFreeTypeImageRenderer *renderer, char c, double *x, double *y)
{
  if (! getChar(c)) return false;

  drawBitmap(renderer, &face_->glyph->bitmap, *x + face_->glyph->bitmap_left,
             *y - face_->glyph->bitmap_top);

  *x += face_->glyph->advance.x/64.0;
  *y += face_->glyph->advance.y/64.0;

  return true;
}

void
CFreeType::
drawBitmap(CFreeTypeImageRenderer *renderer, FT_Bitmap *bitmap, double x, double y)
{
  uchar *p = bitmap->buffer;

  for (int r = 0; r < bitmap->rows; ++r) {
    uchar *p1 = p;

    for (int c = 0; c < bitmap->width; ++c, ++p1) {
      uchar pixel = *p1;

      if (pixel == 0) continue;

      double gray = 1.0;

      if (bitmap->pixel_mode == FT_PIXEL_MODE_GRAY)
        gray = pixel/255.0;

      renderer->drawPoint(CIPoint2D(x + c, y + r), gray);
    }

    p += bitmap->pitch;
  }
}

struct ImageXY {
  CImagePtr image;
  int       x, y;
  int       l, ascent, descent;

  ImageXY(CImagePtr image1, int x1, int y1, int l1, int ascent1, int descent1) :
   image(image1), x(x1), y(y1), l(l1), ascent(ascent1), descent(descent1) {
  }
};

bool
CFreeType::
imageString(CImagePtr image, const char *s, const CRGBA &color)
{
  std::vector<ImageXY> char_images;

  int w = 0, ascent = 0, descent = 0;

  int x1 = 0, y1 = 0;

  uint len = strlen(s);

  for (uint i = 0; i < len; ++i) {
    y1 = 0;

    CImagePtr char_image = CImageMgrInst->createImage(CImageNoSrc());

    int x2 = x1;
    int y2 = y1;

    int l = 0, t = 0;

    (void) imageChar1(char_image, s[i], &l, &t, &x2, &y2, color);

    w = x2;

    int ascent1  = char_image->getHeight();
    int descent1 = 0;

    if (t < 0) {
      ascent1  += t;
      descent1  = -t;
    }

    ascent  = std::max( ascent,  ascent1);
    descent = std::max(descent, descent1);

    char_images.push_back(ImageXY(char_image, x1, y1, l, ascent1, descent1));

    x1 = x2;
  }

  image->setDataSize(w, ascent + descent);

  image->setRGBAData(CRGBA(0,0,0,0));

  uint n = char_images.size();

  for (uint i = 0; i < n; ++i) {
    ImageXY &char_image = char_images[i];

    int x = char_image.x + char_image.l;

    int y = ascent - char_image.ascent;

    char_images[i].image->copyTo(image, x, y);
  }

  return true;
}

bool
CFreeType::
imageChar(CImagePtr image, char c, const CRGBA &color)
{
  int l = 0, t = 0, x = 0, y = 0;

  return imageChar1(image, c, &l, &t, &x, &y, color);
}

bool
CFreeType::
imageChar1(CImagePtr image, char c, int *l, int *t, int *x, int *y, const CRGBA &color)
{
  if (! getChar(c)) return false;

  *l = face_->glyph->bitmap_left;

  if (face_->glyph->bitmap_top > 0)
    *t = face_->glyph->bitmap_top - face_->glyph->bitmap.rows;
  else
    *t = face_->glyph->bitmap_top;

  imageBitmap(image, &face_->glyph->bitmap, color);

  *x += face_->glyph->advance.x/64;
  *y += face_->glyph->advance.y/64;

  return true;
}

void
CFreeType::
imageBitmap(CImagePtr image, FT_Bitmap *bitmap, const CRGBA &color)
{
  image->setDataSize(bitmap->width, bitmap->rows);

  image->setRGBAData(CRGBA(0,0,0,0));

  uchar *p = bitmap->buffer;

  double r = color.getRed  ();
  double g = color.getGreen();
  double b = color.getBlue ();

  for (int row = 0; row < bitmap->rows; ++row) {
    uchar *p1 = p;

    for (int col = 0; col < bitmap->width; ++col, ++p1) {
      uchar pixel = *p1;

      if (pixel == 0) continue;

      if (bitmap->pixel_mode == FT_PIXEL_MODE_GRAY) {
        double gray = pixel/255.0;

        image->setRGBAPixel(col, row, CRGBA(r, g, b, gray));
      }
      else
        image->setRGBAPixel(col, row, CRGBA(r, g, b, 1));
    }

    p += bitmap->pitch;
  }
}

bool
CFreeType::
strokeString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y)
{
  uint len = strlen(s);

  for (uint i = 0; i < len; ++i)
    (void) strokeChar(renderer, s[i], x, y);

  return true;
}

bool
CFreeType::
fillString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y)
{
  uint len = strlen(s);

  for (uint i = 0; i < len; ++i)
    (void) fillChar(renderer, s[i], x, y);

  return true;
}

bool
CFreeType::
pathString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y)
{
  if (! font_.isValid())
    return false;

  const std::string &family = font_->getFamily();
  CFontStyle         style  = font_->getStyle();
  double             size   = font_->getSize();

  renderer->init();

  uint len = strlen(s);

  uint i = 0;

  while (i < len) {
    if (s[i] == '') {
      ++i;

      if (i >= len || s[i] != '[')
        continue;

      ++i;

      int num = 0;

      while (i < len && isdigit(s[i])) {
        num = 10*num + (s[i] - '0');

        ++i;
      }

      if (i >= len || s[i] != 'm')
        continue;

      ++i;

      CFontPtr font1;

      if      (num == 0)
        font1 = CFontMgrInst->lookupFont(family, CFONT_STYLE_NORMAL, size);
      else if (num == 1)
        font1 = CFontMgrInst->lookupFont(family, CFONT_STYLE_BOLD  , size);
      else if (num == 3)
        font1 = CFontMgrInst->lookupFont(family, CFONT_STYLE_ITALIC, size);

      if (font1.isValid())
        setFont(font1);
    }
    else {
      (void) pathChar(renderer, s[i], x, y);

      ++i;
    }
  }

  font_ = CFontMgrInst->lookupFont(family, style, size);

  return true;
}

bool
CFreeType::
strokeChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y)
{
  renderer->init();

  if (! pathChar(renderer, c, x, y))
    return false;

  renderer->stroke();

  return true;
}

bool
CFreeType::
fillChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y)
{
  renderer->init();

  if (! pathChar(renderer, c, x, y))
    return false;

  renderer->fill();

  return true;
}

bool
CFreeType::
pathChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y)
{
  if (! face_) return false;

  renderer_ = renderer;

  uint c1 = (c >= 0 ? c : 256 + c);

  FT_UInt glyph_index = FT_Get_Char_Index(face_, c1);

  if (glyph_index == 0) return false;

  int error1 = FT_Load_Glyph(face_, glyph_index, FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP);

  if (error1) return false;

  pos_ = CPoint2D(*x, *y);

  FT_Outline_Funcs outlineMethods = {
    (FT_Outline_MoveTo_Func ) CFreeType::traceMoveto,
    (FT_Outline_LineTo_Func ) CFreeType::traceLineto,
    (FT_Outline_ConicTo_Func) CFreeType::traceBezier2,
    (FT_Outline_CubicTo_Func) CFreeType::traceBezier3,
    0, // shift
    0  // delta
  };

  int error2 = FT_Outline_Decompose(&face_->glyph->outline, &outlineMethods,
                                    reinterpret_cast<void*>(this));

  if (error2)
    return false;

  renderer->close();

  *x += face_->glyph->advance.x/64.0;
  *y += face_->glyph->advance.y/64.0;

  return true;
}

int
CFreeType::
traceMoveto(FT_Vector *v, CFreeType *th)
{
  CPoint2D current;

  if (th->renderer_->getCurrentPoint(current))
    th->renderer_->close();

  double x = v->x/64.0;
  double y = v->y/64.0;

  CPoint2D p = th->pos_ + CPoint2D(x, y);

  th->renderer_->moveTo(p);

  th->renderer_->setCurrentPoint(p);

  return 0;
}

int
CFreeType::
traceLineto(FT_Vector *v, CFreeType *th)
{
  double x = v->x/64.0;
  double y = v->y/64.0;

  CPoint2D p = th->pos_ + CPoint2D(x, y);

  th->renderer_->lineTo(p);

  th->renderer_->setCurrentPoint(p);

  return 0;
}

int
CFreeType::
traceBezier2(FT_Vector *v1, FT_Vector *v2, CFreeType *th)
{
  double x1 = v1->x/64.0;
  double y1 = v1->y/64.0;
  double x2 = v2->x/64.0;
  double y2 = v2->y/64.0;

  CPoint2D p1 = th->pos_ + CPoint2D(x1, y1);
  CPoint2D p2 = th->pos_ + CPoint2D(x2, y2);

  th->renderer_->bezier2To(p1, p2);

  th->renderer_->setCurrentPoint(p2);

  return 0;
}

int
CFreeType::
traceBezier3(FT_Vector *v1, FT_Vector *v2, FT_Vector *v3, CFreeType *th)
{
  double x1 = v1->x/64.0;
  double y1 = v1->y/64.0;
  double x2 = v2->x/64.0;
  double y2 = v2->y/64.0;
  double x3 = v3->x/64.0;
  double y3 = v3->y/64.0;

  CPoint2D p1 = th->pos_ + CPoint2D(x1, y1);
  CPoint2D p2 = th->pos_ + CPoint2D(x2, y2);
  CPoint2D p3 = th->pos_ + CPoint2D(x3, y3);

  th->renderer_->bezier3To(p1, p2, p3);

  th->renderer_->setCurrentPoint(p3);

  return 0;
}
##concat##CPSViewArray.cpp
#include <CPSViewI.h>

PSViewArray::
PSViewArray(PSVinteger max_length) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(max_length);
}

PSViewArray::
PSViewArray(const PSViewArray &array) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(array.tokens_);
}

PSViewArray::
PSViewArray(const PSViewArray &array, PSVinteger n) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(array.tokens_, n - 1);
}

PSViewArray::
PSViewArray(const PSViewArray &array, PSVinteger pos, PSVinteger len) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(array.tokens_, pos - 1, len);
}

PSViewArray::
~PSViewArray()
{
}

PSViewArray *
PSViewArray::
dup() const
{
  return new PSViewArray(*this);
}

int
PSViewArray::
compare(PSViewArray *array)
{
  PSVinteger num_values1 = getNumValues();
  PSVinteger num_values2 = array->getNumValues();

  if      (num_values1 > num_values2)
    return  1;
  else if (num_values1 < num_values2)
    return -1;

  for (PSVinteger i = 1; i <= num_values1; ++i) {
    PSViewToken *token1 = getValue(i);
    PSViewToken *token2 = array->getValue(i);

    int cmp = token1->compare(token2);

    if (cmp != 0)
      return cmp;
  }

  return 0;
}

PSVinteger
PSViewArray::
getNumValues()
{
  return tokens_->getLen();
}

PSViewToken *
PSViewArray::
getValue(uint i)
{
  return tokens_->getValue(i - 1);
}

void
PSViewArray::
setValue(uint i, PSViewToken *value)
{
  tokens_->setValue(i - 1, value);
}

void
PSViewArray::
setSubValues(uint pos, PSViewToken **sub_tokens, uint num_sub_tokens)
{
  // getPSView()->getMemoryMgr()->change((char **) &array->tokens);

  for (uint i = 0; i < num_sub_tokens; ++i)
    setValue(pos + i, sub_tokens[i]);
}

PSViewArray *
PSViewArray::
split(uint n)
{
  PSViewArray *array = new PSViewArray(*this, n + 1);

  setBounds(1, n);

  return array;
}

void
PSViewArray::
setBounds(int pos, uint len)
{
  if (pos == -1)
    tokens_->setBounds(0, 0);
  else
    tokens_->setBounds(pos - 1, len);
}
##concat##CPSViewArrayToken.cpp
#include <CPSViewI.h>

PSViewArrayToken::
PSViewArrayToken(CPSView *psview, uint max_length) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_ARRAY,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 array_     ()
{
  array_ = new PSViewArray(max_length);
}

PSViewArrayToken::
PSViewArrayToken(CPSView *psview, CMatrix2D *matrix) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_ARRAY,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 array_     ()
{
  array_ = new PSViewArray(6);

  double data[6];

  matrix->getValues(&data[0], &data[2], &data[1],
                    &data[3], &data[4], &data[5]);

  for (uint i = 1; i <= 6; ++i) {
    PSViewToken *sub_token = new PSViewRealToken(psview_, data[i - 1]);

    setValue(i, sub_token);
  }
}

PSViewArrayToken::
PSViewArrayToken(const PSViewArrayToken &array_token) :
 PSViewToken(array_token),
 array_     ()
{
  array_ = array_token.array_->dup();
}

PSViewArrayToken::
PSViewArrayToken(const PSViewArrayToken &array_token, uint n) :
 PSViewToken(array_token),
 array_     ()
{
  array_ = new PSViewArray(*array_token.array_, n);
}

// TODO: transfer ownership
PSViewArrayToken::
PSViewArrayToken(CPSView *psview, PSViewArray *array) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_ARRAY,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 array_(array)
{
}

PSViewArrayToken::
~PSViewArrayToken()
{
}

PSViewArrayToken *
PSViewArrayToken::
dup() const
{
  return new PSViewArrayToken(*this);
}

int
PSViewArrayToken::
compare(PSViewToken *token)
{
  if (token->isType(type_))
    return array_->compare(dynamic_cast<PSViewArrayToken *>(token)->array_);
  else
    return type_ - token->getType();
}

PSVinteger
PSViewArrayToken::
getNumValues()
{
  return array_->getNumValues();
}

PSViewToken *
PSViewArrayToken::
getValue(uint i)
{
  return array_->getValue(i);
}

void
PSViewArrayToken::
setValue(uint i, PSViewToken *value)
{
  if (getGlobal() && value->getLocal()) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);
    return;
  }

  array_->setValue(i, value);
}

void
PSViewArrayToken::
setSubValues(PSVinteger pos, PSViewToken **sub_tokens,
             PSVinteger num_sub_tokens)
{
  if (num_sub_tokens <= 0)
    CTHROW("Invalid Number of Sub Values");

  if (getGlobal()) {
    for (PSVinteger i = 0; i < num_sub_tokens; ++i) {
      if (sub_tokens[i]->getLocal()) {
        psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);
        return;
      }
    }
  }

  array_->setSubValues(pos, sub_tokens, num_sub_tokens);
}

PSViewArrayToken *
PSViewArrayToken::
split(PSVinteger n)
{
  PSViewArray *array = array_->split(n);

  PSViewArrayToken *token = new PSViewArrayToken(psview_, array);

  return token;
}

void
PSViewArrayToken::
setBounds(PSVinteger pos, PSVinteger len)
{
  array_->setBounds(pos, len);
}

void
PSViewArrayToken::
executeToken()
{
  PSVinteger num_tokens = array_->getNumValues();

  if (num_tokens > 0) {
    psview_->getExecutionStack()->push(this);

    for (PSVinteger i = 1; i <= num_tokens; i++) {
      if (i == num_tokens)
        psview_->getExecutionStack()->pop();

      PSViewToken *sub_token = array_->getValue(i);

      if (sub_token->isProcedure())
        psview_->getOperandStack()->push(sub_token);
      else
        sub_token->execute();
    }
  }
}

const PSViewName &
PSViewArrayToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewArrayToken::
print()
{
  if (! isExecutable())
    CStrUtil::printf("[");
  else
    CStrUtil::printf("{");

  PSVinteger num_values = array_->getNumValues();

  for (PSVinteger i = 1; i <= num_values; ++i) {
    if (i > 1) CStrUtil::printf(" ");

    PSViewToken *token = array_->getValue(i);

    token->print();
  }

  if (! isExecutable())
    CStrUtil::printf("]");
  else
    CStrUtil::printf("}");
}

string
PSViewArrayToken::
toString()
{
  return "--nostringval--";
}
##concat##CPSViewBooleanToken.cpp
#include <CPSViewI.h>

PSViewBooleanToken::
PSViewBooleanToken(CPSView *psview, PSVboolean value) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_BOOLEAN,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(value)
{
}

PSViewBooleanToken::
PSViewBooleanToken(const PSViewBooleanToken &boolean_token) :
 PSViewToken(boolean_token), value_(boolean_token.value_)
{
}

PSViewBooleanToken::
~PSViewBooleanToken()
{
}

PSViewBooleanToken *
PSViewBooleanToken::
dup() const
{
  return new PSViewBooleanToken(*this);
}

int
PSViewBooleanToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewBooleanToken *boolean_token = dynamic_cast<PSViewBooleanToken *>(token);

    if      (value_ == boolean_token->value_)
      return 0;
    else if (value_)
      return 1;
    else
      return -1;
  }
  else
    return type_ - token->getType();
}

void
PSViewBooleanToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Boolean Missing\n");
}

const PSViewName &
PSViewBooleanToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewBooleanToken::
print()
{
  CStrUtil::printf("%s", value_ ? "true" : "false");
}

string
PSViewBooleanToken::
toString()
{
  return (value_ ? "true" : "false");
}
##concat##CPSView.cpp
#include <CPSViewI.h>
#include <CReadLine.h>

CPSView::
CPSView() :
 start_time_        (0),
 debug_             (false),
 exit_flag_         (false),
 memory_mgr_        (),
 name_mgr_          (),
 resource_mgr_      (),
 dictionary_mgr_    (),
 operator_mgr_      (),
 operand_stack_     (),
 execution_stack_   (),
 graphics_stack_    (),
 graphics_          (NULL),
 gstate_mgr_        (),
 gstate_token_mgr_  (),
 token_mgr_         (),
 error_mgr_         (),
 mark_token_        (),
 current_file_      (NULL),
 current_file_stack_()
{
  if (getenv("PSVIEW_DEBUG") != NULL)
    debug_ = true;

  memory_mgr_     = new PSViewMemoryMgr(this);
  name_mgr_       = new PSViewNameMgr  (this);
  resource_mgr_   = new PSViewResourceMgr(this);
  dictionary_mgr_ = new PSViewDictionaryMgr(this);
  operator_mgr_   = new PSViewOperatorMgr(this);

  operand_stack_   = new PSViewOperandStack  (this);
  execution_stack_ = new PSViewExecutionStack(this);
  graphics_stack_  = new PSViewGraphicsStack (this);

  gstate_mgr_       = new PSViewGStateMgr(this);
  gstate_token_mgr_ = new PSViewGStateTokenMgr(this);

  token_mgr_ = new PSViewTokenMgr(this);
  error_mgr_ = new PSViewErrorMgr(this);

  mark_token_ = new PSViewMarkToken(this);

  operator_mgr_  ->init();
  dictionary_mgr_->init();

  init();
}

CPSView::
~CPSView()
{
  term();
}

void
CPSView::
setDebug(bool flag)
{
  debug_ = flag;
}

void
CPSView::
setExitFlag(bool flag)
{
  exit_flag_ = flag;
}

void
CPSView::
init()
{
  start_time_ = time(NULL);

  getErrorMgr()->setError(false);

  exit_flag_ = false;

  getMemoryMgr     ()->init();
  getGStateMgr     ()->init();
  getGStateTokenMgr()->init();
  getResourceMgr   ()->init();
}

void
CPSView::
term()
{
}

void
CPSView::
setRenderer(CPSViewRenderer *renderer)
{
  graphics_ = renderer;
}

void
CPSView::
openCurrentFile(const string &filename)
{
  PSViewTextFileToken *token = new PSViewTextFileToken(this, filename, "r");

  if (token == NULL) {
    getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_FILENAME);
    return;
  }

  if (current_file_ != NULL)
    current_file_stack_.push_back(current_file_);

  current_file_ = token;
}

void
CPSView::
closeCurrentFile()
{
  if (current_file_ != NULL)
    current_file_->close();

  /* Print any remaining Stack Tokens */

  if (getDebug()) {
    CStrUtil::printf("Stack : ");
    operand_stack_->print();
    CStrUtil::printf("\n");
  }

  if (current_file_stack_.size() > 0) {
    current_file_ = current_file_stack_[current_file_stack_.size() - 1];

    current_file_stack_.pop_back();
  }
  else
    current_file_ = NULL;
}

void
CPSView::
setCurrentFile(PSViewFileToken *token)
{
  current_file_ = token;
}

PSViewFileToken *
CPSView::
getCurrentFile()
{
  return current_file_;
}

void
CPSView::
executeCurrentFile()
{
  if (current_file_ == NULL)
    return;

  /* Check First Line */

  if (! current_file_->initPostScript()) {
    CStrUtil::eprintf("PSView: Invalid PostScript File %s\n",
                      current_file_->getFileName().c_str());

    return;
  }

  /* Read and Execute each Token in the File */

  PSViewToken *token;

  while ((token = current_file_->readToken()) != NULL) {
    if (token->isProcedure())
      operand_stack_->push(token);
    else
      token->execute();

    if (current_file_ == NULL || getErrorMgr()->getError())
      break;
  }
}

void
CPSView::
executive()
{
  PSViewOperatorMgr::executiveOp(getOperatorMgr());
}

bool
CPSView::
getLine(string &line)
{
  CReadLine readline;

  line = readline.readLine();

  if (readline.eof())
    return false;

  return true;
}
##concat##CPSViewDictionary.cpp
#include <CPSViewI.h>

const int MAX_DICTIONARY_SIZE        = 65535;
const int MAX_DICTIONARY_STACK_DEPTH = 20;
const int ERROR_DICTIONARY_SIZE      = 29;
const int SUB_ERROR_DICTIONARY_SIZE  = 10;
const int SYSTEM_DICTIONARY_SIZE     = 500;
const int GLOBAL_DICTIONARY_SIZE     = 200;
const int USER_DICTIONARY_SIZE       = 200;
const int FONT_DIRECTORY_SIZE        = 100;

const int PSVIEW_OPERAND_STACK_SIZE   = 500;
const int PSVIEW_EXECUTION_STACK_SIZE = 250;

const char *
PSViewDictionaryMgr::
standard_encoding_[256] = {
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  "space"         , "exclam"        , "quotedbl"     , "numbersign"    ,
  "dollar"        , "percent"       , "ampersand"    , "quoteright"    ,
  "parenleft"     , "parenright"    , "asterisk"     , "plus"          ,
  "comma"         , "hyphen"        , "period"       , "slash"         ,
  "zero"          , "one"           , "two"          , "three"         ,
  "four"          , "five"          , "six"          , "seven"         ,
  "eight"         , "nine"          , "colon"        , "semicolon"     ,
  "less"          , "equal"         , "greater"      , "question"      ,
  "at"            , "A"             , "B"            , "C"             ,
  "D"             , "E"             , "F"            , "G"             ,
  "H"             , "I"             , "J"            , "K"             ,
  "L"             , "M"             , "N"            , "O"             ,
  "P"             , "Q"             , "R"            , "S"             ,
  "T"             , "U"             , "V"            , "W"             ,
  "X"             , "Y"             , "Z"            , "bracketleft"   ,
  "backslash"     , "bracketright"  , "asciicircum"  , "underscore"    ,
  "quoteleft"     , "a"             , "b"            , "c"             ,
  "d"             , "e"             , "f"            , "g"             ,
  "h"             , "i"             , "j"            , "k"             ,
  "l"             , "m"             , "n"            , "o"             ,
  "p"             , "q"             , "r"            , "s"             ,
  "t"             , "u"             , "v"            , "w"             ,
  "x"             , "y"             , "z"            , "braceleft"     ,
  "bar"           , "braceright"    , "asciitilde"   , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , "exclamdown"    , "cent"         , "sterling"      ,
  "fraction"      , "yen"           , "florin"       , "section"       ,
  "currency"      , "quotesingle"   , "quotedblleft" , "guillemotleft" ,
  "guilsinglleft" , "guilsinglright", "fi"           , "fl"            ,
  NULL            , "endash"        , "dagger"       , "daggerdbl"     ,
  "periodcentered", NULL            , "paragraph"    , "bullet"        ,
  "quotesinglbase", "quotedblbase"  , "quotedblright", "guillemotright",
  "ellipsis"      , "perthousand"   , NULL           , "questiondown"  ,
  NULL            , "grave"         , "acute"        , "circumflex"    ,
  "tilde"         , "macron"        , "breve"        , "dotaccent"     ,
  "dieresis"      , NULL            , "ring"         , "cedilla"       ,
  NULL            , "hungarumlaut"  , "ogonek"       , "caron"         ,
  "emdash"        , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , "AE"            , NULL           , "ordfeminine"   ,
  NULL            , NULL            , NULL           , NULL            ,
  "Lslash"        , "Oslash"        , "OE"           , "ordmasculine"  ,
  NULL            , NULL            , NULL           , NULL            ,
  NULL            , "ae"            , NULL           , NULL            ,
  NULL            , "dotlessi"      , NULL           , NULL            ,
  "lslash"        , "oslash"        , "oe"           , "germandbls"    ,
  NULL            , NULL            , NULL           , NULL            ,
};

const char *
PSViewDictionaryMgr::
error_names_[] = {
  "$error"            ,
  "configurationerror",
  "dictfull"          ,
  "dictstackoverflow" ,
  "dictstackunderflow",
  "execstackoverflow" ,
  "handleerror"       ,
  "interrupt"         ,
  "invalidaccess"     ,
  "invalidexit"       ,
  "invalidfileaccess" ,
  "invalidfont"       ,
  "invalidrestore"    ,
  "ioerror"           ,
  "limitcheck"        ,
  "nocurrentpoint"    ,
  "rangecheck"        ,
  "stackoverflow"     ,
  "stackunderflow"    ,
  "syntaxerror"       ,
  "timeout"           ,
  "typecheck"         ,
  "undefined"         ,
  "undefinedfilename" ,
  "undefinedresource" ,
  "undefinedresult"   ,
  "unmatchedmark"     ,
  "unregistered"      ,
  "VMerror"           ,
  NULL                ,
};

PSViewDictionaryMgr::
PSViewDictionaryMgr(CPSView *psview) :
 psview_              (psview),
 error_dictionary_    (),
 sub_error_dictionary_(),
 internal_dictionary_ (),
 dictionary_stack_    ()
{
}

PSViewDictionaryMgr::
~PSViewDictionaryMgr()
{
}

void
PSViewDictionaryMgr::
init()
{
  dictionary_stack_.clear();

  //------

  createError();

  //------

  PSViewDictionaryToken *dictionary = createSystem();

  beginDictionary(dictionary);

  //------

  dictionary = createGlobal();

  beginDictionary(dictionary);

  //------

  dictionary = createUser();

  beginDictionary(dictionary);

  //------

  internal_dictionary_ = new PSViewDictionaryToken(this, 100);
}

void
PSViewDictionaryMgr::
createError()
{
  error_dictionary_ = new PSViewDictionaryToken(this, ERROR_DICTIONARY_SIZE);

  //------

  for (int i = 0; error_names_[i] != NULL; ++i) {
    PSViewToken *value = new PSViewNullToken(getPSView());

    error_dictionary_->addValue(error_names_[i], value);
  }

  //------

  sub_error_dictionary_ = new PSViewDictionaryToken(this, SUB_ERROR_DICTIONARY_SIZE);

  PSViewToken *value = new PSViewBooleanToken(getPSView(), false);

  sub_error_dictionary_->addValue("newerror", value);

  value = new PSViewNameToken(getPSView(), "");

  sub_error_dictionary_->addValue("errorname", value);

  value = new PSViewNullToken(getPSView());

  sub_error_dictionary_->addValue("command", value);

  value = new PSViewArrayToken(getPSView(), 1);

  sub_error_dictionary_->addValue("errorinfo", value);

  value = new PSViewArrayToken(getPSView(), 1);

  sub_error_dictionary_->addValue("ostack", value);

  value = new PSViewArrayToken(getPSView(), 1);

  sub_error_dictionary_->addValue("estack", value);

  value = new PSViewArrayToken(getPSView(), 1);

  sub_error_dictionary_->addValue("dstack", value);

  value = new PSViewBooleanToken(getPSView(), true);

  sub_error_dictionary_->addValue("recordstacks", value);

  value = new PSViewBooleanToken(getPSView(), false);

  sub_error_dictionary_->addValue("binary", value);
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
createSystem()
{
  PSViewDictionaryToken *dictionary = new PSViewDictionaryToken(this, SYSTEM_DICTIONARY_SIZE);

  //------

  getPSView()->getOperatorMgr()->addSystemOperators(dictionary);

  //------

  dictionary->setReadOnly();

  //------

  PSViewToken *value = new PSViewDictionaryToken(this, FONT_DIRECTORY_SIZE);

  dictionary->addValue("FontDirectory", value);

  //------

  PSViewArrayToken *array_token = new PSViewArrayToken(getPSView(), 256);

  dictionary->addValue("StandardEncoding", array_token);

  PSViewToken *sub_value;

  for (int i = 0; i < 256; ++i) {
    if (standard_encoding_[i] != NULL)
      sub_value = new PSViewNameToken(getPSView(), standard_encoding_[i]);
    else
      sub_value = new PSViewNameToken(getPSView(), ".notdef");

    array_token->setValue(i + 1, sub_value);
  }

  //------

  dictionary->addValue("errordict", error_dictionary_);

  dictionary->addValue("$error", sub_error_dictionary_);

  //------

  value = new PSViewDictionaryToken(this, 11);

  dictionary->addValue("statusdict", value);

  //------

  value = new PSViewStringToken(getPSView(), 128);

  dictionary->addValue("=string", value);

  //------

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
createGlobal()
{
  PSViewDictionaryToken *dictionary = new PSViewDictionaryToken(this, GLOBAL_DICTIONARY_SIZE);

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
createUser()
{
  PSViewDictionaryToken *dictionary = new PSViewDictionaryToken(this, USER_DICTIONARY_SIZE);

  //------

  PSViewToken *value;

  value = new PSViewIntegerToken(getPSView(), PSVIEW_OPERAND_STACK_SIZE);

  dictionary->addValue("MaxOpStack", value);

  value = new PSViewIntegerToken(getPSView(), MAX_DICTIONARY_STACK_DEPTH);

  dictionary->addValue("MaxDictStack", value);

  value = new PSViewIntegerToken(getPSView(), PSVIEW_EXECUTION_STACK_SIZE);

  dictionary->addValue("MaxExecStack", value);

  return dictionary;
}

int
PSViewDictionaryMgr::
getNumDictionaries()
{
  return dictionary_stack_.size();
}

void
PSViewDictionaryMgr::
addToCurrent(PSViewToken *key, PSViewToken *value)
{
  PSViewDictionaryToken *dictionary = getCurrentDictionary();

  if (! dictionary->getWritable()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);
    return;
  }

  dictionary->addValue(key, value);
}

PSViewToken *
PSViewDictionaryMgr::
lookup(const string &str)
{
  const PSViewName &name = getPSView()->getNameMgr()->getName(str);

  PSViewToken *token = lookup(name);

  return token;
}

PSViewToken *
PSViewDictionaryMgr::
lookup(PSViewToken *key)
{
  int num = dictionary_stack_.size();

  for (int i = num - 1; i >= 0; --i) {
    PSViewDictionaryToken *dictionary = dictionary_stack_[i];

    PSViewToken *token = dictionary->getValue(key);

    if (token != NULL)
      return token;
  }

  return NULL;
}

PSViewToken *
PSViewDictionaryMgr::
lookup(const PSViewName &name)
{
  int num = dictionary_stack_.size();

  for (int i = num - 1; i >= 0; --i) {
    PSViewDictionaryToken *dictionary = dictionary_stack_[i];

    PSViewToken *token = dictionary->getValue(name);

    if (token != NULL)
      return token;
  }

  return NULL;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
lookupDictionary(const string &str)
{
  const PSViewName &name = getPSView()->getNameMgr()->getName(str);

  PSViewDictionaryToken *dictionary = lookupDictionary(name);

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
lookupDictionary(const PSViewName &name)
{
  int num = dictionary_stack_.size();

  for (int i = num - 1; i >= 0; --i) {
    PSViewDictionaryToken *dictionary = dictionary_stack_[i];

    PSViewToken *token = dictionary->getValue(name);

    if (token != NULL)
      return dictionary;
  }

  return NULL;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
lookupDictionary(PSViewToken *key)
{
  int num = dictionary_stack_.size();

  for (int i = num - 1; i >= 0; i--) {
    PSViewDictionaryToken *dictionary = dictionary_stack_[i];

    PSViewToken *token = dictionary->getValue(key);

    if (token != NULL)
      return dictionary;
  }

  return NULL;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
getSystemDictionary()
{
  PSViewDictionaryToken *dictionary = dictionary_stack_[0];

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
getGlobalDictionary()
{
  PSViewDictionaryToken *dictionary = dictionary_stack_[1];

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
getUserDictionary()
{
  PSViewDictionaryToken *dictionary = dictionary_stack_[2];

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
getInternalDictionary()
{
  return internal_dictionary_;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
getCurrentDictionary()
{
  PSViewDictionaryToken *dictionary = dictionary_stack_[dictionary_stack_.size() - 1];

  return dictionary;
}

PSViewDictionaryToken *
PSViewDictionaryMgr::
getDictionary(int num)
{
  PSViewDictionaryToken *dictionary = dictionary_stack_[num - 1];

  return dictionary;
}

void
PSViewDictionaryMgr::
beginDictionary(PSViewDictionaryToken *dictionary)
{
  dictionary_stack_.push_back(dictionary);
}

void
PSViewDictionaryMgr::
endDictionary()
{
  int num = dictionary_stack_.size();

  if (num <= 3) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_DICT_STACK_UNDERFLOW);

    return;
  }

  dictionary_stack_.pop_back();
}

void
PSViewDictionaryMgr::
emptyDictionaryStack()
{
  int num = dictionary_stack_.size();

  while (num > 3) {
    dictionary_stack_.pop_back();

    num--;
  }
}

//------------------

PSViewDictionary::
PSViewDictionary(PSViewDictionaryMgr *mgr, PSVinteger max_length) :
 mgr_    (mgr),
 keyvals_(),
 start_  (0),
 end_    (max_length - 1),
 used_   (0)
{
}

PSViewDictionary::
PSViewDictionary(const PSViewDictionary &dictionary) :
 mgr_    (dictionary.mgr_),
 keyvals_(),
 start_  (0),
 end_    (0),
 used_   (0)
{
  int size = dictionary.end_ + 1;

  end_ = size - 1;

  for (int i = 1; i <= dictionary.used_; ++i) {
    PSViewKeyValue *key_value = dictionary.getKeyValue(i);

    PSViewToken *key   = key_value->getKey  ()->dup();
    PSViewToken *value = key_value->getValue()->dup();

    addValue(key, value);
  }
}

PSViewDictionary::
~PSViewDictionary()
{
}

PSViewDictionary *
PSViewDictionary::
dup() const
{
  return new PSViewDictionary(*this);
}

int
PSViewDictionary::
compare(PSViewDictionary *dictionary)
{
  if      (getNumValues() > dictionary->getNumValues())
    return  1;
  else if (getNumValues() < dictionary->getNumValues())
    return -1;

  for (int i = 1; i <= getNumValues(); ++i) {
    int cmp = getKeyValue(i)->compare(dictionary->getKeyValue(i));

    if (cmp != 0)
      return cmp;
  }

  return 0;
}

int
PSViewDictionary::
getNumValues()
{
  return used_;
}

int
PSViewDictionary::
getMaxValues()
{
  return (end_ - start_ + 1);
}

PSViewKeyValue *
PSViewDictionary::
getKeyValue(int i) const
{
  if (i < 1 || i > used_)
    CTHROW("Subscript Error");

  return (PSViewKeyValue *) &keyvals_[start_ + i - 1];
}

PSViewToken *
PSViewDictionary::
getKey(int i)
{
  return getKeyValue(i)->getKey();
}

PSViewToken *
PSViewDictionary::
getValue(int i)
{
  return getKeyValue(i)->getValue();
}

PSViewToken *
PSViewDictionary::
getValue(PSViewToken *key)
{
  PSVinteger i = start_;

  for (PSVinteger j = 0; j < used_; ++j, ++i) {
    PSViewToken *key1 = keyvals_[i].getKey();

    if (key1->compare(key) == 0)
      return keyvals_[i].getValue();
  }

  return NULL;
}

PSViewToken *
PSViewDictionary::
getValue(const PSViewName &name)
{
  PSVinteger i = start_;

  for (PSVinteger j = 0; j < used_; ++j, ++i) {
    PSViewToken *key1 = keyvals_[i].getKey();

    if (key1->getName().compare(name) == 0)
      return keyvals_[i].getValue();
  }

  return NULL;
}

PSViewToken *
PSViewDictionary::
getValue(const string &str)
{
  const PSViewName &name = getPSView()->getNameMgr()->getName(str);

  return getValue(name);
}

void
PSViewDictionary::
setValue(PSVinteger pos, PSViewToken *key, PSViewToken *value)
{
  if (pos < 1 || pos > used_)
    CTHROW("Subscript Error");

  keyvals_[start_ + pos - 1].setKeyValue(key, value);
}

void
PSViewDictionary::
resize()
{
  long num_keyvals = end_ - start_ + 1;

  if (num_keyvals >= MAX_DICTIONARY_SIZE) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_DICT_FULL);
    return;
  }

  long num_keyvals1 = (2*num_keyvals + 1) % MAX_DICTIONARY_SIZE;

  keyvals_.resize(num_keyvals1 + 1);

  start_ = 0;
  end_   = num_keyvals1 - 1;
}

void
PSViewDictionary::
addValue(const string &name, PSViewToken *value)
{
  PSViewToken *key = new PSViewNameToken(getPSView(), name);

  addValue(key, value);
}

void
PSViewDictionary::
addValue(const PSViewName &key, PSViewToken *value)
{
  PSViewToken *key1 = new PSViewNameToken(getPSView(), key);

  addValue(key1, value);
}

void
PSViewDictionary::
addValue(PSViewToken *key, PSViewToken *value)
{
  int i = start_;

  for (int j = 0; j < used_; ++j) {
    if (keyvals_[i].getKey()->compare(key) == 0) {
      keyvals_[i].setValue(value);
      return;
    }

    ++i;
  }

  PSVinteger ind = start_ + used_;

  if (ind > end_) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_DICT_FULL);

    return;
  }

  keyvals_.push_back(PSViewKeyValue());

  keyvals_[ind].setKeyValue(key, value);

  ++used_;
}

void
PSViewDictionary::
deleteValue(PSViewToken *key)
{
  int i = start_;

  int j = 0;

  for ( ; j < used_; ++j) {
    if (keyvals_[i].getKey()->compare(key) == 0)
      break;

    ++i;
  }

  if (j >= used_)
    CTHROW("Dictionary Entry Not Found");

  --used_;

  for ( ; j < used_; ++j)
    keyvals_[i].setKeyValue(keyvals_[i + 1]);

  keyvals_.pop_back();
}

void
PSViewDictionary::
clear()
{
  used_ = 0;

  keyvals_.clear();
}

//-------

PSViewKeyValue::
PSViewKeyValue(PSViewToken *key, PSViewToken *value) :
 key_(key), value_(value)
{
}

int
PSViewKeyValue::
compare(PSViewKeyValue *key_value)
{
  int cmp = key_->compare(key_value->key_);

  if (cmp != 0)
    return cmp;

  return value_->compare(key_value->value_);
}

PSViewToken *
PSViewKeyValue::
getKey()
{
  return key_;
}

PSViewToken *
PSViewKeyValue::
getValue()
{
  return value_;
}

void
PSViewKeyValue::
setKey(PSViewToken *key)
{
  key_ = key;
}

void
PSViewKeyValue::
setValue(PSViewToken *value)
{
  value_ = value;
}

void
PSViewKeyValue::
setKeyValue(PSViewToken *key, PSViewToken *value)
{
  key_   = key;
  value_ = value;
}

void
PSViewKeyValue::
setKeyValue(const PSViewKeyValue &key_value)
{
  key_   = key_value.key_;
  value_ = key_value.value_;
}
##concat##CPSViewDictionaryToken.cpp
#include <CPSViewI.h>

PSViewDictionaryToken::
PSViewDictionaryToken(PSViewDictionaryMgr *mgr, PSVinteger max_length) :
 PSViewToken(mgr->getPSView(), PSVIEW_TOKEN_TYPE_DICTIONARY,
             PSVIEW_TOKEN_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 mgr_       (mgr),
 dictionary_()
{
  dictionary_ = new PSViewDictionary(mgr, max_length);
}

PSViewDictionaryToken::
PSViewDictionaryToken(const PSViewDictionaryToken &dictionary_token) :
 PSViewToken(dictionary_token),
 mgr_       (dictionary_token.mgr_),
 dictionary_()
{
  dictionary_ = dictionary_token.dictionary_->dup();
}

PSViewDictionaryToken::
~PSViewDictionaryToken()
{
}

PSViewDictionaryToken *
PSViewDictionaryToken::
dup() const
{
  return new PSViewDictionaryToken(*this);
}

int
PSViewDictionaryToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewDictionaryToken *dictionary_token = dynamic_cast<PSViewDictionaryToken *>(token);

    return dictionary_->compare(dictionary_token->dictionary_);
  }
  else
    return type_ - token->getType();
}

void
PSViewDictionaryToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Dictionary Missing\n");
}

const PSViewName &
PSViewDictionaryToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewDictionaryToken::
print()
{
  CStrUtil::printf("-dict-");

  if (psview_->getDebug()) {
    print();

    CStrUtil::printf("<<");

    for (int i = 1; i <= getNumValues(); i++) {
      if (i > 1) CStrUtil::printf(" ");

      getKey(i)->print();

      CStrUtil::printf(" ");

      getValue(i)->print();
    }

    CStrUtil::printf(">>\n");
  }
}

string
PSViewDictionaryToken::
toString()
{
  return "--nostringval--";
}

int
PSViewDictionaryToken::
getNumValues()
{
  return dictionary_->getNumValues();
}

int
PSViewDictionaryToken::
getMaxValues()
{
  return dictionary_->getMaxValues();
}

void
PSViewDictionaryToken::
setValue(PSVinteger pos, PSViewToken *key, PSViewToken *value)
{
  if (getGlobal() && (key->getLocal() || value->getLocal())) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);
    return;
  }

  if (key->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) key;

    key = new PSViewNameToken(string_token);
  }

  dictionary_->setValue(pos, key, value);
}

void
PSViewDictionaryToken::
setValue(PSVinteger pos, const PSViewName &key, PSViewToken *value)
{
  if (getGlobal() && value->getLocal()) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);
    return;
  }

  PSViewToken *key1 = new PSViewNameToken(psview_, key);

  dictionary_->setValue(pos, key1, value);
}

void
PSViewDictionaryToken::
setValue(PSVinteger pos, const string &key, PSViewToken *value)
{
  if (getGlobal() && value->getLocal()) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);
    return;
  }

  PSViewToken *key1 = new PSViewNameToken(psview_, key);

  dictionary_->setValue(pos, key1, value);
}

void
PSViewDictionaryToken::
addValue(PSViewToken *key, PSViewToken *value)
{
  if (getGlobal() && (key->getLocal() || value->getLocal()))
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);

  if (key->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) key;

    key = new PSViewNameToken(string_token);
  }

  dictionary_->addValue(key, value);
}

void
PSViewDictionaryToken::
addValue(const PSViewName &key, PSViewToken *value)
{
  dictionary_->addValue(key, value);
}

void
PSViewDictionaryToken::
addValue(const string &key, PSViewToken *value)
{
  dictionary_->addValue(key, value);
}

PSViewKeyValue *
PSViewDictionaryToken::
getKeyValue(int i)
{
  return dictionary_->getKeyValue(i);
}

PSViewToken *
PSViewDictionaryToken::
getKey(int i)
{
  return dictionary_->getKey(i);
}

PSViewToken *
PSViewDictionaryToken::
getValue(int i)
{
  return dictionary_->getValue(i);
}

PSViewToken *
PSViewDictionaryToken::
getValue(PSViewToken *key)
{
  return dictionary_->getValue(key);
}

PSViewToken *
PSViewDictionaryToken::
getValue(const PSViewName &key)
{
  return dictionary_->getValue(key);
}

PSViewToken *
PSViewDictionaryToken::
getValue(const string &key)
{
  return dictionary_->getValue(key);
}

void
PSViewDictionaryToken::
deleteValue(PSViewToken *key)
{
  dictionary_->deleteValue(key);
}

void
PSViewDictionaryToken::
resize()
{
  dictionary_->resize();
}

void
PSViewDictionaryToken::
clear()
{
  dictionary_->clear();
}
##concat##CPSViewError.cpp
#include <CPSViewI.h>
#include <COSEnv.h>
#include <COSEnv.h>
#include <signal.h>

string
PSViewErrorMgr::
error_names_[] = {
  "configurationerror",
  "dictfull",
  "dictstackoverflow",
  "dictstackunderflow",
  "execstackoverflow",
  "handleerror",
  "interrupt",
  "invalidaccess",
  "invalidexit",
  "invalidfileaccess",
  "invalidfont",
  "invalidrestore",
  "ioerror",
  "limitcheck",
  "nocurrentpoint",
  "rangecheck",
  "stackoverflow",
  "stackunderflow",
  "syntaxerror",
  "timeout",
  "typecheck",
  "undefined",
  "undefinedfilename",
  "undefinedresource",
  "undefinedresult",
  "unmatchedmark",
  "unregistered",
};

PSViewErrorMgr::
PSViewErrorMgr(CPSView *psview) :
 psview_     (psview),
 error_token_(NULL),
 error_name_ (NULL),
 error_flag_ (false)
{
}

PSViewErrorMgr::
~PSViewErrorMgr()
{
}

void
PSViewErrorMgr::
raise(PSViewErrorType type)
{
  if (CEnvInst.exists("PSVIEW_ERROR_EXIT")) {
    cerr << error_names_[type] << endl;
    exit(1);
  }

  if (CEnvInst.exists("PSVIEW_ERROR_SEGV")) {
    cerr << error_names_[type] << endl;
    ::raise(SIGSEGV);
  }

  error_token_ = getPSView()->getTokenMgr()->getLastExecuteToken();

  if (error_token_ != NULL)
    getPSView()->getOperandStack()->push(error_token_);

  PSViewToken *value = getPSView()->getDictionaryMgr()->lookup("errordict");

  if (! value->isDictionary())
    CTHROW("Bad errordict");

  PSViewDictionaryToken *error_dict = (PSViewDictionaryToken *) value;

  error_name_ = new PSViewNameToken(getPSView(), error_names_[type]);

  PSViewToken *error_handler = error_dict->getValue(error_name_);

  if (error_handler->isNull())
    defaultErrorHandler();
  else
    error_handler->execute();
}

void
PSViewErrorMgr::
defaultErrorHandler()
{
  static bool inErrorHandler;

  if (inErrorHandler)
    return;

  inErrorHandler = true;

  /*--------------*/

  PSViewToken *value = getPSView()->getDictionaryMgr()->lookup("$error");

  if (! value->isDictionary())
    CTHROW("Bad $error");

  PSViewDictionaryToken *error_dict = (PSViewDictionaryToken *) value;

  /*--------------*/

  value = new PSViewBooleanToken(getPSView(), true);

  error_dict->addValue("newerror", value);

  /*--------------*/

  error_dict->addValue("errorname", error_name_);

  /*--------------*/

  error_dict->addValue("command", error_token_);

  /*--------------*/

  value = new PSViewArrayToken(getPSView(), 1);

  error_dict->addValue("errorinfo", value);

  /*--------------*/

  int num = getPSView()->getOperandStack()->size();

  PSViewArrayToken *array_token = new PSViewArrayToken(getPSView(), num);

  for (int i = 1; i <= num; i++)
    array_token->setValue(i, getPSView()->getOperandStack()->peek(i));

  error_dict->addValue("ostack", array_token);

  /*--------------*/

  num = getPSView()->getExecutionStack()->size();

  array_token = new PSViewArrayToken(getPSView(), num);

  for (int i = 1; i <= num; i++)
    array_token->setValue(i, getPSView()->getExecutionStack()->peek(i));

  error_dict->addValue("estack", array_token);

  /*--------------*/

  num = getPSView()->getDictionaryMgr()->getNumDictionaries();

  array_token = new PSViewArrayToken(getPSView(), num);

  for (int i = 1; i <= num; i++)
    array_token->setValue(i, getPSView()->getDictionaryMgr()->getDictionary(i));

  error_dict->addValue("dstack", array_token);

  /*--------------*/

  value = new PSViewBooleanToken(getPSView(), true);

  error_dict->addValue("recordstack", value);

  /*--------------*/

  value = new PSViewBooleanToken(getPSView(), false);

  error_dict->addValue("binary", value);

  /*--------------*/

  value = getPSView()->getDictionaryMgr()->lookup("stop");

  value->execute();

  /*--------------*/

  inErrorHandler = false;
}

void
PSViewErrorMgr::
defaultHandleError()
{
  CStrUtil::eprintf("PSView: ");

  /*--------------*/

  PSViewToken *value = getPSView()->getDictionaryMgr()->lookup("$error");

  if (! value->isDictionary())
    CTHROW("Bad $error");

  PSViewDictionaryToken *error_dict = (PSViewDictionaryToken *) value;

  /*--------------*/

  value = error_dict->getValue("errorname");

  value->print();

  /*--------------*/

  CStrUtil::eprintf("  Last Executed ");

  /*--------------*/

  value = error_dict->getValue("command");

  value->print();

  /*--------------*/

  value = new PSViewBooleanToken(getPSView(), false);

  error_dict->addValue("newerror", value);
}

void
PSViewErrorMgr::
setError(bool flag)
{
  error_flag_ = flag;
}

bool
PSViewErrorMgr::
getError()
{
  return error_flag_;
}
##concat##CPSViewFile.cpp
#include <CPSViewI.h>

string PSViewFile::ascii85_chars_ =
"!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuz";

string PSViewFile::delim_chars_ = "()<>[]{}/%";

PSViewFile::
PSViewFile(CPSView *psview) :
 psview_(psview)
{
}

PSViewFile::
PSViewFile(const PSViewFile &file) :
 psview_(file.psview_)
{
}

PSViewFile::
~PSViewFile()
{
}

PSViewToken *
PSViewFile::
readToken()
{
  skipSpace();

  int c = lookChar();

  while (c == '%') {
    string str;

    str += readChar();

    c = lookChar();

    while (c != EOF && c != '\n' && c != '\f') {
      str += readChar();

      c = lookChar();
    }

    if (c == '\n' || c == '\f')
      readChar();

    if      (str == "%%DebugOn" )
      getPSView()->setDebug(true);
    else if (str == "%%DebugOff")
      getPSView()->setDebug(false);

    skipSpace();

    c = lookChar();
  }

  PSViewToken *token;

  token = readNumber();

  if (token == NULL)
    token = readString();

  if (token == NULL)
    token = readName();

  if (token == NULL)
    token = readProcedure();

  if (token == NULL) {
    if (isDelimiter()) {
      char delimiter_string[2];

      delimiter_string[0] = readChar();
      delimiter_string[1] = '\0';

      token = new PSViewNameToken(getPSView(), delimiter_string);
    }
  }

  if (getPSView()->getDebug()) {
    CStrUtil::printf("Read ");

    if (token != NULL)
      token->print();
    else
      CStrUtil::printf("<null>");

    CStrUtil::printf("\n");
  }

  return token;
}

PSViewToken *
PSViewFile::
readNumber()
{
  uint save_buffer_pos;

  getPosition(&save_buffer_pos);

  int c = lookChar();

  bool sign1 = false;

  string str;

  if (c == '+' || c == '-') {
    str += readChar();

    sign1 = true;
  }

  bool digits1 = false;

  while (isDigit()) {
    str += readChar();

    digits1 = true;
  }

  c = lookChar();

  PSViewToken *token = NULL;

  if (c == '.' || c == 'e' || c == 'E') {
    if (c == '.') {
      str += readChar();

      bool digits2 = false;

      while (isDigit()) {
        str += readChar();

        digits2 = true;
      }

      if (! digits1 && ! digits2)
        goto fail;

      c = lookChar();
    }

    if (c == 'e' || c == 'E') {
      str += readChar();

      c = lookChar();

      if (c == '+' || c == '-')
        str += readChar();

      if (! isDigit())
        goto fail;

      while (isDigit())
        str += readChar();
    }

    if (! isSeparator())
      goto fail;

    double real = CStrUtil::toReal(str);

    token = new PSViewRealToken(getPSView(), real);
  }
  else if (c == '#' && ! sign1 && digits1) {
    int integer;

    if (! CStrUtil::isInteger(str))
      goto fail;

    int base = CStrUtil::toInteger(str);

    if (base < 2 || base > 36)
      goto fail;

    c = readChar();

    if (! isBaseDigit(base))
      goto fail;

    str = "";

    while (isBaseDigit(base))
      str += readChar();

    if (! isSeparator())
      goto fail;

    if (! CStrUtil::isBaseInteger(str, base))
      goto fail;

    integer = CStrUtil::toBaseInteger(str, base);

    token = new PSViewIntegerToken(getPSView(), integer);
  }
  else if (digits1 && isSeparator()) {
    if (CStrUtil::isInteger(str)) {
      long integer = CStrUtil::toInteger(str);

      token = new PSViewIntegerToken(getPSView(), integer);
    }
    else {
      double real = CStrUtil::toReal(str);

      token = new PSViewRealToken(getPSView(), real);
    }
  }
  else
    goto fail;

  return token;

 fail:
  setPosition(save_buffer_pos);

  return NULL;
}

PSViewToken *
PSViewFile::
readString()
{
  uint save_buffer_pos;

  getPosition(&save_buffer_pos);

  int c = lookChar();

  if (c == '(') {
    readChar();

    PSVinteger num_brackets = 1;

    c = lookChar();

    string str;

    while (c != EOF && (c != ')' || num_brackets > 1)) {
      if      (c == '\\') {
        readChar();

        c = lookChar();

        if      (c == '\r' || c == '\n') {
          readChar();

          if (c == '\r') {
            c = lookChar();

            if (c == '\n')
              readChar();
          }
        }
        else if (c == 'n') {
          str += '\n';

          readChar();
        }
        else if (c == 'r') {
          str += '\r';

          readChar();
        }
        else if (c == 't') {
          str += '\t';

          readChar();
        }
        else if (c == 'b') {
          str += '\b';

          readChar();
        }
        else if (c == 'f') {
          str += '\f';

          readChar();
        }
        else if (c == '\\') {
          str += '\\';

          readChar();
        }
        else if (c == '(') {
          str += '(';

          readChar();
        }
        else if (c == ')') {
          str += ')';

          readChar();
        }
        else if (CStrUtil::isBaseChar(c, 8)) {
          int   octal_value;
          char  octal_string[4];

          octal_string[0] = readChar();

          c = lookChar();

          if (CStrUtil::isBaseChar(c, 8)) {
            octal_string[1] = readChar();

            c = lookChar();

            if (CStrUtil::isBaseChar(c, 8)) {
              octal_string[2] = readChar();

              octal_string[3] = '\0';
            }
            else
              octal_string[2] = '\0';
          }
          else
            octal_string[1] = '\0';

          octal_value = CStrUtil::toBaseInteger(octal_string, 8);

          str += (char) octal_value;
        }
        else
          str += readChar();
      }
      else if (c == '(') {
        num_brackets++;

        str += readChar();
      }
      else if (c == ')') {
        num_brackets--;

        str += readChar();
      }
      else
        str += readChar();

      c = lookChar();
    }

    if (c == EOF)
      CStrUtil::eprintf("PSView: Unterminated String\n");

    readChar();

    PSViewStringToken *token = new PSViewStringToken(getPSView(), str);

    return token;
  }
  else if (c == '<') {
    readChar();

    c = lookChar();

    if (c == '~') {
      CStrUtil::eprintf("PSView: ASCII 85 Encoding not implemented\n");

      readChar();

      c = lookChar();

      while (c != EOF && isASCII85Char(c)) {
        readChar();

        c = lookChar();
      }

      if (c != '~') {
        getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_SYNTAX_ERROR);

        return NULL;
      }

      readChar();

      c = lookChar();

      if (c != '>') {
        getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_SYNTAX_ERROR);

        return NULL;
      }

      readChar();

      PSViewStringToken *token = new PSViewStringToken(getPSView(), 0L);

      return token;
    }
    else {
      char hex_string[3];

      c = lookChar();

      if (c == EOF || (! isxdigit(c) && ! isspace(c)))
        goto fail;

      int count = 0;

      string str;

      while (c != EOF && c != '>') {
        if (isspace(c)) {
          readChar();

          c = lookChar();

          continue;
        }

        if (! isxdigit(c)) {
          CStrUtil::eprintf("PSView: Invalid Hex String\n");

          goto fail;
        }

        hex_string[count++] = readChar();

        if (count == 2) {
          hex_string[count] = '\0';

          int hex_value = CStrUtil::toBaseInteger(hex_string, 16);

          str += (char) hex_value;

          count = 0;
        }

        c = lookChar();
      }

      if (count == 1) {
        hex_string[count++] = '0';

        hex_string[count] = '\0';

        int hex_value = CStrUtil::toBaseInteger(hex_string, 16);

        str += (char) hex_value;
      }

      if (c == EOF)
        CStrUtil::eprintf("PSView: Unterminated Hex String\n");

      readChar();

      PSViewStringToken *token = new PSViewStringToken(getPSView(), str);

      return token;
    }
  }

 fail:
  setPosition(save_buffer_pos);

  return NULL;
}

PSViewToken *
PSViewFile::
readName()
{
  int c1 = lookChar();

  if (c1 == '<' || c1 == '>') {
    char name_string[3];

    readChar();

    int c2 = lookChar();

    if ((c1 == '<' && c2 == '<') || (c1 == '>' && c2 == '>')) {
      readChar();

      name_string[0] = c1;
      name_string[1] = c2;
      name_string[2] = '\0';
    }
    else {
      name_string[0] = c1;
      name_string[2] = '\0';
    }

    PSViewToken *token = new PSViewNameToken(getPSView(), name_string);

    return token;
  }

  PSVboolean literal  = false;
  PSVboolean evaluate = false;

  if (c1 == '/') {
    readChar();

    int c2 = lookChar();

    if (c2 == '/') {
      readChar();

      evaluate = true;
    }
    else
      literal = true;
  }

  string str;

  while (lookChar() != EOF && ! isSeparator())
    str += readChar();

  if (str.size() == 0)
    return NULL;

  PSViewToken *token = new PSViewNameToken(getPSView(), str);

  if (evaluate) {
    PSViewToken *value = getPSView()->getDictionaryMgr()->lookup(token);

    if (value == NULL) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

      return NULL;
    }

    return value;
  }
  else {
    if (literal)
      token->setLiteral();

    return token;
  }
}

PSViewToken *
PSViewFile::
readProcedure()
{
  PSViewArrayToken *procedure_token = NULL;

  uint save_buffer_pos;

  getPosition(&save_buffer_pos);

  int c = lookChar();

  if (c != '{') {
    setPosition(save_buffer_pos);

    return NULL;
  }

  readChar();

  getPSView()->getExecutionStack()->push(getPSView()->getMarkToken());

  PSViewToken *token = readToken();

  while (token != NULL) {
    if (token->isName()) {
      PSViewNameToken *name_token = (PSViewNameToken *) token;

      const PSViewName &name = name_token->getValue();

      if (name.compare(getPSView()->getTokenMgr()->getRBraceName()) == 0) {
        int num_tokens = getPSView()->getExecutionStack()->countToMark();

        procedure_token = new PSViewArrayToken(getPSView(), num_tokens);

        for (int i = num_tokens; i >= 1; i--) {
          PSViewToken *sub_token = getPSView()->getExecutionStack()->pop();

          procedure_token->setValue(i, sub_token);
        }

        procedure_token->setExecutable();

        getPSView()->getExecutionStack()->pop();

        break;
      }
      else
        getPSView()->getExecutionStack()->push(token);
    }
    else
      getPSView()->getExecutionStack()->push(token);

    token = readToken();
  }

  return procedure_token;
}

void
PSViewFile::
skipComment()
{
  int c = lookChar();

  while (c != EOF && c != '\n' && c != '\f') {
    readChar();

    c = lookChar();
  }

  if (c == '\n' || c == '\f')
    readChar();
}

void
PSViewFile::
skipSpace()
{
  int c = lookChar();

  while (c != EOF && isspace(c)) {
    readChar();

    c = lookChar();
  }
}

PSVboolean
PSViewFile::
isBaseDigit(PSVinteger base)
{
  int c = lookChar();

  return CStrUtil::isBaseChar(c, base);
}

PSVboolean
PSViewFile::
isDigit()
{
  int c = lookChar();

  return isdigit(c);
}

PSVboolean
PSViewFile::
isSeparator()
{
  int c = lookChar();

  if (c == EOF || c == '%' || isspace(c))
    return true;

  return isDelimiter();
}

PSVboolean
PSViewFile::
isDelimiter()
{
  int c = lookChar();

  return (delim_chars_.find(c) != string::npos);
}

// TODO: Move to CStrUtil
string
PSViewFile::
charsToASCII85(uint chars)
{
  if (chars == 0)
    return "z";

  int c[5];

  for (int i = 0; i < 5; i++) {
    int temp = chars/85;

    c[i] = chars - temp*85;

    chars = temp;
  }

  string str;

  for (int i = 0; i < 5; i++)
    str += ascii85_chars_[c[4 - i]];

  return str;
}

PSVboolean
PSViewFile::
isASCII85Char(int c)
{
  return (ascii85_chars_.find(c) != string::npos);
}
##concat##CPSViewFileToken.cpp
#include <CPSViewI.h>

PSViewFileToken::
PSViewFileToken(CPSView *psview) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_FILE,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 file_      ()
{
}

PSViewFileToken::
PSViewFileToken(const PSViewFileToken &file_token) :
 PSViewToken(file_token),
 file_      ()
{
}

PSViewFileToken::
~PSViewFileToken()
{
}

int
PSViewFileToken::
compare(PSViewToken *token)
{
  if (token->isType(type_))
    return 1;
  else
    return type_ - token->getType();
}

PSVboolean
PSViewFileToken::
initPostScript()
{
  if (! file_->isReadable())
    return false;

  int c = file_->readChar();

  if (c != '%')
    return false;

  c = file_->readChar();

  if (c != '!')
    return false;

  file_->skipComment();

  return true;
}

PSViewToken *
PSViewFileToken::
readString()
{
  return file_->readString();
}
##concat##CPSViewFilterFile.cpp
#include <CPSViewI.h>

static char ps_id_chars[] = "%! \n";

class PSViewExecData {
  friend class PSViewFilterFile;

 private:
  ushort r_;
  int    initialised_;
  uint   pos_start_;
  uint   pos_end_;

 public:
  PSViewExecData();
 ~PSViewExecData();

  static uchar decrypt(uint cipher, ushort *r);
};

PSViewFilterFile::
PSViewFilterFile(PSViewFile *file, const PSViewName &name) :
 PSViewFile (file->getPSView()),
 file_      (file),
 name_      (name.getString()),
 proc_      (),
 data_      (NULL),
 mode_      (PSVIEW_FILE_MODE_TYPE_NONE),
 buffer_    (),
 buffer_pos_(0)
{
  init();
}

PSViewFilterFile::
PSViewFilterFile(PSViewFile *file, const string &name) :
 PSViewFile (file->getPSView()),
 file_      (file),
 name_      (name),
 proc_      (),
 data_      (NULL),
 mode_      (PSVIEW_FILE_MODE_TYPE_NONE),
 buffer_    (),
 buffer_pos_(0)
{
  init();
}

PSViewFilterFile::
PSViewFilterFile(const PSViewFilterFile &filter_file) :
 PSViewFile (filter_file.getPSView()),
 file_      (filter_file.file_),
 name_      (filter_file.name_),
 proc_      (),
 data_      (NULL),
 mode_      (PSVIEW_FILE_MODE_TYPE_NONE),
 buffer_    (),
 buffer_pos_(0)
{
  init();
}

PSViewFilterFile::
~PSViewFilterFile()
{
}

void
PSViewFilterFile::
init()
{
  int size = 0;

  if      (name_ == "ASCIIHexEncode") {
    proc_ = (PSViewFilterFileProc) asciiHexEncode;
    data_ = NULL;
    mode_ = PSVIEW_FILE_MODE_TYPE_WRITE;
    size  = 0;
  }
  else if (name_ == "ASCIIHexDecode") {
    proc_ = (PSViewFilterFileProc) asciiHexDecode;
    data_ = NULL;
    mode_ = PSVIEW_FILE_MODE_TYPE_READ;
    size  = 0;
  }
  else if (name_ == "ASCII85Encode") {
    proc_ = (PSViewFilterFileProc) ascii85Encode;
    data_ = NULL;
    mode_ = PSVIEW_FILE_MODE_TYPE_WRITE;
    size  = 4;
  }
  else if (name_ == "EExecDecode") {
    PSViewExecData *eexec_data = new PSViewExecData;

    proc_ = (PSViewFilterFileProc) eexecDecode;
    data_ = (char *) eexec_data;
    mode_ = PSVIEW_FILE_MODE_TYPE_READ;
    size  = 256;
  }
  else
    CTHROW("Invalid File Type" + name_);

  buffer_.resize(size + 1);

  buffer_pos_ = 0;
}

int
PSViewFilterFile::
compare(PSViewFilterFile *)
{
  return 1;
}

void
PSViewFilterFile::
flush()
{
  if (! isWritable())
    return;

  (*proc_)(this, EOF, data_);
}

bool
PSViewFilterFile::
isReadable() const
{
  return file_->isReadable();
}

bool
PSViewFilterFile::
isWritable() const
{
  if (! (mode_ & PSVIEW_FILE_MODE_TYPE_WRITE))
    return false;

  return file_->isWritable();
}

bool
PSViewFilterFile::
isValid() const
{
  return (file_ != NULL);
}

int
PSViewFilterFile::
size()
{
  if (file_ == NULL)
    return -1;

  return file_->size();
}

int
PSViewFilterFile::
bytesUsed()
{
  if (file_ == NULL)
    return -1;

  return file_->bytesUsed();
}

int
PSViewFilterFile::
bytesAvailable()
{
  if (file_ == NULL)
    return -1;

  return file_->bytesAvailable();
}

bool
PSViewFilterFile::
setPosition(uint pos)
{
  if (file_ == NULL)
    return false;

  uint pos1;

  if (! file_->getPosition(&pos1))
    return false;

  if (pos == pos1)
    return true;

  if (! file_->setPosition(pos))
    return false;

  buffer_pos_ = 0;

  return true;
}

bool
PSViewFilterFile::
getPosition(uint *pos)
{
  if (file_ == NULL)
    return false;

  return file_->getPosition(pos);
}

string
PSViewFilterFile::
getFileName()
{
  return "--filterfile--";
}

int
PSViewFilterFile::
readChar()
{
  if (! (mode_ & PSVIEW_FILE_MODE_TYPE_READ))
    return EOF;

  if (file_ == NULL)
    return EOF;

  int c = (*proc_)(this, data_, true);

  return c;
}

int
PSViewFilterFile::
lookChar()
{
  if (! (mode_ & PSVIEW_FILE_MODE_TYPE_READ))
    return EOF;

  if (file_ == NULL)
    return EOF;

  int c = (*proc_)(this, data_, false);

  return c;
}

void
PSViewFilterFile::
unreadChars(const vector<int> &chars)
{
  file_->unreadChars(chars);
}

bool
PSViewFilterFile::
loadBuffer()
{
  return false;
}

bool
PSViewFilterFile::
writeChar(int c)
{
  if (! (mode_ & PSVIEW_FILE_MODE_TYPE_WRITE))
    return false;

  (*proc_)(this, c, data_);

  return true;
}

void
PSViewFilterFile::
reset()
{
  buffer_pos_ = 0;
}

void
PSViewFilterFile::
close()
{
  if (! (mode_ & PSVIEW_FILE_MODE_TYPE_WRITE))
    return;

  (*proc_)(this, EOF, data_);

  file_->close();

  file_ = NULL;

  buffer_pos_ = 0;
}

void
PSViewFilterFile::
asciiHexEncode(PSViewFilterFile *file, int c, char *)
{
  if (c == EOF)
    return;

  string str = CStrUtil::toHexString(c, 2);

  file->file_->writeChar(str[0]);
  file->file_->writeChar(str[1]);
}

int
PSViewFilterFile::
asciiHexDecode(PSViewFilterFile *file, char *, bool consume)
{
  vector<int> chars;

  // skip space
  int c = file->file_->lookChar();

  while (c != EOF && isspace(c)) {
    c = file->file_->readChar();

    chars.push_back(c);

    c = file->file_->lookChar();
  }

  // read file hex char
  int c1 = file->file_->readChar();

  if (c1 == EOF) {
    if (! consume) file->file_->unreadChars(chars);
    return EOF;
  }

  chars.push_back(c1);

  // skip space
  c = file->file_->lookChar();

  while (c != EOF && isspace(c)) {
    c = file->file_->readChar();

    chars.push_back(c);

    c = file->file_->lookChar();
  }

  int c2 = file->file_->readChar();

  if (c2 == EOF) {
    if (! consume) file->file_->unreadChars(chars);
    return EOF;
  }

  chars.push_back(c2);

  uint v1, v2;

  if (! CStrUtil::decodeHexChar(c1, &v1) || ! CStrUtil::decodeHexChar(c2, &v2)) {
    if (! consume) file->file_->unreadChars(chars);
    return EOF;
  }

  int cc = ((v1 & 0xF) << 4) | (v2 & 0xF);

  if (! consume) file->file_->unreadChars(chars);

  return cc;
}

void
PSViewFilterFile::
ascii85Encode(PSViewFilterFile *file, int c, char *)
{
  if (c == EOF) {
    if (file->buffer_pos_ == 0)
      return;

    int pos = file->buffer_pos_;

    while (file->buffer_pos_ <= 3)
      file->buffer_[file->buffer_pos_++] = '\0';

    int chars = (file->buffer_[0] << 24) | (file->buffer_[1] << 16) |
                (file->buffer_[2] <<  8) |  file->buffer_[3];

    string str = file->charsToASCII85(chars);

    if (str == "z")
      str = "!!!!!";

    for (int i = 0; i < pos + 1; i++)
      file->file_->writeChar(str[i]);

    file->file_->writeChar('~');
    file->file_->writeChar('>');

    file->buffer_pos_ = 0;

    return;
  }

  if (file->buffer_pos_ <= 3)
    file->buffer_[file->buffer_pos_++] = c;

  if (file->buffer_pos_ == 4) {
    int chars = (file->buffer_[0] << 24) | (file->buffer_[1] << 16) |
                (file->buffer_[2] <<  8) |  file->buffer_[3];

    string str = file->charsToASCII85(chars);

    int len = str.size();

    for (int i = 0; i < len; i++)
      file->file_->writeChar(str[i]);

    file->buffer_pos_ = 0;
  }
}

int
PSViewFilterFile::
eexecDecode(PSViewFilterFile *file, char *data, bool consume)
{
  PSViewExecData *eexec_data = (PSViewExecData *) data;

  uint pos;

  file->getPosition(&pos);

  if (! eexec_data->initialised_) {
    eexec_data->initialised_ = true;

    eexec_data->pos_start_ = pos;
    eexec_data->pos_end_   = pos;

    int i = 0;

    while (true) {
      file->skipSpace();

      string str = "XX";

      str[0] = file->readChar();

      if (str[0] == EOF || ! isxdigit(str[0]))
        break;

      if (str[0] == '0') {
        int zero_count = 1;

        uint save_pos;

        file->getPosition(&save_pos);

        file->skipSpace();

        str[1] = file->lookChar();

        while (str[1] == '0') {
          zero_count++;

          file->readChar();

          file->skipSpace();

          str[1] = file->lookChar();
        }

        if (zero_count == 512)
          break;

        file->setPosition(save_pos);
      }

      file->skipSpace();

      str[1] = file->readChar();

      if (str[1] == EOF || ! isxdigit(str[1]))
        break;

      uint c;

      sscanf(str.c_str(), "%x", &c);

      c = PSViewExecData::decrypt(c, &eexec_data->r_);

      if (i < 4)
        c = ps_id_chars[i];

      if (i >= (int) file->buffer_.size())
        file->buffer_.resize(2*file->buffer_.size() + 3);

      file->buffer_[i++] = c;
    }

    file->buffer_[i] = EOF;

    uint save_pos;

    file->getPosition(&save_pos);

    eexec_data->pos_end_ = save_pos;

    file->setPosition(pos);
  }

  if (pos < eexec_data->pos_start_ || pos > eexec_data->pos_end_)
    return EOF;

  int i = (pos - eexec_data->pos_start_)/2;

  int c = file->buffer_[i];

  if (consume) {
    file->readChar();
    file->readChar();
  }

  return c;
}

PSViewExecData::
PSViewExecData() :
 r_          (55665),
 initialised_(false),
 pos_start_  (0),
 pos_end_    (0)
{
}

uchar
PSViewExecData::
decrypt(uint cipher, ushort *r)
{
  static ushort c1 = 52845;
  static ushort c2 = 22719;

  uchar plain = (cipher ^ (*r >> 8));

  *r = (cipher + *r)*c1 + c2;

  return plain;
}
##concat##CPSViewFilterFileToken.cpp
#include <CPSViewI.h>

PSViewFilterFileToken::
PSViewFilterFileToken(PSViewFileToken *token, const PSViewName &name) :
 PSViewFileToken(token->getPSView()),
 filter_file_    ()
{
  PSViewFile *file = token->getFile();

  filter_file_ = new PSViewFilterFile(file, name);

  file_ = filter_file_;
}

PSViewFilterFileToken::
PSViewFilterFileToken(PSViewFileToken *token, const string &name) :
 PSViewFileToken(token->getPSView()),
 filter_file_    ()
{
  PSViewFile *file = token->getFile();

  filter_file_ = new PSViewFilterFile(file, name);

  file_ = filter_file_;
}

PSViewFilterFileToken::
PSViewFilterFileToken(const PSViewFilterFileToken &filter_file_token) :
 PSViewFileToken(filter_file_token),
 filter_file_    ()
{
  filter_file_ = new PSViewFilterFile(*filter_file_token.filter_file_);

  file_ = filter_file_;
}

PSViewFilterFileToken::
~PSViewFilterFileToken()
{
}

PSViewFilterFileToken *
PSViewFilterFileToken::
dup() const
{
  return new PSViewFilterFileToken(*this);
}

int
PSViewFilterFileToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewFilterFileToken *filter_file_token = dynamic_cast<PSViewFilterFileToken *>(token);

    return filter_file_->compare(filter_file_token->filter_file_);
  }
  else
    return type_ - token->getType();
}

void
PSViewFilterFileToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Filter File Missing\n");
}

void
PSViewFilterFileToken::
print()
{
  CStrUtil::printf("-file-");
}

string
PSViewFilterFileToken::
toString()
{
  return "--nostringval--";
}

void
PSViewFilterFileToken::
flush()
{
  filter_file_->flush();
}

PSViewToken *
PSViewFilterFileToken::
readToken()
{
  return filter_file_->readToken();
}

bool
PSViewFilterFileToken::
isReadable() const
{
  return filter_file_->isReadable();
}

bool
PSViewFilterFileToken::
isWritable() const
{
  return filter_file_->isWritable();
}

bool
PSViewFilterFileToken::
isValid() const
{
  return filter_file_->isValid();
}

int
PSViewFilterFileToken::
size()
{
  return filter_file_->size();
}

int
PSViewFilterFileToken::
bytesUsed()
{
  return filter_file_->bytesUsed();
}

uint
PSViewFilterFileToken::
bytesAvailable()
{
  return filter_file_->bytesAvailable();
}

PSVboolean
PSViewFilterFileToken::
setPosition(uint pos)
{
  return filter_file_->setPosition(pos);
}

PSVboolean
PSViewFilterFileToken::
getPosition(uint *pos)
{
  return filter_file_->getPosition(pos);
}

string
PSViewFilterFileToken::
getFileName()
{
  return filter_file_->getFileName();
}

int
PSViewFilterFileToken::
readChar()
{
  return filter_file_->readChar();
}

int
PSViewFilterFileToken::
lookChar()
{
  return filter_file_->lookChar();
}

bool
PSViewFilterFileToken::
loadBuffer()
{
  return filter_file_->loadBuffer();
}

PSVboolean
PSViewFilterFileToken::
writeChar(PSVchar c)
{
  return filter_file_->writeChar(c);
}

void
PSViewFilterFileToken::
reset()
{
  filter_file_->reset();
}

void
PSViewFilterFileToken::
close()
{
  filter_file_->close();
}

const PSViewName &
PSViewFilterFileToken::
getName()
{
  return psview_->getNameMgr()->getName(filter_file_->getFileName());
}
##concat##CPSViewFontIdToken.cpp
#include <CPSViewI.h>

PSViewFontIdToken::
PSViewFontIdToken(CPSView *psview, PSVfont_id value) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_FONT_ID,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(value)
{
}

PSViewFontIdToken::
PSViewFontIdToken(const PSViewFontIdToken &font_id_token) :
 PSViewToken(font_id_token), value_(font_id_token.value_)
{
}

PSViewFontIdToken::
~PSViewFontIdToken()
{
}

PSViewFontIdToken *
PSViewFontIdToken::
dup() const
{
  return new PSViewFontIdToken(*this);
}

int
PSViewFontIdToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewFontIdToken *font_id_token = dynamic_cast<PSViewFontIdToken *>(token);

    return (value_ - font_id_token->value_);
  }
  else
    return type_ - token->getType();
}

void
PSViewFontIdToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Font Id Missing\n");
}

const PSViewName &
PSViewFontIdToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewFontIdToken::
print()
{
  CStrUtil::printf("-%s-", getTypeName().c_str());
}

string
PSViewFontIdToken::
toString()
{
  return "--nostringval--";
}
##concat##CPSViewGState.cpp
#include <CPSViewI.h>
#include <CRGBA.h>
#include <CHSV.h>
#include <CLineList2D.h>
#include <CBezierToLine.h>
#include <COSEnv.h>

#include <CPSViewGStateFont.h>
#include <CPSViewGStatePattern.h>

class PSViewTokenPathVisitor : public PSViewPathVisitor {
 private:
  CPSView     *psview_;
  PSViewToken *move_to_token_;
  PSViewToken *line_to_token_;
  PSViewToken *curve_to_token_;
  PSViewToken *close_path_token_;

 public:
  PSViewTokenPathVisitor(CPSView *psview,
                         PSViewToken *move_to_token,
                         PSViewToken *line_to_token,
                         PSViewToken *curve_to_token,
                         PSViewToken *close_path_token) :
   psview_(psview), move_to_token_(move_to_token), line_to_token_(line_to_token),
   curve_to_token_(curve_to_token), close_path_token_(close_path_token) {
  }

  void moveTo(const CPoint2D &point) {
    PSViewToken *token1 = new PSViewRealToken(psview_, point.x);
    PSViewToken *token2 = new PSViewRealToken(psview_, point.y);

    psview_->getOperandStack()->push(token1);
    psview_->getOperandStack()->push(token2);

    move_to_token_->execute();
  }

  void lineTo(const CPoint2D &point) {
    PSViewToken *token1 = new PSViewRealToken(psview_, point.x);
    PSViewToken *token2 = new PSViewRealToken(psview_, point.y);

    psview_->getOperandStack()->push(token1);
    psview_->getOperandStack()->push(token2);

    line_to_token_->execute();
  }

  void bezier2To(const CPoint2D &point1, const CPoint2D &point2) {
    PSViewToken *token1 = new PSViewRealToken(psview_, point1.x);
    PSViewToken *token2 = new PSViewRealToken(psview_, point1.y);
    PSViewToken *token3 = new PSViewRealToken(psview_, point2.x);
    PSViewToken *token4 = new PSViewRealToken(psview_, point2.y);

    psview_->getOperandStack()->push(token1);
    psview_->getOperandStack()->push(token2);
    psview_->getOperandStack()->push(token3);
    psview_->getOperandStack()->push(token4);

    curve_to_token_->execute();
  }

  void bezier3To(const CPoint2D &point1, const CPoint2D &point2, const CPoint2D &point3) {
    PSViewToken *token1 = new PSViewRealToken(psview_, point1.x);
    PSViewToken *token2 = new PSViewRealToken(psview_, point1.y);
    PSViewToken *token3 = new PSViewRealToken(psview_, point2.x);
    PSViewToken *token4 = new PSViewRealToken(psview_, point2.y);
    PSViewToken *token5 = new PSViewRealToken(psview_, point3.x);
    PSViewToken *token6 = new PSViewRealToken(psview_, point3.y);

    psview_->getOperandStack()->push(token1);
    psview_->getOperandStack()->push(token2);
    psview_->getOperandStack()->push(token3);
    psview_->getOperandStack()->push(token4);
    psview_->getOperandStack()->push(token5);
    psview_->getOperandStack()->push(token6);

    curve_to_token_->execute();
  }

  void arcTo(const CPoint2D &, double, double, double, double) {
    // TODO
  }

  void close() {
    close_path_token_->execute();
  }

 private:
  PSViewTokenPathVisitor(const PSViewTokenPathVisitor &rhs);
  PSViewTokenPathVisitor &operator=(const PSViewTokenPathVisitor &rhs);
};

class PSViewPathRenderer : public PSViewPathVisitor {
 private:
  CPSViewRenderer *renderer_;

 public:
  PSViewPathRenderer(CPSViewRenderer *renderer) :
   renderer_(renderer) {
    renderer->pathInit();
  }

  void moveTo(const CPoint2D &p) {
    renderer_->pathMoveTo(p);
  }

  void lineTo(const CPoint2D &p) {
    renderer_->pathLineTo(p);
  }

  void bezier2To(const CPoint2D &p1, const CPoint2D &p2) {
    renderer_->pathBezier2To(p1, p2);
  }

  void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    renderer_->pathBezier3To(p1, p2, p3);
  }

  void arcTo(const CPoint2D &c, double xr, double yr, double theta, double delta) {
    renderer_->pathArc(c, xr, yr, theta, theta + delta);
  }

  void close() {
    renderer_->pathClose();
  }

 private:
  PSViewPathRenderer(const PSViewPathRenderer &rhs);
  PSViewPathRenderer &operator=(const PSViewPathRenderer &rhs);
};

class PSViewPathStroker : public PSViewPathVisitor {
 public:
  PSViewPathStroker(PSViewGState *gstate) :
   gstate_ (gstate),
   start_  (0,0),
   current_(0,0),
   closed_ (false),
   inner_  (),
   outer_  (),
   path_   () {
    path_ = new PSViewPath;
  }

  void init() {
  }

  void term() {
    buildPath();
  }

  void moveTo(const CPoint2D &p) {
    start_   = p;
    current_ = p;
    closed_  = false;
  }

  void lineTo(const CPoint2D &p) {
    strokeLine(current_, p);

    current_ = p;
    closed_  = false;
  }

  void bezier2To(const CPoint2D &p1, const CPoint2D &p2) {
    strokeBezier2(current_, p1, p2);

    current_ = p2;
    closed_  = false;
  }

  void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    strokeBezier3(current_, p1, p2, p3);

    current_ = p3;
    closed_  = false;
  }

  void arcTo(const CPoint2D &c, double xr, double yr, double theta, double delta) {
    strokeArc(c, xr, yr, theta, delta);

    int    fa, fs;
    double x0, y0, x1, y1;

    CMathGeom2D::ConvertToSVGArc(c.x, c.y, xr, yr, theta, delta, 0.0,
                                 &x0, &y0, &x1, &y1, &fa, &fs);

    current_ = CPoint2D(x1, y1);
    closed_  = false;
  }

  void close() {
    if (! closed_) {
      strokeLine(current_, start_);

      closed_ = true;
    }

    buildPath();
  }

  PSViewPath *getPath() const { return path_; }

 private:
  void strokeBezier2(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    C2Bezier2D bezier(p1, p2, p3);

    vector<CPoint2D> points;

    CBezierToLine b_to_l;

    b_to_l.toLines(bezier, points);

    uint numPoints = points.size();

    for (uint i = 1; i < numPoints; ++i)
      strokeLine(points[i - 1], points[i]);
  }

  void strokeBezier3(const CPoint2D &p1, const CPoint2D &p2,
                     const CPoint2D &p3, const CPoint2D &p4) {
    C3Bezier2D bezier(p1, p2, p3, p4);

    vector<CPoint2D> points;

    CBezierToLine b_to_l;

    b_to_l.toLines(bezier, points);

    uint numPoints = points.size();

    for (uint i = 1; i < numPoints; ++i)
      strokeLine(points[i - 1], points[i]);
  }

  void strokeArc(const CPoint2D &, double, double, double, double) {
  }

  void strokeLine(const CPoint2D &p1, const CPoint2D &p2) {
    double w = gstate_->getLineWidth()/2.0;

    double x21 = p2.x - p1.x;
    double y21 = p2.y - p1.y;

    if (x21 == 0.0 && y21 == 0.0) return;

    double g = atan2(y21, x21);

    double dx = w*cos(g);
    double dy = w*sin(g);

    inner_.push_back(CLine2D(CPoint2D(p1.x + dx, p1.y - dy),
                             CPoint2D(p2.x + dx, p2.y - dy)));
    outer_.push_back(CLine2D(CPoint2D(p2.x - dx, p2.y + dy),
                             CPoint2D(p1.x - dx, p1.y + dy)));
  }

  void buildPath() {
    uint num_inner = inner_.size();
    uint num_outer = outer_.size();

    if (num_inner == 0 || num_outer == 0)
      return;

    path_->init();

    if (! closed_) { // not closed so inner + outer form a single shape
      const CPoint2D *p1 = &inner_[0].start();
      const CPoint2D *p2 = &inner_[0].end  ();

      path_->moveTo(*p1);

      for (uint i = 1; i < num_inner; ++i) {
        const CPoint2D *p3 = &inner_[i].start();
        const CPoint2D *p4 = &inner_[i].end  ();

        CPoint2D pi;
        double   mu1, mu2;

        CMathGeom2D::IntersectLine(CLine2D(*p1, *p2), CLine2D(*p3, *p4), &pi, &mu1, &mu2);

        if (mu1 >= 0.0 && mu1 <= 1.0) {
          path_->lineTo(pi);
        }
        else {
          path_->lineTo(pi);
          //path_->lineTo(*p2);
          //path_->lineTo(*p3);
        }

        p1 = p3;
        p2 = p4;
      }

      for (uint i = 0; i < num_outer; ++i) {
        const CPoint2D *p3 = &outer_[num_outer - i - 1].start();
        const CPoint2D *p4 = &outer_[num_outer - i - 1].end  ();

        CPoint2D pi;
        double   mu1, mu2;

        CMathGeom2D::IntersectLine(CLine2D(*p1, *p2), CLine2D(*p3, *p4), &pi, &mu1, &mu2);

        if (mu1 > 0.0 && mu1 < 1.0) {
          path_->lineTo(pi);
        }
        else {
          path_->lineTo(pi);
          //path_->lineTo(*p2);
          //path_->lineTo(*p3);
        }

        p1 = p3;
        p2 = p4;
      }

      path_->lineTo(*p2);

      path_->close();
    }
    else { // closed inner anf outer form separate shapes
      // inner
      {
      const CPoint2D *p1 = &inner_[num_inner - 1].start();
      const CPoint2D *p2 = &inner_[num_inner - 1].end  ();

      const CPoint2D *p3 = &inner_[0].start();
      const CPoint2D *p4 = &inner_[0].end  ();

      CPoint2D pi;
      double   mu1, mu2;

      CMathGeom2D::IntersectLine(CLine2D(*p1, *p2), CLine2D(*p3, *p4), &pi, &mu1, &mu2);

      path_->moveTo(pi);

      p1 = p3;
      p2 = p4;

      for (uint i = 1; i < num_inner; ++i) {
        const CPoint2D *p3 = &inner_[i].start();
        const CPoint2D *p4 = &inner_[i].end  ();

        CPoint2D pi;
        double   mu1, mu2;

        CMathGeom2D::IntersectLine(CLine2D(*p1, *p2), CLine2D(*p3, *p4), &pi, &mu1, &mu2);

        path_->lineTo(pi);

        p1 = p3;
        p2 = p4;
      }

      path_->close();
      }

      // outer
      {
      const CPoint2D *p1 = &outer_[0].start();
      const CPoint2D *p2 = &outer_[0].end  ();

      const CPoint2D *p3 = &outer_[num_outer - 1].start();
      const CPoint2D *p4 = &outer_[num_outer - 1].end  ();

      CPoint2D pi;
      double   mu1, mu2;

      CMathGeom2D::IntersectLine(CLine2D(*p1, *p2), CLine2D(*p3, *p4), &pi, &mu1, &mu2);

      path_->moveTo(pi);

      p1 = p3;
      p2 = p4;

      for (uint i = 1; i < num_outer; ++i) {
        const CPoint2D *p3 = &outer_[num_outer - i - 1].start();
        const CPoint2D *p4 = &outer_[num_outer - i - 1].end  ();

        CPoint2D pi;
        double   mu1, mu2;

        CMathGeom2D::IntersectLine(CLine2D(*p1, *p2), CLine2D(*p3, *p4), &pi, &mu1, &mu2);

        path_->lineTo(pi);

        p1 = p3;
        p2 = p4;
      }

      path_->close();
      }
    }

    inner_.clear();
    outer_.clear();
  }

 private:
  PSViewGState         *gstate_;
  CPoint2D              start_;
  CPoint2D              current_;
  bool                  closed_;
  vector<CLine2D>       inner_;
  vector<CLine2D>       outer_;
  CAutoPtr<PSViewPath>  path_;

 private:
  PSViewPathStroker(const PSViewPathStroker &rhs);
  PSViewPathStroker &operator=(const PSViewPathStroker &rhs);
};

//-----------

PSViewGStateMgr::
PSViewGStateMgr(CPSView *psview) :
 psview_               (psview),
 CMYKColorSpaceName_   (&psview->getNameMgr()->getName("DeviceCMYK")),
 RGBColorSpaceName_    (&psview->getNameMgr()->getName("DeviceRGB")),
 GrayColorSpaceName_   (&psview->getNameMgr()->getName("DeviceGray")),
 PatternColorSpaceName_(&psview->getNameMgr()->getName("Pattern")),
 font_dir_             (),
 default_ctm_matrix_   (),
 current_font_id_      (0),
 default_font_         (NULL)
{
  font_dir_ = COSUser::getUserHome() + "/data/PSView/fonts";

  init();
}

PSViewGStateMgr::
~PSViewGStateMgr()
{
}

void
PSViewGStateMgr::
init()
{
  default_ctm_matrix_.setIdentity();

  //------

  createDefaultFont();
}

CMatrix2D *
PSViewGStateMgr::
getDefaultMatrix()
{
  return &default_ctm_matrix_;
}

void
PSViewGStateMgr::
createDefaultFont()
{
  default_font_ = new PSViewDictionaryToken(getPSView()->getDictionaryMgr(), 10);

  //------

  PSViewToken *key = new PSViewNameToken(getPSView(), "FontType");

  PSViewToken *value = new PSViewIntegerToken(getPSView(), PSVIEW_FONT_TYPE_DEFAULT);

  default_font_->addValue(key, value);

  //------

  CMatrix2D matrix;

  matrix.setIdentity();

  key   = new PSViewNameToken(getPSView(), "FontMatrix");
  value = new PSViewArrayToken(getPSView(), &matrix);

  default_font_->addValue(key, value);
}

//-----------

PSViewGState::
PSViewGState(PSViewGStateMgr *mgr) :
 mgr_               (mgr),
 ctm_matrix_        (),
 color_space_       (NULL),
 pattern_color_     (false),
 pen_               (),
 brush_             (),
 cmyk_              (0, 0, 0, 0),
 cmyk_valid_        (false),
 hsb_               (0, 0, 0),
 hsb_valid_         (false),
 stroke_adjust_     (false),
 black_generation_  (),
 undercolor_removal_(),
 font_              (),
 graphics_          (NULL),
 pattern_           (),
 path_              (),
 clippath_          ()
{
  pen_.setColor(CRGBA(0,0,0));
  pen_.setMitreLimit(10.0);
  pen_.setFlatness(2.0);

  brush_.setColor(CRGBA(0,0,0));

  ctm_matrix_.setIdentity();

  color_space_ = &mgr_->getGrayColorSpace();
  font_        = new PSViewGStateFont;
  graphics_    = getPSView()->getGraphics();
  path_        = new PSViewPath;
  clippath_    = new PSViewPath;

  setFont(mgr_->getDefaultFont());

  initGraphics();

  newPath();
}

PSViewGState::
PSViewGState(const PSViewGState &gstate) :
 mgr_               (gstate.mgr_          ),
 ctm_matrix_        (gstate.ctm_matrix_   ),
 color_space_       (gstate.color_space_  ),
 pattern_color_     (gstate.pattern_color_),
 pen_               (gstate.pen_          ),
 brush_             (gstate.brush_        ),
 cmyk_              (gstate.cmyk_         ),
 cmyk_valid_        (gstate.cmyk_valid_   ),
 hsb_               (gstate.hsb_          ),
 hsb_valid_         (gstate.hsb_valid_    ),
 stroke_adjust_     (gstate.stroke_adjust_),
 black_generation_  (                     ),
 undercolor_removal_(                     ),
 font_              (                     ),
 graphics_          (NULL                 ),
 pattern_           (                     ),
 path_              (                     ),
 clippath_          (                     )
{
  if (gstate.black_generation_.isValid())
    black_generation_ = gstate.black_generation_->dup();

  if (gstate.undercolor_removal_.isValid())
    undercolor_removal_ = gstate.undercolor_removal_->dup();

  if (gstate.font_.isValid())
    font_ = new PSViewGStateFont(*gstate.font_);

  graphics_ = getPSView()->getGraphics();

  if (gstate.pattern_.isValid())
    pattern_ = new PSViewGStatePattern(*gstate.pattern_);

  if (gstate.path_.isValid())
    path_ = gstate.path_->dup();

  if (gstate.clippath_.isValid())
    clippath_ = gstate.clippath_->dup();
}

PSViewGState::
~PSViewGState()
{
}

const PSViewGState &
PSViewGState::
operator=(const PSViewGState &gstate)
{
  if (this == &gstate)
    return *this;

  ctm_matrix_         = gstate.ctm_matrix_;
  color_space_        = gstate.color_space_;
  pattern_color_      = gstate.pattern_color_;
  pen_                = gstate.pen_;
  brush_              = gstate.brush_;
  cmyk_               = gstate.cmyk_;
  cmyk_valid_         = gstate.cmyk_valid_;
  hsb_                = gstate.hsb_;
  hsb_valid_          = gstate.hsb_valid_;
  stroke_adjust_      = gstate.stroke_adjust_;
  black_generation_   = NULL;
  undercolor_removal_ = NULL;
  font_               = NULL;
  pattern_            = NULL;
  path_               = NULL;
  clippath_           = NULL;

  if (gstate.black_generation_.isValid())
    black_generation_ = gstate.black_generation_->dup();

  if (gstate.undercolor_removal_.isValid())
    undercolor_removal_ = gstate.undercolor_removal_->dup();

  if (gstate.font_.isValid())
    font_ = new PSViewGStateFont(*gstate.font_);

  graphics_ = getPSView()->getGraphics();

  if (gstate.pattern_.isValid())
    pattern_ = new PSViewGStatePattern(*gstate.pattern_);

  if (gstate.path_.isValid())
    path_ = gstate.path_->dup();

  if (gstate.clippath_.isValid())
    clippath_ = gstate.clippath_->dup();

  return *this;
}

int
PSViewGState::
compare(PSViewGState *)
{
  return 1;
}

void
PSViewGState::
initGraphics()
{
  initMatrix();
  newPath   ();
  initClip  ();

  setColorSpace  (mgr_->getGrayColorSpace());
  setPatternColor(false);
  setGray        (0.0);
  setFlat        (2.0);
  setLineWidth   (1.0);
  setLineCap     (LINE_CAP_TYPE_BUTT);
  setLineJoin    (LINE_JOIN_TYPE_MITRE);
  setMitreLimit  (10.0);
  setStrokeAdjust(false);
  setDashPattern (NULL, 0, 0.0);
}

void
PSViewGState::
initMatrix()
{
  setCTMMatrix(mgr_->getDefaultMatrix());
}

void
PSViewGState::
setGraphics()
{
  if (graphics_ != NULL) {
    CPen pen = pen_;

    double tx, ty;

    multiplyDistByCTMMatrix(pen_.getWidth(), pen_.getWidth(), &tx, &ty);

    pen.setWidth(tx);

    graphics_->setPen(pen);

    graphics_->setBrush(brush_);
  }
}

void
PSViewGState::
newPath()
{
  path_->init();
}

void
PSViewGState::
initClip()
{
  if (graphics_ != NULL) {
    clippath_->init();

    double xmin = 0.0, ymin = 0.0, xmax = CPSView::PAGE_WIDTH - 1, ymax = CPSView::PAGE_HEIGHT - 1;

    clippath_->moveTo(CPoint2D(xmin, ymin));
    clippath_->lineTo(CPoint2D(xmax, ymin));
    clippath_->lineTo(CPoint2D(xmax, ymax));
    clippath_->lineTo(CPoint2D(xmin, ymax));

    clippath_->close();
  }
}

void
PSViewGState::
moveTo(double x, double y)
{
  double x1, y1;

  multiplyByCTMMatrix(x, y, &x1, &y1);

  path_->moveTo(CPoint2D(x1, y1));
}

void
PSViewGState::
rmoveTo(double x, double y)
{
  double x1, y1;

  multiplyDistByCTMMatrix(x, y, &x1, &y1);

  if (! path_->rmoveTo(CPoint2D(x1, y1)))
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
}

void
PSViewGState::
lineTo(double x, double y)
{
  double x1, y1;

  multiplyByCTMMatrix(x, y, &x1, &y1);

  if (! path_->lineTo(CPoint2D(x1, y1)))
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
}

void
PSViewGState::
rlineTo(double x, double y)
{
  double x1, y1;

  multiplyDistByCTMMatrix(x, y, &x1, &y1);

  if (! path_->rlineTo(CPoint2D(x1, y1)))
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
}

void
PSViewGState::
arc(double x, double y, double r, double angle1, double angle2)
{
  double x1, y1;

  multiplyByCTMMatrix(x, y, &x1, &y1);

  double rx1, ry1;

  multiplyDistByCTMMatrix(r, r, &rx1, &ry1);

  path_->arc(CPoint2D(x1, y1), rx1, ry1, angle1, angle2);
}

void
PSViewGState::
arcN(double x, double y, double r, double angle1, double angle2)
{
  double x1, y1;

  multiplyByCTMMatrix(x, y, &x1, &y1);

  double rx1, ry1;

  multiplyDistByCTMMatrix(r, r, &rx1, &ry1);

  path_->arcN(CPoint2D(x1, y1), rx1, ry1, angle1, angle2);
}

void
PSViewGState::
arcTo(double x1, double y1, double x2, double y2, double r, double *xt1, double *yt1,
      double *xt2, double *yt2)
{
  double x0, y0;

  getCurrentPoint(&x0, &y0);

  //---

  // get angles of two tangents intersecting at (x1, y1)
  double x01 = x0 - x1;
  double y01 = y0 - y1;
  double x21 = x2 - x1;
  double y21 = y2 - y1;

  double id1 = 1.0/sqrt(x01*x01 + y01*y01);
  double id2 = 1.0/sqrt(x21*x21 + y21*y21);

  //double g1 = atan2(y01, x01);
  //double g2 = atan2(y21, x21);

  //---

  // get angles of perpendiculars
  double pg1 = atan2(-x01, y01);
  double pg2 = atan2(-x21, y21);

  //---

  // get included angle
  double a = CMathGeom2D::IncludedAngle(CPoint2D(x0, y0), CPoint2D(x1, y1), CPoint2D(x2, y2));

  // get distance along lines to tangents (adjacent edge of triangle with angle of half included
  // angle and opposite of 'r')
  double d = r/tan(a/2);

  // calc tangent points (d along line from (x1, y1) using tangent gradient
  //*xt1 = x1 + d*cos(g1); *yt1 = y1 + d*sin(g1);
  //*xt2 = x1 + d*cos(g2); *yt2 = y1 + d*sin(g2);

  *xt1 = x1 + d*x01*id1; *yt1 = y1 + d*y01*id1;
  *xt2 = x1 + d*x21*id2; *yt2 = y1 + d*y21*id2;

  // intersect lines perpendicular to tangent points to get center
  double xi, yi, mu1, mu2;

  CPoint2D pi;

  CMathGeom2D::IntersectLine(CLine2D(CPoint2D(*xt1, *yt1),
                                     CPoint2D(*xt1 + cos(pg1), *yt1 + sin(pg1))),
                             CLine2D(CPoint2D(*xt2, *yt2),
                                     CPoint2D(*xt2 + cos(pg2), *yt2 + sin(pg2))),
                             &pi, &mu1, &mu2);

  xi = pi.x;
  yi = pi.y;

  //------

  // arc angles from center to tangent points
  double ag1 = atan2(*yt1 - yi, *xt1 - xi);
  double ag2 = atan2(*yt2 - yi, *xt2 - xi);

  // draw arc
  arc(xi, yi, r, ag1, ag2);
}

void
PSViewGState::
curveTo(double x1, double y1, double x2, double y2, double x3, double y3)
{
  double tx1, ty1, tx2, ty2, tx3, ty3;

  multiplyByCTMMatrix(x1, y1, &tx1, &ty1);
  multiplyByCTMMatrix(x2, y2, &tx2, &ty2);
  multiplyByCTMMatrix(x3, y3, &tx3, &ty3);

  if (! path_->bezier3To(CPoint2D(tx1, ty1), CPoint2D(tx2, ty2), CPoint2D(tx3, ty3)))
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
}

void
PSViewGState::
rcurveTo(double x1, double y1, double x2, double y2, double x3, double y3)
{
  double tx1, ty1, tx2, ty2, tx3, ty3;

  multiplyDistByCTMMatrix(x1, y1, &tx1, &ty1);
  multiplyDistByCTMMatrix(x2, y2, &tx2, &ty2);
  multiplyDistByCTMMatrix(x3, y3, &tx3, &ty3);

  if (! path_->rbezier3To(CPoint2D(tx1, ty1), CPoint2D(tx2, ty2), CPoint2D(tx3, ty3)))
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
}

bool
PSViewGState::
getCurrentPoint(double *x, double *y)
{
  CPoint2D p1;

  bool flag = path_->getCurrentPoint(p1);

  if (! flag)
    return false;

  multiplyByInverseCTMMatrix(p1.x, p1.y, x, y);

  return true;
}

void
PSViewGState::
show(const string &str)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: Show not implemented for Type 1 Fonts\n");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewDictionaryToken *font_dictionary = font->getDictionary();

    string str1 = " ";

    int i = 0;

    int len = str.size();

    while (i < len) {
      PSViewDictionaryToken *font_dictionary1 = NULL;

      str1[0] = getType0Char(str, &i, &font_dictionary1);

      setFont1(font_dictionary1);

      show(str1);

      setFont1(font_dictionary);
    }

    return;
  }

  //------

  CPoint2D p;

  bool flag = path_->getCurrentPoint(p);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  //------

  int len = str.size();

  for (int i = 1; i <= len; i++) {
    if      (type == PSVIEW_FONT_TYPE_DEFAULT)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_1)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_3)
      showType3Char  (str[i - 1], &p.x, &p.y);
  }

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);
}

void
PSViewGState::
ashow(double ax, double ay, const string &str)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: AShow not implemented for Type 1 Fonts\n");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewDictionaryToken *font_dictionary = font->getDictionary();

    string str1 = " ";

    int i = 0;

    int len = str.size();

    while (i < len) {
      PSViewDictionaryToken *font_dictionary1 = NULL;

      str1[0] = getType0Char(str, &i, &font_dictionary1);

      setFont1(font_dictionary1);

      ashow(ax, ay, str1);

      setFont1(font_dictionary);
    }

    return;
  }

  //------

  CPoint2D p;

  bool flag = path_->getCurrentPoint(p);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  //------

  int len = str.size();

  for (int i = 1; i <= len; i++) {
    if      (type == PSVIEW_FONT_TYPE_DEFAULT)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_1)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_3)
      showType3Char  (str[i - 1], &p.x, &p.y);

    p.x += ax;
    p.y += ay;
  }

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);
}

void
PSViewGState::
widthShow(double cx, double cy, int c, const string &str)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: WidthShow not implemented for Type 1 Fonts\n");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewDictionaryToken *font_dictionary = font->getDictionary();

    string str1 = " ";

    int i = 0;

    int len = str.size();

    while (i < len) {
      PSViewDictionaryToken *font_dictionary1 = NULL;

      str1[0] = getType0Char(str, &i, &font_dictionary1);

      setFont1(font_dictionary1);

      widthShow(cx, cy, c, str1);

      setFont1(font_dictionary);
    }

    return;
  }

  //------

  CPoint2D p;

  bool flag = path_->getCurrentPoint(p);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  //------

  int len = str.size();

  for (int i = 1; i <= len; i++) {
    if      (type == PSVIEW_FONT_TYPE_DEFAULT)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_1)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_3)
      showType3Char  (str[i - 1], &p.x, &p.y);

    if (str[i - 1] == c) {
      p.x += cx;
      p.y += cy;
    }
  }

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);
}

void
PSViewGState::
awidthShow(double cx, double cy, int c, double ax, double ay, const string &str)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: AShow not implemented for Type 1 Fonts\n");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewDictionaryToken *font_dictionary = font->getDictionary();

    string str1 = " ";

    int i = 0;

    int len = str.size();

    while (i < len) {
      PSViewDictionaryToken *font_dictionary1 = NULL;

      str1[0] = getType0Char(str, &i, &font_dictionary1);

      setFont1(font_dictionary1);

      awidthShow(cx, cy, c, ax, ay, str1);

      setFont1(font_dictionary);
    }

    return;
  }

  //------

  CPoint2D p;

  bool flag = path_->getCurrentPoint(p);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  //------

  int len = str.size();

  for (int i = 1; i <= len; i++) {
    if      (type == PSVIEW_FONT_TYPE_DEFAULT)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_1)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_3)
      showType3Char  (str[i - 1], &p.x, &p.y);

    p.x += ax;
    p.y += ay;

    if (str[i - 1] == c) {
      p.x += cx;
      p.y += cy;
    }
  }

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);
}

void
PSViewGState::
glyphShow(const PSViewName &name)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT)
    CStrUtil::eprintf("PSView: %s not implemented for Internal Fonts\n", "GlyphShow");
  else if (type == PSVIEW_FONT_TYPE_0)
    CStrUtil::eprintf("PSView: %s not implemented for Type 0 Fonts\n", "GlyphShow");
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: %s not implemented for Type 1 Fonts\n", "GlyphShow");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  CPoint2D p;

  bool flag = path_->getCurrentPoint(p);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  //------

  if (type == PSVIEW_FONT_TYPE_3) {
    PSViewGStateFont3Data *font_data = font->getFont3Data();

    if (font_data->build_type == PSVIEW_FONT_BUILD_TYPE_GLYPH) {
      getPSView()->getOperandStack()->push(font->getDictionary());

      PSViewToken *token = new PSViewNameToken(getPSView(), name);

      getPSView()->getOperandStack()->push(token);

      //------

      getPSView()->getGStateTokenMgr()->save();

      newPath();

      moveTo(0, 0);

      double x1, y1, x2, y2;

      CMatrix2D *matrix = getCTMMatrix();

      matrix->getValues(&x1, &y1, &x2, &y2, NULL, NULL);
      matrix->setValues( x1,  y1,  x2,  y2,    0,    0);

      CMatrix2D tmatrix;

      tmatrix.setTranslation(p.x, p.y);

      preMultiplyCTMMatrix(&tmatrix);

      postMultiplyCTMMatrix(&font_data->matrix);

      setCharWidth(0.0, 0.0);

      font_data->execute();

      getCharWidth(&x1, &y1);

      getPSView()->getGStateTokenMgr()->restore();

      p.x += x1;
      p.y += y1;
    }
    else {
      PSViewArrayToken *array_token = (PSViewArrayToken *) font_data->encoding;

      int c;

      const PSViewName *name1 = &name;

      for (int i = 1; i <= 2; i++) {
        for (c = 1; c <= 256; c++) {
          PSViewToken *token = array_token->getValue(c);

          if (! token->isName()) {
            getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);

            return;
          }

          PSViewNameToken *name_token = (PSViewNameToken *) token;

          if (name_token->getValue().compare(*name1) == 0)
            break;
        }

        if (c <= 256)
          break;

        if (i == 2) {
          getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);

          return;
        }

        name1 = &getPSView()->getNameMgr()->getName(".notdef");
      }

      showType3Char(c, &p.x, &p.y);
    }
  }
  else {
    int c = ' ';

    showDefaultChar(c, &p.x, &p.y);
  }

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);
}

void
PSViewGState::
kshow(PSViewToken *proc, const string &str)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: KShow not implemented for Type 1 Fonts\n");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  CPoint2D p;

  bool flag = path_->getCurrentPoint(p);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  //------

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewDictionaryToken *font_dictionary = font->getDictionary();

    string str1 = " ";

    int i = 0;

    int len = str.size();

    while (i < len) {
      PSViewDictionaryToken *font_dictionary1 = NULL;

      str1[0] = getType0Char(str, &i, &font_dictionary1);

      setFont1(font_dictionary1);

      kshow(proc, str1);

      setFont1(font_dictionary);
    }

    return;
  }

  //------

  int len = str.size();

  for (int i = 1; i <= len; i++) {
    if (i > 1) {
      PSViewToken *token1 = new PSViewIntegerToken(getPSView(), str[i - 2]);
      PSViewToken *token2 = new PSViewIntegerToken(getPSView(), str[i - 1]);

      getPSView()->getOperandStack()->push(token1);
      getPSView()->getOperandStack()->push(token2);

      proc->execute();

      delete token1;
      delete token2;
    }

    if      (type == PSVIEW_FONT_TYPE_DEFAULT)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_1)
      showDefaultChar(str[i - 1], &p.x, &p.y);
    else if (type == PSVIEW_FONT_TYPE_3)
      showType3Char  (str[i - 1], &p.x, &p.y);
  }

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);
}

void
PSViewGState::
stringWidth(const string &str, double *wx, double *wy)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: %s not implemented for Type 1 Fonts\n", "StringWidth");
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewDictionaryToken *font_dictionary = font->getDictionary();

    string str1 = " ";

    int i = 0;

    int len = str.size();

    while (i < len) {
      PSViewDictionaryToken *font_dictionary1 = NULL;

      str1[0] = getType0Char(str, &i, &font_dictionary1);

      setFont1(font_dictionary1);

      stringWidth(str1, wx, wy);

      setFont1(font_dictionary);
    }

    return;
  }

  //------

  *wx = 0;
  *wy = 0;

  int len = str.size();

  for (int i = 1; i <= len; i++) {
    if      (type == PSVIEW_FONT_TYPE_DEFAULT)
      showDefaultChar(str[i - 1], wx, wy);
    else if (type == PSVIEW_FONT_TYPE_1)
      showDefaultChar(str[i - 1], wx, wy);
    else if (type == PSVIEW_FONT_TYPE_3)
      showType3Char  (str[i - 1], wx, wy);
  }
}

void
PSViewGState::
showDefaultChar(int c, double *x, double *y)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  PSViewPathRenderer renderer(graphics_);

  CMatrix2D m = ctm_matrix_*font_data->matrix;

  path_->addChar(c, m, x, y);

  path_->process(renderer);

  brush_.setFillRule(FILL_TYPE_WINDING);

  setGraphics();

  graphics_->pathFill();

  newPath();
}

void
PSViewGState::
defaultCharPath(int c, double *x, double *y)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  PSViewPathRenderer renderer(graphics_);

  CMatrix2D m = ctm_matrix_*font_data->matrix;

  path_->addChar(c, m, x, y);
}

int
PSViewGState::
getType0Char(const string &str, int *pos, PSViewDictionaryToken **font_dictionary)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont0Data *font_data = font->getFont0Data();

  //------

  if (*font_dictionary == NULL)
    *font_dictionary = font_data->font_array[0];

  if      (font_data->map_type == 2) {
    int font_num = font_data->encoding[str[*pos] % font_data->encoding_size];

    (*pos)++;

    *font_dictionary = font_data->font_array[font_num % font_data->num_fonts];
  }
  else if (font_data->map_type == 3) {
    if (str[*pos] == font_data->escape_char) {
      (*pos)++;

      int font_num = font_data->encoding[str[*pos] % font_data->encoding_size];

      *font_dictionary = font_data->font_array[font_num % font_data->num_fonts];

      (*pos)++;
    }
  }
  else
    CStrUtil::eprintf("PSView: MapType %d not supported for Composite Fonts", font_data->map_type);

  return str[(*pos)++];
}

void
PSViewGState::
showType3Char(int c, double *x, double *y)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  //------

  getPSView()->getOperandStack()->push(font->getDictionary());

  //------

  c = ((uint) c) & 0xFF;

  PSViewToken *show_char;

  if (font_data->build_type == PSVIEW_FONT_BUILD_TYPE_GLYPH) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) font_data->encoding;

    show_char = array_token->getValue(c + 1);
  }
  else
    show_char = new PSViewIntegerToken(getPSView(), c);

  getPSView()->getOperandStack()->push(show_char);

  //------

  getPSView()->getGStateTokenMgr()->save();

  newPath();

  double x1, y1, x2, y2;

  CMatrix2D *matrix = getCTMMatrix();

  matrix->getValues(&x1, &y1, &x2, &y2, NULL, NULL);
  matrix->setValues( x1,  y1,  x2,  y2,    0,    0);

  CMatrix2D tmatrix;

  tmatrix.setTranslation(*x, *y);

  preMultiplyCTMMatrix(&tmatrix);

  postMultiplyCTMMatrix(&font_data->matrix);

  setCharWidth(0.0, 0.0);

  font_data->execute();

  getCharWidth(&x1, &y1);

  getPSView()->getGStateTokenMgr()->restore();

  //------

  *x += x1;
  *y += y1;
}

void
PSViewGState::
charPath(const string &str, int flag)
{
  PSViewGStateFont *font = getFont();

  PSViewFontType type = font->getType();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
    CPoint2D p;

    path_->getCurrentPoint(p);

    int len = str.size();

    for (int i = 1; i <= len; i++)
      defaultCharPath(str[i - 1], &p.x, &p.y);

    return;
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
    CStrUtil::eprintf("PSView: CharPath not implemented for Type 0 Fonts\n");
    return;
  }
  else if (type == PSVIEW_FONT_TYPE_1) {
    CStrUtil::eprintf("PSView: CharPath not implemented for Type 1 Fonts\n");
    return;
  }
  else if (type == PSVIEW_FONT_TYPE_3) {
  }

  //------

  PSViewToken *key1 = new PSViewNameToken(getPSView(), "fill");
  PSViewToken *key2 = new PSViewNameToken(getPSView(), "stroke");

  PSViewDictionaryToken *dict1 = getPSView()->getDictionaryMgr()->lookupDictionary(key1);
  PSViewDictionaryToken *dict2 = getPSView()->getDictionaryMgr()->lookupDictionary(key2);

  PSViewToken *value1 = getPSView()->getDictionaryMgr()->lookup(key1);
  PSViewToken *value2 = getPSView()->getDictionaryMgr()->lookup(key2);

  PSViewToken *value = new PSViewOperatorToken(getPSView(), "charpathfill");

  dict1->addValue(key1, value);

  if (flag)
    value = new PSViewOperatorToken(getPSView(), "charpathstroketrue");
  else
    value = new PSViewOperatorToken(getPSView(), "charpathstrokefalse");

  dict2->addValue(key2, value);

  //------

  CPoint2D p;

  bool flag1 = path_->getCurrentPoint(p);

  if (! flag1) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);

    return;
  }

  //------

  int len = str.size();

  for (int i = 1; i <= len; i++)
    addType3CharPath(str[i - 1], &p.x, &p.y);

  //------

  double x1, y1;

  multiplyByInverseCTMMatrix(p.x, p.y, &x1, &y1);

  moveTo(x1, y1);

  //------

  dict1->addValue(key1, value1);
  dict2->addValue(key2, value2);
}

void
PSViewGState::
addType3CharPath(int c, double *x, double *y)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  //------

  getPSView()->getOperandStack()->push(font->getDictionary());

  //------

  c = ((uint) c) & 0xFF;

  PSViewToken *show_char;

  if (font_data->build_type == PSVIEW_FONT_BUILD_TYPE_GLYPH) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) font_data->encoding;

    show_char = array_token->getValue(c + 1);
  }
  else
    show_char = new PSViewIntegerToken(getPSView(), c);

  getPSView()->getOperandStack()->push(show_char);

  //------

  getPSView()->getGStateTokenMgr()->save();

  newPath();

  double x1, y1, x2, y2;

  CMatrix2D *matrix = getCTMMatrix();

  matrix->getValues(&x1, &y1, &x2, &y2, NULL, NULL);
  matrix->setValues( x1,  y1,  x2,  y2,    0,    0);

  CMatrix2D tmatrix;

  tmatrix.setTranslation(*x, *y);

  preMultiplyCTMMatrix(&tmatrix);

  postMultiplyCTMMatrix(&font_data->matrix);

  setCharWidth(0.0, 0.0);

  font_data->execute();

  getCharWidth(&x1, &y1);

  getPSView()->getGStateTokenMgr()->restore();

  newPath();

  //------

  *x += x1;
  *y += y1;
}

void
PSViewGState::
image(char *image_data, int width, int height, int bits_per_sample, CMatrix2D *matrix,
      double *decode_array, int decode_size)
{
#ifdef DEBUG
  debugPrintImage(image_data, width, height, bits_per_sample, matrix, decode_array, decode_size);
#endif

  CMatrix2D imatrix;

  bool flag = matrix->invert(imatrix);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);
    return;
  }

  if (graphics_ == NULL) return;

  int num_colors = 1 << bits_per_sample;

  int bit_num  = 7;
  int byte_num = 0;

  CRGBA rgba(1,1,1);

  double y = 0.0;

  for (int i = 0; i < height; ++i) {
    double x = 0.0;

    int bit_mask = 1 << bit_num;

    for (int j = 0; j < width; ++j) {
      int color_bit = bits_per_sample - 1;

      int color = 0;

      for (int k = 0; k < bits_per_sample; ++k) {
        if (image_data[byte_num] & bit_mask)
          color |= 1 << color_bit;

        bit_num--;

        if (bit_num < 0) {
          bit_num = 7;

          ++byte_num;
        }

        bit_mask = 1 << bit_num;
      }

      if (color < decode_size)
        rgba.setGray(decode_array[color]);
      else
        rgba.setGray(((double) color)/(num_colors - 1));

      double x11, y11, x21, y21;

      imatrix.multiplyPoint(x    , y    , &x11, &y11);
      imatrix.multiplyPoint(x + 1, y + 1, &x21, &y21);

      double x12, y12, x22, y22;

      ctm_matrix_.multiplyPoint(x11, y11, &x12, &y12);
      ctm_matrix_.multiplyPoint(x21, y21, &x22, &y22);

      CPoint2D points[4];

      points[0].x = x12; points[0].y = y12;
      points[1].x = x22; points[1].y = y12;
      points[2].x = x22; points[2].y = y22;
      points[3].x = x12; points[3].y = y22;

      pen_  .setColor(CRGBA(0,0,0,0));
      brush_.setColor(rgba);

      path_->init();

      path_->moveTo(points[0]);
      path_->lineTo(points[1]);
      path_->lineTo(points[2]);
      path_->lineTo(points[3]);

      path_->close();

      PSViewPathRenderer renderer(graphics_);

      path_->process(renderer);

      brush_.setFillRule(FILL_TYPE_WINDING);

      setGraphics();

      graphics_->pathFill();

      x += 1.0;
    }

    if (bit_num != 7) {
      bit_num = 7;

      ++byte_num;
    }

    y += 1.0;
  }
}

void
PSViewGState::
debugPrintImage(char *image_data, int width, int height, int bits_per_sample,
                CMatrix2D *, double *, int)
{
  CStrUtil::printf("Image\n");
  CStrUtil::printf("  Width  = %d\n", width);
  CStrUtil::printf("  Height = %d\n", height);
  CStrUtil::printf("  Bits   = %d\n", bits_per_sample);
  CStrUtil::printf("  Data :-\n");

  int width1 = width;

  if ((width % 8) != 0)
    width1 += 8 - (width % 8);

  int num_bits  = width1*height*bits_per_sample;
  int num_bytes = num_bits/8;

  int i = 0;

  for ( ; i < num_bytes; ++i) {
    if (i % 8 == 0)
      CStrUtil::printf("    ");
    else
      CStrUtil::printf(", ");

    CStrUtil::printf("%x", image_data[i] & 0xFF);

    if (i % 8 == 7)
      CStrUtil::printf("\n");
  }

  if (i % 8 != 0)
    CStrUtil::printf("\n");
}

void
PSViewGState::
imageMask(char *image_data, int width, int height, int polarity, CMatrix2D *matrix)
{
#ifdef DEBUG
  debugPrintImageMask(image_data, width, height, polarity, matrix);
#endif

  CMatrix2D imatrix;

  bool flag = matrix->invert(imatrix);

  if (! flag) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);
    return;
  }

  if (graphics_ == NULL)
    return;

  int bit_num  = 7;
  int byte_num = 0;

  double y = 0.0;

  for (int i = 0; i < height; ++i) {
    double x = 0.0;

    int bit_mask = 1 << bit_num;

    for (int j = 0; j < width; ++j) {
      int color = 0;

      if (image_data[byte_num] & bit_mask)
        color = 1;

      bit_num--;

      if (bit_num < 0) {
        bit_num = 7;

        ++byte_num;
      }

      bit_mask = 1 << bit_num;

      if      ((color == 0 && ! polarity) ||
               (color == 1 &&   polarity)) {
        double x11, y11, x21, y21;

        imatrix.multiplyPoint(x    , y    , &x11, &y11);
        imatrix.multiplyPoint(x + 1, y + 1, &x21, &y21);

        double x12, y12, x22, y22;

        ctm_matrix_.multiplyPoint(x11, y11, &x12, &y12);
        ctm_matrix_.multiplyPoint(x21, y21, &x22, &y22);

        CPoint2D points[4];

        points[0].x = x12; points[0].y = y12;
        points[1].x = x22; points[1].y = y12;
        points[2].x = x22; points[2].y = y22;
        points[3].x = x12; points[3].y = y22;

        path_->init();

        path_->moveTo(points[0]);
        path_->lineTo(points[1]);
        path_->lineTo(points[2]);
        path_->lineTo(points[3]);

        path_->close();

        PSViewPathRenderer renderer(graphics_);

        path_->process(renderer);

        brush_.setFillRule(FILL_TYPE_WINDING);

        setGraphics();

        graphics_->pathFill();
      }

      x += 1.0;
    }

    if (bit_num != 7) {
      bit_num = 7;

      ++byte_num;
    }

    y += 1.0;
  }
}

void
PSViewGState::
debugPrintImageMask(char *image_data, int width, int height, int polarity, CMatrix2D *)
{
  CStrUtil::printf("ImageMask\n");
  CStrUtil::printf("  Width    = %d\n", width);
  CStrUtil::printf("  Height   = %d\n", height);
  CStrUtil::printf("  Polarity = %d\n", polarity);
  CStrUtil::printf("  Data :-\n");

  int width1 = width;

  if ((width % 8) != 0)
    width1 += 8 - (width % 8);

  int num_bits  = width1*height;
  int num_bytes = num_bits/8;

  int i = 0;

  for ( ; i < num_bytes; ++i) {
    if (i % 8 == 0)
      CStrUtil::printf("    ");
    else
      CStrUtil::printf(", ");

    CStrUtil::printf("%x", image_data[i] & 0xFF);

    if (i % 8 == 7)
      CStrUtil::printf("\n");
  }

  if (i % 8 != 0)
    CStrUtil::printf("\n");
}

void
PSViewGState::
closePath()
{
  path_->close();
}

void
PSViewGState::
rectStroke(double x, double y, double width, double height, CMatrix2D *matrix)
{
  getPSView()->getGStateTokenMgr()->save();

  newPath();

  moveTo ( x    , y     );
  rlineTo( width, 0.0   );
  rlineTo( 0.0  , height);
  rlineTo(-width, 0.0   );

  closePath();

  if (matrix != NULL)
    postMultiplyCTMMatrix(matrix);

  stroke();

  getPSView()->getGStateTokenMgr()->restore();
}

void
PSViewGState::
rectFill(double x, double y, double width, double height)
{
  getPSView()->getGStateTokenMgr()->save();

  newPath();

  moveTo ( x    , y     );
  rlineTo( width, 0.0   );
  rlineTo( 0.0  , height);
  rlineTo(-width, 0.0   );

  closePath();

  fill();

  getPSView()->getGStateTokenMgr()->restore();
}

void
PSViewGState::
rectClip(double *x, double *y, double *width, double *height, int num_rects)
{
  newPath();

  for (int i = 0; i < num_rects; i++) {
    moveTo ( x[i]    , y[i]     );
    rlineTo( width[i], 0.0      );
    rlineTo( 0.0     , height[i]);
    rlineTo(-width[i], 0.0      );

    closePath();
  }

  clip();

  newPath();
}

void
PSViewGState::
stroke()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::stroke\n");

    path_->print();
  }

  path_->setStrokeAdjust(stroke_adjust_);

  PSViewPathRenderer renderer(graphics_);

  path_->process(renderer);

  setGraphics();

  graphics_->pathStroke();

  newPath();
}

void
PSViewGState::
strokePath()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::strokePath\n");

    path_->print();
  }

  PSViewPathStroker stroker(this);

  path_->process(stroker);

  path_ = stroker.getPath();
}

void
PSViewGState::
fill()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::fill\n");

    path_->print();
  }

  if (pattern_color_ && pattern_.isValid())
    patternFill();
  else {
    PSViewPathRenderer renderer(graphics_);

    path_->process(renderer);

    brush_.setFillRule(FILL_TYPE_WINDING);

    setGraphics();

    graphics_->pathFill();
  }

  newPath();
}

void
PSViewGState::
patternFill()
{
  double xmin, ymin, xmax, ymax;

  path_->getBounds(&xmin, &ymin, &xmax, &ymax);

  double x_step = pattern_->getXStep();
  double y_step = pattern_->getYStep();

  double x1, y1, x2, y2;

  CMatrix2D *matrix = getCTMMatrix();

  matrix->multiplyPoint(0.0   , 0.0   , &x1, &y1);
  matrix->multiplyPoint(x_step, y_step, &x2, &y2);

  x_step = x2 - x1;
  y_step = y2 - y1;

  //------

  x1 = 0.0;

  if (x1 < xmin) {
    while (x1 < xmin)
      x1 += x_step;

    x1 -= x_step;
  }
  else {
    while (x1 > xmin)
      x1 -= x_step;
  }

  xmin = x1;

  y1 = 0.0;

  if (y1 < ymin) {
    while (y1 < ymin)
      y1 += y_step;

    y1 -= y_step;
  }
  else {
    while (y1 > ymin)
      y1 -= y_step;
  }

  ymin = y1;

  /****************/

  PSViewGStateTokenMgr *mgr = getPSView()->getGStateTokenMgr();

  PSViewOperandStack *opStack = getPSView()->getOperandStack();

  for (double x = xmin; x < xmax; x += x_step) {
    for (double y = ymin; y < ymax; y += y_step) {
      PSViewGStateToken *gstate_token = mgr->save();

      gstate_token->clip();

      gstate_token->newPath();

      CMatrix2D tmatrix;

      tmatrix.setTranslation(x, y);

      gstate_token->preMultiplyCTMMatrix(&tmatrix);

      PSViewGStatePattern *pattern = gstate_token->getPattern();

      const double *bbox = pattern->getBBox();

      gstate_token->moveTo(bbox[0], bbox[1]);
      gstate_token->lineTo(bbox[2], bbox[1]);
      gstate_token->lineTo(bbox[2], bbox[3]);
      gstate_token->lineTo(bbox[0], bbox[3]);

      gstate_token->closePath();

      gstate_token->clip();

      gstate_token->newPath();

      opStack->push(pattern->getDictionary());

      pattern->execute();

      mgr->restore();
    }
  }
}

void
PSViewGState::
eofill()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::eofill\n");

    path_->print();
  }

  PSViewPathRenderer renderer(graphics_);

  path_->process(renderer);

  brush_.setFillRule(FILL_TYPE_EVEN_ODD);

  setGraphics();

  graphics_->pathFill();

  newPath();
}

void
PSViewGState::
clip()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::clip\n");

    path_->print();
  }

  *clippath_ = *path_;

  PSViewPathRenderer renderer(graphics_);

  path_->process(renderer);

  brush_.setFillRule(FILL_TYPE_WINDING);

  setGraphics();

  graphics_->pathClip();
}

void
PSViewGState::
eoclip()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::eoclip\n");

    path_->print();
  }

  *clippath_ = *path_;

  PSViewPathRenderer renderer(graphics_);

  path_->process(renderer);

  brush_.setFillRule(FILL_TYPE_EVEN_ODD);

  setGraphics();

  graphics_->pathClip();
}

void
PSViewGState::
clipPath()
{
  *path_ = *clippath_;

  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::clipPath\n");

    path_->print();
  }
}

void
PSViewGState::
flattenPath()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::flattenPath\n");

    path_->print();
  }

  path_->flatten();

  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::flattenPath\n");

    path_->print();
  }
}

void
PSViewGState::
reversePath()
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::reversePath\n");

    path_->print();
  }

  path_->reverse();

  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::reversePath\n");

    path_->print();
  }
}

void
PSViewGState::
pathBBox(double *llx, double *lly, double *urx, double *ury)
{
  double x1, y1, x2, y2;

  path_->getBounds(&x1, &y1, &x2, &y2);

  multiplyByInverseCTMMatrix(x1, y1, llx, lly);
  multiplyByInverseCTMMatrix(x2, y2, urx, ury);

  newPath();
}

void
PSViewGState::
pathForAll(PSViewToken *move_to_token, PSViewToken *line_to_token,
           PSViewToken *curve_to_token, PSViewToken *close_path_token)
{
  if (getPSView()->getDebug()) {
    CStrUtil::printf("PSViewGState::pathForAll\n");

    path_->print();
  }

  PSViewTokenPathVisitor visitor(getPSView(), move_to_token, line_to_token,
                                 curve_to_token, close_path_token);

  path_->process(visitor);
}

void
PSViewGState::
showPage()
{
  // if (graphics_ != NULL)
  //   graphics_->showPage();
}

void
PSViewGState::
erasePage()
{
  if (graphics_ != NULL)
    graphics_->clear(CRGBA(1,1,1));
}

void
PSViewGState::
setCacheDevice(double wx, double wy, double llx, double lly, double urx, double ury)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  font_data->cache_device_wx  = wx;
  font_data->cache_device_wy  = wy;
  font_data->cache_device_llx = llx;
  font_data->cache_device_lly = lly;
  font_data->cache_device_urx = urx;
  font_data->cache_device_ury = ury;
}

void
PSViewGState::
setCharWidth(double wx, double wy)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  font_data->cache_device_wx = wx;
  font_data->cache_device_wy = wy;
}

void
PSViewGState::
getCharWidth(double *wx, double *wy)
{
  double cx, cy;

  getCharWidth1(&cx, &cy);

  double x1, y1;

  multiplyDistByCTMMatrix(cx, cy, &x1, &y1);

  *wx = x1;
  *wy = y1;
}

void
PSViewGState::
getCharWidth1(double *wx, double *wy)
{
  PSViewGStateFont *font = getFont();

  PSViewGStateFont3Data *font_data = font->getFont3Data();

  *wx = font_data->cache_device_wx;
  *wy = font_data->cache_device_wy;
}

void
PSViewGState::
defineFont(PSViewToken *key, PSViewDictionaryToken *dictionary)
{
  PSViewToken *token = dictionary->getValue("FontType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);

    return;
  }

  PSVinteger type = token->getIntegerValue();

  if (type != PSVIEW_FONT_TYPE_DEFAULT &&
      type != PSVIEW_FONT_TYPE_0       &&
      type != PSVIEW_FONT_TYPE_1       &&
      type != PSVIEW_FONT_TYPE_3) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_LIMIT_CHECK);

    return;
  }

  if      (type == PSVIEW_FONT_TYPE_0)
    defineType0Font(key, dictionary);
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: Type 1 Fonts not Implemented\n");
  else if (type == PSVIEW_FONT_TYPE_3)
    defineType3Font(key, dictionary);
}

void
PSViewGState::
defineType0Font(PSViewToken *key, PSViewDictionaryToken *dictionary)
{
  PSViewToken *token = dictionary->getValue("FontMatrix");

  if (token == NULL || ! token->isMatrix()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  //------

  token = dictionary->getValue("FMapType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  //------

  token = dictionary->getValue("Encoding");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  PSVinteger encoding_size = array_token->getNumValues();

  for (int i = 1; i <= encoding_size; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isInteger()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }
  }

  //------

  token = dictionary->getValue("FDepVector");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  array_token = (PSViewArrayToken *) token;

  PSVinteger num_fonts = array_token->getNumValues();

  for (int i = 1; i <= num_fonts; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isDictionary()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }
  }

  //------

  PSViewToken *key1 = new PSViewNameToken(getPSView(), "FID");

  PSViewToken *value1 = new PSViewFontIdToken(getPSView(), mgr_->getNextFontId());

  dictionary->addValue(key1, value1);

  //------

  token = getPSView()->getDictionaryMgr()->lookup("FontDirectory");

  if (token == NULL || ! token->isDictionary())
    return;

  PSViewDictionaryToken *dictionary_token = (PSViewDictionaryToken *) token;

  dictionary_token->addValue(key, dictionary);

  //------

  getPSView()->getOperandStack()->push(value1);

  return;
}

void
PSViewGState::
defineType3Font(PSViewToken *key, PSViewDictionaryToken *dictionary)
{
  PSViewToken *token = dictionary->getValue("FontMatrix");

  if (token == NULL || ! token->isMatrix()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  //------

  token = dictionary->getValue("Encoding");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  PSVinteger num_tokens = array_token->getNumValues();

  if (num_tokens != 256) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  for (int i = 1; i <= 256; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isName()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }
  }

  //------

  token = dictionary->getValue("FontBBox");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  array_token = (PSViewArrayToken *) token;

  num_tokens = array_token->getNumValues();

  if (num_tokens != 4) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  for (int i = 1; i <= 4; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }
  }

  //------

  token = dictionary->getValue("BuildChar");

  if (token != NULL && ! token->isProcedure()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  //------

  token = dictionary->getValue("BuildGlyph");

  if (token != NULL && ! token->isProcedure()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  //------

  PSViewToken *key1 = new PSViewNameToken(getPSView(), "FID");

  PSViewToken *value1 = new PSViewFontIdToken(getPSView(), mgr_->getNextFontId());

  dictionary->addValue(key1, value1);

  //------

  token = getPSView()->getDictionaryMgr()->lookup("FontDirectory");

  if (token == NULL || ! token->isDictionary()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  PSViewDictionaryToken *dictionary_token = (PSViewDictionaryToken *) token;

  dictionary_token->addValue(key, dictionary);

  //------

  getPSView()->getOperandStack()->push(value1);

  return;
}

void
PSViewGState::
undefineFont(PSViewToken *key)
{
  PSViewToken *token = getPSView()->getDictionaryMgr()->lookup("FontDirectory");

  if (token == NULL || ! token->isDictionary())
    return;

  PSViewDictionaryToken *dictionary = (PSViewDictionaryToken *) token;

  dictionary->addValue(key, NULL);
}

PSViewDictionaryToken *
PSViewGState::
findFont(PSViewToken *key)
{
  PSViewToken *token = getPSView()->getDictionaryMgr()->lookup("FontDirectory");

  if (token == NULL || ! token->isDictionary())
    return mgr_->getDefaultFont();

  PSViewDictionaryToken *dictionary = (PSViewDictionaryToken *) token;

  token = dictionary->getValue(key);

  PSViewDictionaryToken *font;

  if (token != NULL && token->isDictionary())
    font = (PSViewDictionaryToken *) token;
  else
    font = readFont(key);

  return font;
}

PSViewDictionaryToken *
PSViewGState::
readFont(PSViewToken *key)
{
  if (! key->isName())
    return mgr_->getDefaultFont();

  PSViewToken *key1 = NULL;

  PSViewNameToken *name_token = (PSViewNameToken *) key;

  const PSViewName &name = name_token->getValue();

  string name1 = name.getString();

  bool file_found = false;

  string font_dir = COSEnv::getenv("PSVIEW_FONT_DIR");

  if (font_dir == "")
    font_dir = COSUser::getUserHome() + "/data/PSView/fonts";

  char font_filename[256];

  if (font_dir[font_dir.size() - 1] == '/')
    sprintf(font_filename, "%s%s.font", font_dir.c_str(), name1.c_str());
  else
    sprintf(font_filename, "%s/%s.font", font_dir.c_str(), name1.c_str());

  struct stat file_stat;

  if (stat(font_filename, &file_stat) != -1)
    file_found = true;

  if (! file_found) {
    if (font_dir[font_dir.size() - 1] == '/')
      sprintf(font_filename, "%s%s.font", font_dir.c_str(), name1.c_str());
    else
      sprintf(font_filename, "%s/%s.font", font_dir.c_str(), name1.c_str());

    struct stat file_stat;

    if (stat(font_filename, &file_stat) != -1)
      file_found = true;
  }

  if (! file_found) {
    sprintf(font_filename, "%s.font", name1.c_str());

    struct stat file_stat;

    if (stat(font_filename, &file_stat) != -1)
      file_found = true;
  }

  if (! file_found) {
    if (CStrUtil::casefind(name1, "Bold") != string::npos) {
      if (CStrUtil::casefind(name1, "Italic" ) != string::npos ||
          CStrUtil::casefind(name1, "Oblique") != string::npos)
        name1 = "Helvetica-BoldOblique";
      else
        name1 = "Helvetica-Bold";
    }
    else {
      if (CStrUtil::casefind(name1, "Italic" ) != string::npos ||
          CStrUtil::casefind(name1, "Oblique") != string::npos)
        name1 = "Helvetica-Oblique";
      else
        name1 = "Helvetica";
    }

    key1 = key;
    key  = new PSViewNameToken(getPSView(), name1);

    if (font_dir[font_dir.size() - 1] == '/')
      sprintf(font_filename, "%s%s.font", font_dir.c_str(), name1.c_str());
    else
      sprintf(font_filename, "%s/%s.font", font_dir.c_str(), name1.c_str());

    struct stat file_stat;

    if (stat(font_filename, &file_stat) != -1)
      file_found = true;

    if (! file_found) {
      if (font_dir[font_dir.size() - 1] == '/')
        sprintf(font_filename, "%s%s.font", font_dir.c_str(), name1.c_str());
      else
        sprintf(font_filename, "%s/%s.font", font_dir.c_str(), name1.c_str());

      struct stat file_stat;

      if (stat(font_filename, &file_stat) != -1)
        file_found = true;
    }

    if (! file_found) {
      sprintf(font_filename, "%s.font", name1.c_str());

      struct stat file_stat;

      if (stat(font_filename, &file_stat) != -1)
        file_found = true;
    }
  }

  if (! file_found)
    return mgr_->getDefaultFont();

  getPSView()->openCurrentFile(font_filename);

  getPSView()->executeCurrentFile();

  getPSView()->closeCurrentFile();

  PSViewToken *token = getPSView()->getDictionaryMgr()->lookup("FontDirectory");

  if (token == NULL || ! token->isDictionary())
    return mgr_->getDefaultFont();

  PSViewDictionaryToken *dictionary = (PSViewDictionaryToken *) token;

  token = dictionary->getValue(key);

  if (token == NULL || ! token->isDictionary())
    return mgr_->getDefaultFont();

  if (key1 != NULL)
    dictionary->addValue(key1, token);

  PSViewDictionaryToken *font = (PSViewDictionaryToken *) token;

  return font;
}

void
PSViewGState::
setFont(PSViewDictionaryToken *font_dictionary)
{
  setFont1(font_dictionary);
}

void
PSViewGState::
setFont1(PSViewDictionaryToken *font_dictionary)
{
  PSViewToken *token = font_dictionary->getValue("FontType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  PSVinteger type = token->getIntegerValue();

  if (type != PSVIEW_FONT_TYPE_DEFAULT &&
      type != PSVIEW_FONT_TYPE_0       &&
      type != PSVIEW_FONT_TYPE_1       &&
      type != PSVIEW_FONT_TYPE_3) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_LIMIT_CHECK);
    return;
  }

  //------

  token = font_dictionary->getValue("FontMatrix");

  if (token == NULL || ! token->isMatrix()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return;
  }

  CAutoPtr<CMatrix2D> matrix;

  matrix = token->getMatrix();

  //------

  PSViewGStateFont *font = getFont();

  if      (type == PSVIEW_FONT_TYPE_DEFAULT) {
    font->setDefaultFont(font_dictionary, matrix);
  }
  else if (type == PSVIEW_FONT_TYPE_0) {
    PSViewToken *token1 = font_dictionary->getValue("Encoding");

    if (token1 == NULL || ! token1->isArray()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    PSViewArrayToken *array_token = (PSViewArrayToken *) token1;

    PSVinteger encoding_size = array_token->getNumValues();

    if (encoding_size == 0) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    vector<int> encoding;

    encoding.resize(encoding_size);

    for (int i = 1; i <= encoding_size; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isInteger()) {
        getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
        return;
      }

      encoding[i - 1] = sub_token->getIntegerValue();
    }

    //------

    token1 = font_dictionary->getValue("FMapType");

    if (token1 == NULL || ! token1->isInteger()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    PSVinteger map_type = token1->getIntegerValue();

    //------

    token1 = font_dictionary->getValue("EscChar");

    if (token1 != NULL && ! token1->isInteger()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    PSVinteger escape_char = 255;

    if (token1 != NULL)
      escape_char = token1->getIntegerValue();

    //------

    token1 = font_dictionary->getValue("FDepVector");

    if (token1 == NULL || ! token1->isArray()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    array_token = (PSViewArrayToken *) token1;

    PSVinteger num_fonts = array_token->getNumValues();

    if (num_fonts == 0) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    vector<PSViewDictionaryToken *> font_array;

    font_array.resize(num_fonts);

    for (int i = 1; i <= num_fonts; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isDictionary()) {
        getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
        return;
      }

      font_array[i - 1] = (PSViewDictionaryToken *) sub_token;
    }

    //------

    font->setType1Font(font_dictionary, encoding_size, encoding,
                        map_type, escape_char, num_fonts, font_array);
  }
  else if (type == PSVIEW_FONT_TYPE_1)
    CStrUtil::eprintf("PSView: Type 1 Fonts not implemented\n");
  else if (type == PSVIEW_FONT_TYPE_3) {
    PSViewToken *encoding = font_dictionary->getValue("Encoding");

    if (encoding == NULL || ! encoding->isArray()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    //------

    PSViewToken *build_glyph = font_dictionary->getValue("BuildGlyph");
    PSViewToken *build_char  = font_dictionary->getValue("BuildChar" );

    PSViewToken         *build;
    PSViewFontBuildType  build_type;

    if (build_glyph != NULL) {
      build      = build_glyph;
      build_type = PSVIEW_FONT_BUILD_TYPE_GLYPH;
    }
    else {
      build      = build_char;
      build_type = PSVIEW_FONT_BUILD_TYPE_CHAR;
    }

    if (build == NULL || ! build->isProcedure()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return;
    }

    //------

    font->setType3Font(font_dictionary, matrix, encoding, build, build_type);
  }
}

PSViewDictionaryToken *
PSViewGState::
getCurrentFont()
{
  PSViewGStateFont *font = getFont();

  return font->getDictionary();
}

PSViewDictionaryToken *
PSViewGState::
getRootFont()
{
  PSViewGStateFont *font = getFont();

  PSViewDictionaryToken *root_font = font->getDictionary();

  if (root_font != NULL)
    return root_font;
  else
    return getCurrentFont();
}

void
PSViewGState::
selectScaleFont(PSViewToken *key, PSVreal scale)
{
  getPSView()->getOperandStack()->push(key);

  PSViewToken *findfont = getPSView()->getDictionaryMgr()->lookup("findfont");

  findfont->execute();

  PSViewToken *token = getPSView()->getOperandStack()->pop();

  PSViewDictionaryToken *font = (PSViewDictionaryToken *) token;

  PSViewDictionaryToken *font_dictionary1 = scaleFont(font, scale);

  setFont(font_dictionary1);
}

void
PSViewGState::
selectMakeFont(PSViewToken *key, CMatrix2D *matrix)
{
  getPSView()->getOperandStack()->push(key);

  PSViewToken *findfont = getPSView()->getDictionaryMgr()->lookup("findfont");

  findfont->execute();

  PSViewToken *token = getPSView()->getOperandStack()->pop();

  PSViewDictionaryToken *font = (PSViewDictionaryToken *) token;

  PSViewDictionaryToken *font_dictionary1 = makeFont(font, matrix);

  setFont(font_dictionary1);
}

PSViewDictionaryToken *
PSViewGState::
scaleFont(PSViewDictionaryToken *font_dictionary, PSVreal scale)
{
  PSViewToken *token = font_dictionary->getValue("FontType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return NULL;
  }

  PSVinteger type = token->getIntegerValue();

  if (type != PSVIEW_FONT_TYPE_DEFAULT &&
      type != PSVIEW_FONT_TYPE_0       &&
      type != PSVIEW_FONT_TYPE_1       &&
      type != PSVIEW_FONT_TYPE_3) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_LIMIT_CHECK);
    return NULL;
  }

  if (type == PSVIEW_FONT_TYPE_0) {
    PSViewToken *token = font_dictionary->getValue("FDepVector");

    if (token == NULL || ! token->isArray()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
      return NULL;
    }

    PSViewArrayToken *array_token = (PSViewArrayToken *) token;

    int num_fonts = array_token->getNumValues();

    for (int i = 1; i <= num_fonts; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isDictionary()) {
        getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
        return NULL;
      }

      PSViewDictionaryToken *dictionary = (PSViewDictionaryToken *) sub_token;

      PSViewDictionaryToken *font_dictionary1 = scaleFont(dictionary, scale);

      array_token->setValue(i, font_dictionary1);
    }

    return font_dictionary;
  }

  PSViewToken *token_m1 = font_dictionary->getValue("FontMatrix");

  if (token_m1 == NULL) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return NULL;
  }

  CAutoPtr<CMatrix2D> matrix;

  matrix = token_m1->getMatrix();

  CMatrix2D matrix1;

  matrix1.setScale(scale, scale);

  CMatrix2D matrix2 = matrix1 * (*matrix);

  PSViewToken *token_m2 = new PSViewArrayToken(getPSView(), &matrix2);

  //------

  PSVinteger size = font_dictionary->getMaxValues();

  PSViewDictionaryToken *font_dictionary1 =
    new PSViewDictionaryToken(getPSView()->getDictionaryMgr(), size);

  size = font_dictionary->getNumValues();

  for (int i = 1; i < size; i++) {
    PSViewKeyValue *keyval = font_dictionary->getKeyValue(i);

    font_dictionary1->addValue(keyval->getKey(), keyval->getValue());
  }

  //------

  PSViewToken *key = new PSViewNameToken(getPSView(), "FontMatrix");

  font_dictionary1->addValue(key, token_m2);

  return font_dictionary1;
}

PSViewDictionaryToken *
PSViewGState::
makeFont(PSViewDictionaryToken *font_dictionary, CMatrix2D *matrix)
{
  PSViewToken *token_m1 = font_dictionary->getValue("FontMatrix");

  if (token_m1 == NULL) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_FONT);
    return NULL;
  }

  CAutoPtr<CMatrix2D> matrix1;

  matrix1 = token_m1->getMatrix();

  CMatrix2D matrix2 = (*matrix) * (*matrix1);

  PSViewToken *token_m2 = new PSViewArrayToken(getPSView(), &matrix2);

  //------

  PSVinteger size = font_dictionary->getMaxValues();

  PSViewDictionaryToken *font_dictionary1 =
    new PSViewDictionaryToken(getPSView()->getDictionaryMgr(), size);

  size = font_dictionary->getNumValues();

  for (int i = 1; i < size; i++) {
    PSViewKeyValue *keyval = font_dictionary->getKeyValue(i);

    font_dictionary1->addValue(keyval->getKey(), keyval->getValue());
  }

  //------

  PSViewToken *key = new PSViewNameToken(getPSView(), "FontMatrix");

  font_dictionary1->addValue(key, token_m2);

  return font_dictionary1;
}

//------

PSViewDictionaryToken *
PSViewGState::
makePattern(PSViewDictionaryToken *pattern_dictionary, CMatrix2D *matrix)
{
  PSViewToken *token = pattern_dictionary->getValue("PatternType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  PSVinteger pattern_type = token->getIntegerValue();

  if (pattern_type != 1) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  //------

  token = pattern_dictionary->getValue("PaintType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  PSVinteger paint_type = token->getIntegerValue();

  if (paint_type != 1 && paint_type != 2) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  //------

  token = pattern_dictionary->getValue("TilingType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  PSVinteger tiling_type = token->getIntegerValue();

  if (tiling_type != 1 && tiling_type != 2 && tiling_type != 3) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  //------

  token = pattern_dictionary->getValue("BBox");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  PSVinteger num_tokens = array_token->getNumValues();

  if (num_tokens != 4) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  for (int i = 1; i <= 4; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return NULL;
    }
  }

  //------

  token = pattern_dictionary->getValue("XStep");

  if (token == NULL || ! token->isNumber()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  PSVreal x_step = token->getRealValue();

  if (x_step == 0.0) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  //------

  token = pattern_dictionary->getValue("YStep");

  if (token == NULL || ! token->isNumber()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  PSVreal y_step = token->getRealValue();

  if (y_step == 0.0) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  //------

  PSViewToken *paint_proc = pattern_dictionary->getValue("PaintProc");

  if (paint_proc == NULL || ! paint_proc->isProcedure()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return NULL;
  }

  //------

  PSVinteger size = pattern_dictionary->getMaxValues();

  PSViewDictionaryToken *pattern1 =
    new PSViewDictionaryToken(getPSView()->getDictionaryMgr(), size);

  size = pattern_dictionary->getNumValues();

  for (int i = 1; i <= size; i++) {
    PSViewKeyValue *keyval = pattern_dictionary->getKeyValue(i);

    pattern1->addValue(keyval->getKey(), keyval->getValue());
  }

  //------

  PSViewGStateToken *gstate_token =
    new PSViewGStateToken(*getPSView()->getGStateTokenMgr()->getCurrent());

  PSViewGState *gstate = gstate_token->getGState();

  CMatrix2D matrix1 = gstate->ctm_matrix_ * (*matrix);

  gstate->ctm_matrix_ = matrix1;

  gstate->newPath();

  gstate->initClip();

  //------

  PSViewToken *sub_token = new PSViewNameToken(getPSView(), "Implementation");

  pattern1->addValue(sub_token, gstate_token);

  return pattern1;
}

void
PSViewGState::
setPattern(PSViewDictionaryToken *pattern_dictionary)
{
  PSViewToken *token = pattern_dictionary->getValue("PatternType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  int pattern_type = token->getIntegerValue();

  if (pattern_type != 1) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  //------

  token = pattern_dictionary->getValue("PaintType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  int paint_type = token->getIntegerValue();

  if (paint_type != 1 && paint_type != 2) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  //------

  token = pattern_dictionary->getValue("TilingType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  int tiling_type = token->getIntegerValue();

  if (tiling_type != 1 && tiling_type != 2 && tiling_type != 3) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  //------

  token = pattern_dictionary->getValue("BBox");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  int num_tokens = array_token->getNumValues();

  if (num_tokens != 4) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  double bbox[4];

  for (int i = 1; i <= 4; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    bbox[i - 1] = sub_token->getRealValue();
  }

  //------

  token = pattern_dictionary->getValue("XStep");

  if (token == NULL || ! token->isNumber()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  double x_step = token->getRealValue();

  //------

  token = pattern_dictionary->getValue("YStep");

  if (token == NULL || ! token->isNumber()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  double y_step = token->getRealValue();

  //------

  PSViewToken *paint_proc = pattern_dictionary->getValue("PaintProc");

  if (paint_proc == NULL || ! paint_proc->isProcedure()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  //------

  token = pattern_dictionary->getValue("Implementation");

  if (token == NULL || ! token->isGState()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewGStateToken *gstate_token = (PSViewGStateToken *) token;

  PSViewGState *gstate = gstate_token->getGState();

  //------

  pattern_color_ = true;

  pattern_ = new PSViewGStatePattern(pattern_dictionary, pattern_type, paint_type, tiling_type,
                                     bbox, x_step, y_step, paint_proc, gstate);

  if (paint_type == 2) {
    gstate->color_space_   = color_space_;
    gstate->pattern_color_ = pattern_color_;
    gstate->pen_           = pen_;
  }
}

void
PSViewGState::
execForm(PSViewDictionaryToken *form_dictionary)
{
  PSViewToken *token = form_dictionary->getValue("FormType");

  if (token == NULL || ! token->isInteger()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVinteger form_type = token->getIntegerValue();

  if (form_type != 1) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  //------

  token = form_dictionary->getValue("BBox");

  if (token == NULL || ! token->isArray()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  PSVinteger num_tokens = array_token->getNumValues();

  if (num_tokens != 4) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  double bbox[4];

  for (int i = 1; i <= 4; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    bbox[i - 1] = sub_token->getRealValue();
  }

  //------

  token = form_dictionary->getValue("Matrix");

  if (token == NULL || ! token->isMatrix()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  CMatrix2D *matrix = token->getMatrix();

  //------

  PSViewToken *paint_proc = form_dictionary->getValue("PaintProc");

  if (paint_proc == NULL || ! paint_proc->isProcedure()) {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  //------

  token = new PSViewNameToken(getPSView(), "Implementation");

  PSViewToken *sub_token = new PSViewNullToken(getPSView());

  form_dictionary->addValue(token, sub_token);

  //------

  getPSView()->getGStateTokenMgr()->save();

  postMultiplyCTMMatrix(matrix);

  newPath();

  moveTo(bbox[0], bbox[1]);
  lineTo(bbox[2], bbox[1]);
  lineTo(bbox[2], bbox[3]);
  lineTo(bbox[0], bbox[3]);

  closePath();

  clip();

  newPath();

  getPSView()->getOperandStack()->push(form_dictionary);

  paint_proc->execute();

  getPSView()->getGStateTokenMgr()->restore();
}

void
PSViewGState::
setColorSpace(const PSViewName &color_space)
{
  color_space_ = &color_space;
}

void
PSViewGState::
setPatternColor(bool flag)
{
  pattern_color_ = flag;
}

const PSViewName &
PSViewGState::
getColorSpace()
{
  return *color_space_;
}

bool
PSViewGState::
getPatternColor()
{
  return pattern_color_;
}

void
PSViewGState::
setCMYKColor(const CCMYK &cmyk)
{
  cmyk_ = cmyk;

  cmyk_valid_ = true;
  hsb_valid_  = false;

  CRGBA rgba = CRGBA(cmyk_.toRGB());

  setRGBColor1(rgba);
}

void
PSViewGState::
getCMYKColor(CCMYK &cmyk)
{
  if (! cmyk_valid_)
    cmyk_ = rgbToCMYK(pen_.getColor());

  cmyk = cmyk_;
}

void
PSViewGState::
setHSBColor(const CHSB &hsb)
{
  hsb_ = hsb;

  hsb_valid_  = true;
  cmyk_valid_ = false;

  CRGBA rgba = CRGBA(hsb_.toRGB());

  setRGBColor1(rgba);
}

void
PSViewGState::
getHSBColor(CHSB &hsb)
{
  if (! hsb_valid_)
    hsb_ = CHSB::fromRGB(pen_.getColor().getRGB());

  hsb = hsb_;
}

CCMYK
PSViewGState::
rgbToCMYK(const CRGBA &rgba)
{
  CCMYK cmyk = CCMYK::fromRGB(rgba.getRGB());

  //------

  double black = cmyk.getBlack();

  PSViewToken *token1 = new PSViewRealToken(getPSView(), black);

  getPSView()->getOperandStack()->push(token1);

  PSViewToken *proc = getBlackGeneration();

  proc->execute();

  PSViewToken *token2 = getPSView()->getOperandStack()->pop();

  if (token2 != NULL) {
    black = token2->getRealValue();

    black = std::min(std::max(black, 0.0), 1.0);

    cmyk.setBlack(black);
  }

  delete token1;

  //------

  double delta = cmyk.getBlack();

  token1 = new PSViewRealToken(getPSView(), delta);

  getPSView()->getOperandStack()->push(token1);

  proc = getUnderColorRemoval();

  proc->execute();

  token2 = getPSView()->getOperandStack()->pop();

  if (token2 != NULL) {
    delta = token2->getRealValue();

    cmyk.lighten(delta);
  }

  delete token1;

  //------

  return cmyk;
}

void
PSViewGState::
setRGBColor(const CRGBA &rgba)
{
  cmyk_valid_ = false;
  hsb_valid_  = false;

  setRGBColor1(rgba);
}

void
PSViewGState::
setRGBColor1(const CRGBA &rgba)
{
  pen_  .setColor(rgba);
  brush_.setColor(rgba);
}

void
PSViewGState::
getRGBColor(CRGBA &rgba)
{
  rgba = pen_.getColor();
}

void
PSViewGState::
setGray(double gray)
{
  setRGBColor1(CRGBA(gray));
}

double
PSViewGState::
getGray()
{
  return pen_.getColor().getGray();
}

void
PSViewGState::
setFlat(double flat)
{
  if (flat < 0.2) flat = 0.2;
  if (flat > 100) flat = 100;

  pen_.setFlatness(flat);
}

double
PSViewGState::
getFlat()
{
  return pen_.getFlatness();
}

void
PSViewGState::
setLineWidth(double line_width)
{
  pen_.setWidth(line_width);
}

double
PSViewGState::
getLineWidth()
{
  return pen_.getWidth();
}

void
PSViewGState::
setLineCap(CLineCapType line_cap)
{
  pen_.setLineCap(line_cap);
}

CLineCapType
PSViewGState::
getLineCap()
{
  return pen_.getLineCap();
}

void
PSViewGState::
setLineJoin(CLineJoinType line_join)
{
  pen_.setLineJoin(line_join);
}

CLineJoinType
PSViewGState::
getLineJoin()
{
  return pen_.getLineJoin();
}

void
PSViewGState::
setMitreLimit(double mitre_limit)
{
  pen_.setMitreLimit(mitre_limit);
}

double
PSViewGState::
getMitreLimit()
{
  return pen_.getMitreLimit();
}

void
PSViewGState::
setStrokeAdjust(bool flag)
{
  stroke_adjust_ = flag;
}

bool
PSViewGState::
getStrokeAdjust()
{
  return stroke_adjust_;
}

void
PSViewGState::
setDashPattern(double *dash_array, int num_dashes, double dash_offset)
{
  CLineDash dash;

  dash.setDashes(dash_array, num_dashes, dash_offset);

  pen_.setLineDash(dash);
}

void
PSViewGState::
getDashPattern(const double **dash_array, int *num_dashes, double *dash_offset)
{
  const CLineDash &dash = pen_.getLineDash();

  *dash_array  = dash.getLengths();
  *num_dashes  = dash.getNumLengths();
  *dash_offset = dash.getOffset();
}

void
PSViewGState::
setBlackGeneration(PSViewToken *token)
{
  black_generation_ = token;
}

PSViewToken *
PSViewGState::
getBlackGeneration()
{
  if (black_generation_ == NULL) {
    black_generation_ = new PSViewArrayToken(getPSView(), (uint) 0);

    black_generation_->setExecutable();
  }

  return black_generation_;
}

void
PSViewGState::
setUnderColorRemoval(PSViewToken *token)
{
  undercolor_removal_ = token;
}

PSViewToken *
PSViewGState::
getUnderColorRemoval()
{
  if (undercolor_removal_ == NULL) {
    undercolor_removal_ = new PSViewArrayToken(getPSView(), (uint) 0);

    undercolor_removal_->setExecutable();
  }

  return undercolor_removal_;
}

void
PSViewGState::
setCTMMatrix(CMatrix2D *matrix)
{
  ctm_matrix_ = *matrix;
}

CMatrix2D *
PSViewGState::
getCTMMatrix()
{
  return &ctm_matrix_;
}

CMatrix2D *
PSViewGState::
getInverseCTMMatrix()
{
  static CMatrix2D imatrix;

  bool flag = ctm_matrix_.invert(imatrix);

  if (flag)
    return &imatrix;
  else
    return NULL;
}

void
PSViewGState::
preMultiplyCTMMatrix(CMatrix2D *matrix)
{
  CMatrix2D matrix1 = (*matrix) * ctm_matrix_;

  setCTMMatrix(&matrix1);
}

void
PSViewGState::
postMultiplyCTMMatrix(CMatrix2D *matrix)
{
  CMatrix2D matrix1 = ctm_matrix_ * (*matrix);

  setCTMMatrix(&matrix1);
}

void
PSViewGState::
multiplyDistByCTMMatrix(double x1, double y1, double *x2, double *y2)
{
  CMatrix2D *matrix = getCTMMatrix();

  double tx1, ty1, tx2, ty2;

  matrix->multiplyPoint(0 , 0 , &tx1, &ty1);
  matrix->multiplyPoint(x1, y1, &tx2, &ty2);

  *x2 = tx2 - tx1;
  *y2 = ty2 - ty1;
}

void
PSViewGState::
multiplyByCTMMatrix(double x1, double y1, double *x2, double *y2)
{
  CMatrix2D *matrix = getCTMMatrix();

  matrix->multiplyPoint(x1, y1, x2, y2);
}

void
PSViewGState::
multiplyByInverseCTMMatrix(double x1, double y1, double *x2, double *y2)
{
  CMatrix2D *imatrix = getInverseCTMMatrix();

  if (imatrix != NULL)
    imatrix->multiplyPoint(x1, y1, x2, y2);
  else {
    *x2 = x1;
    *y2 = y1;
  }
}
##concat##CPSViewGStateToken.cpp
#include <CPSViewI.h>

PSViewGStateTokenMgr::
PSViewGStateTokenMgr(CPSView *psview) :
 psview_        (psview),
 current_gstate_(NULL)
{
}

PSViewGStateTokenMgr::
~PSViewGStateTokenMgr()
{
}

void
PSViewGStateTokenMgr::
init()
{
  current_gstate_ = NULL;
}

PSViewGStateToken *
PSViewGStateTokenMgr::
getCurrent()
{
  if (current_gstate_ == NULL)
    current_gstate_ = new PSViewGStateToken(psview_);

  return current_gstate_;
}

void
PSViewGStateTokenMgr::
setCurrent(PSViewGStateToken *gstate_token)
{
  current_gstate_ = gstate_token;
}

PSViewGStateToken *
PSViewGStateTokenMgr::
save()
{
  PSViewGStateToken *gstate_token = getCurrent()->dup();

  psview_->getGraphicsStack()->push(gstate_token);

  return getCurrent();
}

PSViewGStateToken *
PSViewGStateTokenMgr::
restore()
{
  PSViewGStateToken *gstate_token = psview_->getGraphicsStack()->pop();

  *current_gstate_ = *gstate_token;

  delete gstate_token;

  return getCurrent();
}

void
PSViewGStateTokenMgr::
restoreAll()
{
  int num = psview_->getGraphicsStack()->size();

  if (num < 1)
    return;

  for (int i = 0; i < num - 1; i++) {
    PSViewGStateToken *gstate_token = psview_->getGraphicsStack()->pop();

    delete gstate_token;
  }

  restore();

  getCurrent()->initGraphics();
}

//----------------

PSViewGStateToken::
PSViewGStateToken(CPSView *psview) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_GSTATE,
             PSVIEW_TOKEN_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 gstate_    ()
{
  gstate_ = new PSViewGState(psview_->getGStateMgr());
}

PSViewGStateToken::
PSViewGStateToken(const PSViewGStateToken &gstate_token) :
 PSViewToken(gstate_token),
 gstate_    ()
{
  gstate_ = new PSViewGState(*gstate_token.gstate_);
}

PSViewGStateToken::
~PSViewGStateToken()
{
}

const PSViewGStateToken &
PSViewGStateToken::
operator=(const PSViewGStateToken &gstate_token)
{
  if (&gstate_token == this)
    return *this;

  *gstate_ = *gstate_token.gstate_;

  return *this;
}

PSViewGStateToken *
PSViewGStateToken::
dup() const
{
  return new PSViewGStateToken(*this);
}

int
PSViewGStateToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewGStateToken *gstate_token = dynamic_cast<PSViewGStateToken *>(token);

    return gstate_->compare(gstate_token->gstate_);
  }
  else
    return type_ - token->getType();
}

void
PSViewGStateToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for GState Missing\n");
}

const PSViewName &
PSViewGStateToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewGStateToken::
print()
{
  CStrUtil::printf("-gstate-");
}

string
PSViewGStateToken::
toString()
{
  return "--nostringval--";
}

void
PSViewGStateToken::
initGraphics()
{
  gstate_->initGraphics();
}

void
PSViewGStateToken::
newPath()
{
  gstate_->newPath();
}

void
PSViewGStateToken::
initMatrix()
{
  gstate_->initMatrix();
}

void
PSViewGStateToken::
initClip()
{
  gstate_->initClip();
}

void
PSViewGStateToken::
moveTo(double x, double y)
{
  gstate_->moveTo(x, y);
}

void
PSViewGStateToken::
rmoveTo(double x, double y)
{
  gstate_->rmoveTo(x, y);
}

void
PSViewGStateToken::
lineTo(double x, double y)
{
  gstate_->lineTo(x, y);
}

void
PSViewGStateToken::
rlineTo(double x, double y)
{
  gstate_->rlineTo(x, y);
}

void
PSViewGStateToken::
arc(double x, double y, double r, double angle1, double angle2)
{
  gstate_->arc(x, y, r, angle1, angle2);
}

void
PSViewGStateToken::
arcN(double x, double y, double r, double angle1, double angle2)
{
  gstate_->arcN(x, y, r, angle1, angle2);
}

void
PSViewGStateToken::
arcTo(double x1, double y1, double x2, double y2, double r,
      double *xt1, double *yt1, double *xt2, double *yt2)
{
  gstate_->arcTo(x1, y1, x2, y2, r, xt1, yt1, xt2, yt2);
}

void
PSViewGStateToken::
curveTo(double x1, double y1, double x2, double y2, double x3, double y3)
{
  gstate_->curveTo(x1, y1, x2, y2, x3, y3);
}

void
PSViewGStateToken::
rcurveTo(double x1, double y1, double x2, double y2, double x3, double y3)
{
  gstate_->rcurveTo(x1, y1, x2, y2, x3, y3);
}

bool
PSViewGStateToken::
getCurrentPoint(double *x, double *y)
{
  return gstate_->getCurrentPoint(x, y);
}

void
PSViewGStateToken::
show(const string &str)
{
  gstate_->show(str);
}

void
PSViewGStateToken::
ashow(double ax, double ay, const string &str)
{
  gstate_->ashow(ax, ay, str);
}

void
PSViewGStateToken::
widthShow(double cx, double cy, int c, const string &str)
{
  gstate_->widthShow(cx, cy, c, str);
}

void
PSViewGStateToken::
awidthShow(double cx, double cy, int c, double ax, double ay,
           const string &str)
{
  gstate_->awidthShow(cx, cy, c, ax, ay, str);
}

void
PSViewGStateToken::
glyphShow(const PSViewName &name)
{
  gstate_->glyphShow(name);
}

void
PSViewGStateToken::
kshow(PSViewToken *proc, const string &str)
{
  gstate_->kshow(proc, str);
}

void
PSViewGStateToken::
stringWidth(const string &str, double *wx, double *wy)
{
  gstate_->stringWidth(str, wx, wy);
}

void
PSViewGStateToken::
charPath(const string &str, bool flag)
{
  gstate_->charPath(str, flag);
}

void
PSViewGStateToken::
image(char *image_data, int width, int height, int bits_per_sample,
      CMatrix2D *matrix, double *decode_array, int decode_size)
{
  gstate_->image(image_data, width, height, bits_per_sample,
                 matrix, decode_array, decode_size);
}

void
PSViewGStateToken::
imageMask(char *image_data, int width, int height,
          int polarity, CMatrix2D *matrix)
{
  gstate_->imageMask(image_data, width, height, polarity, matrix);
}

void
PSViewGStateToken::
closePath()
{
  gstate_->closePath();
}

void
PSViewGStateToken::
rectStroke(double x, double y, double width, double height, CMatrix2D *matrix)
{
  gstate_->rectStroke(x, y, width, height, matrix);
}

void
PSViewGStateToken::
rectFill(double x, double y, double width, double height)
{
  gstate_->rectFill(x, y, width, height);
}

void
PSViewGStateToken::
rectClip(double *x, double *y, double *width, double *height, int num_rects)
{
  gstate_->rectClip(x, y, width, height, num_rects);
}

void
PSViewGStateToken::
stroke()
{
  gstate_->stroke();
}

void
PSViewGStateToken::
strokePath()
{
  gstate_->strokePath();
}

void
PSViewGStateToken::
fill()
{
  gstate_->fill();
}

void
PSViewGStateToken::
eofill()
{
  gstate_->eofill();
}

void
PSViewGStateToken::
clip()
{
  gstate_->clip();
}

void
PSViewGStateToken::
eoclip()
{
  gstate_->eoclip();
}

void
PSViewGStateToken::
clipPath()
{
  gstate_->clipPath();
}

void
PSViewGStateToken::
flattenPath()
{
  gstate_->flattenPath();
}

void
PSViewGStateToken::
reversePath()
{
  gstate_->reversePath();
}

void
PSViewGStateToken::
pathBBox(double *llx, double *lly, double *urx, double *ury)
{
  gstate_->pathBBox(llx, lly, urx, ury);
}

void
PSViewGStateToken::
pathForAll(PSViewToken *move_to_token, PSViewToken *line_to_token,
           PSViewToken *curve_to_token, PSViewToken *close_path_token)
{
  gstate_->pathForAll(move_to_token, line_to_token,
                      curve_to_token, close_path_token);
}

void
PSViewGStateToken::
showPage()
{
  gstate_->showPage();
}

void
PSViewGStateToken::
erasePage()
{
  gstate_->erasePage();
}

void
PSViewGStateToken::
defineFont(PSViewToken *key, PSViewDictionaryToken *dictionary)
{
  gstate_->defineFont(key, dictionary);
}

void
PSViewGStateToken::
undefineFont(PSViewToken *key)
{
  gstate_->undefineFont(key);
}

void
PSViewGStateToken::
setCacheDevice(double wx, double wy, double llx, double lly,
               double urx, double ury)
{
  gstate_->setCacheDevice(wx, wy, llx, lly, urx, ury);
}

void
PSViewGStateToken::
setCharWidth(double wx, double wy)
{
  gstate_->setCharWidth(wx, wy);
}

void
PSViewGStateToken::
getCharWidth(double *wx, double *wy)
{
  gstate_->getCharWidth(wx, wy);
}

PSViewDictionaryToken *
PSViewGStateToken::
findFont(PSViewToken *key)
{
  return gstate_->findFont(key);
}

PSViewDictionaryToken *
PSViewGStateToken::
readFont(PSViewToken *key)
{
  return gstate_->readFont(key);
}

void
PSViewGStateToken::
setFont(PSViewDictionaryToken *font)
{
  gstate_->setFont(font);
}

PSViewToken *
PSViewGStateToken::
getCurrentFont()
{
  return gstate_->getCurrentFont();
}

PSViewToken *
PSViewGStateToken::
getRootFont()
{
  return gstate_->getRootFont();
}

void
PSViewGStateToken::
selectScaleFont(PSViewToken *key, PSVreal scale)
{
  gstate_->selectScaleFont(key, scale);
}

void
PSViewGStateToken::
selectMakeFont(PSViewToken *key, CMatrix2D *matrix)
{
  gstate_->selectMakeFont(key, matrix);
}

PSViewDictionaryToken *
PSViewGStateToken::
scaleFont(PSViewDictionaryToken *font_dictionary, PSVreal scale)
{
  return gstate_->scaleFont(font_dictionary, scale);
}

PSViewDictionaryToken *
PSViewGStateToken::
makeFont(PSViewDictionaryToken *font_dictionary, CMatrix2D *matrix)
{
  return gstate_->makeFont(font_dictionary, matrix);
}

PSViewDictionaryToken *
PSViewGStateToken::
makePattern(PSViewDictionaryToken *pattern_dictionary, CMatrix2D *matrix)
{
  return gstate_->makePattern(pattern_dictionary, matrix);
}

void
PSViewGStateToken::
setPattern(PSViewDictionaryToken *pattern_dictionary)
{
  gstate_->setPattern(pattern_dictionary);
}

void
PSViewGStateToken::
execForm(PSViewDictionaryToken *form_dictionary)
{
  gstate_->execForm(form_dictionary);
}

void
PSViewGStateToken::
setColorSpace(const PSViewName &color_space)
{
  gstate_->setColorSpace(color_space);
}

void
PSViewGStateToken::
setPatternColor(bool pattern)
{
  gstate_->setPatternColor(pattern);
}

const PSViewName &
PSViewGStateToken::
getColorSpace()
{
  return gstate_->getColorSpace();
}

PSViewNameToken *
PSViewGStateToken::
getColorSpaceToken()
{
  const PSViewName &color_space = gstate_->getColorSpace();

  PSViewNameToken *token = new PSViewNameToken(psview_, color_space);

  token->setLiteral();

  return token;
}

bool
PSViewGStateToken::
getPatternColor()
{
  return gstate_->getPatternColor();
}

void
PSViewGStateToken::
setCMYKColor(const CCMYK &cmyk)
{
  gstate_->setCMYKColor(cmyk);
}

void
PSViewGStateToken::
getCMYKColor(CCMYK &cmyk)
{
  gstate_->getCMYKColor(cmyk);
}

void
PSViewGStateToken::
setHSBColor(const CHSB &hsb)
{
  gstate_->setHSBColor(hsb);
}

void
PSViewGStateToken::
getHSBColor(CHSB &hsb)
{
  gstate_->getHSBColor(hsb);
}

void
PSViewGStateToken::
setRGBColor(const CRGBA &rgba)
{
  gstate_->setRGBColor(rgba);
}

void
PSViewGStateToken::
getRGBColor(CRGBA &rgba)
{
  gstate_->getRGBColor(rgba);
}

void
PSViewGStateToken::
setGray(double gray)
{
  gstate_->setGray(gray);
}

void
PSViewGStateToken::
getGray(double *gray)
{
  *gray = gstate_->getGray();
}

void
PSViewGStateToken::
setFlat(double flat)
{
  gstate_->setFlat(flat);
}

double
PSViewGStateToken::
getFlat()
{
  return gstate_->getFlat();
}

void
PSViewGStateToken::
setLineWidth(double line_width)
{
  gstate_->setLineWidth(line_width);
}

double
PSViewGStateToken::
getLineWidth()
{
  return gstate_->getLineWidth();
}

void
PSViewGStateToken::
setLineCap(CLineCapType line_cap)
{
  gstate_->setLineCap(line_cap);
}

CLineCapType
PSViewGStateToken::
getLineCap()
{
  return gstate_->getLineCap();
}

void
PSViewGStateToken::
setLineJoin(CLineJoinType line_join)
{
  gstate_->setLineJoin(line_join);
}

CLineJoinType
PSViewGStateToken::
getLineJoin()
{
  return gstate_->getLineJoin();
}

void
PSViewGStateToken::
setMitreLimit(double mitre_limit)
{
  gstate_->setMitreLimit(mitre_limit);
}

double
PSViewGStateToken::
getMitreLimit()
{
  return gstate_->getMitreLimit();
}

void
PSViewGStateToken::
setStrokeAdjust(bool flag)
{
  gstate_->setStrokeAdjust(flag);
}

bool
PSViewGStateToken::
getStrokeAdjust()
{
  return gstate_->getStrokeAdjust();
}

void
PSViewGStateToken::
setDashPattern(double *dash_array, int num_dashes, double dash_offset)
{
  gstate_->setDashPattern(dash_array, num_dashes, dash_offset);
}

void
PSViewGStateToken::
getDashPattern(const double **dash_array, int *num_dashes, double *dash_offset)
{
  gstate_->getDashPattern(dash_array, num_dashes, dash_offset);
}

void
PSViewGStateToken::
setBlackGeneration(PSViewToken *token)
{
  gstate_->setBlackGeneration(token);
}

PSViewToken *
PSViewGStateToken::
getBlackGeneration()
{
  return gstate_->getBlackGeneration();
}

void
PSViewGStateToken::
setUnderColorRemoval(PSViewToken *token)
{
  gstate_->setUnderColorRemoval(token);
}

PSViewToken *
PSViewGStateToken::
getUnderColorRemoval()
{
  return gstate_->getUnderColorRemoval();
}

CMatrix2D *
PSViewGStateToken::
getDefaultMatrix()
{
  return gstate_->getGStateMgr()->getDefaultMatrix();
}

void
PSViewGStateToken::
setCTMMatrix(CMatrix2D *matrix)
{
  gstate_->setCTMMatrix(matrix);
}

CMatrix2D *
PSViewGStateToken::
getCTMMatrix()
{
  return gstate_->getCTMMatrix();
}

CMatrix2D *
PSViewGStateToken::
getInverseCTMMatrix()
{
  return gstate_->getInverseCTMMatrix();
}

void
PSViewGStateToken::
preMultiplyCTMMatrix(CMatrix2D *matrix)
{
  gstate_->preMultiplyCTMMatrix(matrix);
}

void
PSViewGStateToken::
postMultiplyCTMMatrix(CMatrix2D *matrix)
{
  gstate_->postMultiplyCTMMatrix(matrix);
}

void
PSViewGStateToken::
multiplyByCTMMatrix(double x1, double y1, double *x2, double *y2)
{
  gstate_->multiplyByCTMMatrix(x1, y1, x2, y2);
}

void
PSViewGStateToken::
multiplyByInverseCTMMatrix(double x1, double y1, double *x2, double *y2)
{
  gstate_->multiplyByInverseCTMMatrix(x1, y1, x2, y2);
}
##concat##CPSViewIntegerToken.cpp
#include <CPSViewI.h>

PSViewIntegerToken::
PSViewIntegerToken(CPSView *psview, PSVinteger value) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_INTEGER,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(value)
{
}

PSViewIntegerToken::
PSViewIntegerToken(const PSViewIntegerToken &integer_token) :
 PSViewToken(integer_token), value_(integer_token.value_)
{
}

PSViewIntegerToken::
~PSViewIntegerToken()
{
}

PSViewIntegerToken *
PSViewIntegerToken::
dup() const
{
  return new PSViewIntegerToken(*this);
}

int
PSViewIntegerToken::
compare(PSViewToken *token)
{
  if     (token->isType(type_)) {
    PSViewIntegerToken *integer_token = dynamic_cast<PSViewIntegerToken *>(token);

    return (value_ - integer_token->value_);
  }
  else if (token->isType(PSVIEW_TOKEN_TYPE_REAL)) {
    PSViewRealToken real_token1(psview_, value_);

    return real_token1.compare(token);
  }
  else
    return type_ - token->getType();
}

const PSViewName &
PSViewIntegerToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewIntegerToken::
executeToken()
{
  psview_->getOperandStack()->push(this);
}

void
PSViewIntegerToken::
print()
{
  CStrUtil::printf("%ld", value_);
}

string
PSViewIntegerToken::
toString()
{
  return CStrUtil::toString(value_);
}
##concat##CPSViewMarkToken.cpp
#include <CPSViewI.h>

PSViewMarkToken::
PSViewMarkToken(CPSView *psview) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_MARK,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE)
{
}

PSViewMarkToken::
~PSViewMarkToken()
{
}

PSViewMarkToken *
PSViewMarkToken::
dup() const
{
  return (PSViewMarkToken *) this;
}

int
PSViewMarkToken::
compare(PSViewToken *token)
{
  return type_ - token->getType();
}

void
PSViewMarkToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Mark Missing\n");
}

const PSViewName &
PSViewMarkToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewMarkToken::
print()
{
  CStrUtil::printf("-mark-");
}

string
PSViewMarkToken::
toString()
{
  return "--nostringval--";
}
##concat##CPSViewMemory.cpp
#include <CPSViewI.h>

const uint MEMORY_ID = 0xDEAFDEAD;

struct PSViewSaveMemory {
  PSViewMemory  *new_memory;
  PSViewMemory  *old_memory;
  char         **address;

  PSViewSaveMemory() :
   new_memory(NULL),
   old_memory(NULL),
   address   (NULL) {
  }
};

struct PSViewSaveData {
  int                      depth_;
  list<PSViewSaveMemory *> save_memory_list_;

  PSViewSaveData() :
   depth_           (0),
   save_memory_list_() {
  }
};

/*---- Data ----*/

PSViewMemoryMgr::
PSViewMemoryMgr(CPSView *psview) :
 psview_            (psview),
 memory_type_       (PSVIEW_MEMORY_TYPE_LOCAL),
 memory_depth_      (1),
 memory_used_       (0),
 save_data_         (NULL),
 global_memory_list_(),
 local_memory_list_ ()
{
  init();
}

PSViewMemoryMgr::
~PSViewMemoryMgr()
{
}

void
PSViewMemoryMgr::
init()
{
  list<PSViewMemory *>::iterator pmemory;

  for (pmemory = global_memory_list_.begin();
        pmemory != global_memory_list_.end(); ++pmemory)
    delete *pmemory;

  for (pmemory = local_memory_list_.begin();
        pmemory != local_memory_list_.end(); ++pmemory)
    delete *pmemory;

  global_memory_list_.clear();
  local_memory_list_ .clear();

  /*----*/

  memory_type_  = PSVIEW_MEMORY_TYPE_LOCAL;
  memory_depth_ = 1;
  memory_used_  = 0;

  /*----*/

  save();
}

void
PSViewMemoryMgr::
getStatus(int *depth, int *used, int *max)
{
  *depth = memory_depth_;
  *used  = memory_used_;
  *max   = -1;
}

PSViewToken *
PSViewMemoryMgr::
save()
{
  memory_depth_++;

  save_data_ = new PSViewSaveData;

  save_data_->depth_ = memory_depth_;

  PSViewToken *token = new PSViewSaveToken(getPSView(), save_data_);

  return token;
}

void
PSViewMemoryMgr::
restore(PSViewToken *token)
{
  PSViewSaveToken *save_token = (PSViewSaveToken *) token;

  save_data_ = (PSViewSaveData *) save_token->getValue();

  list<PSViewSaveMemory *>::iterator psave_memory;

  for (psave_memory = save_data_->save_memory_list_.begin();
        psave_memory != save_data_->save_memory_list_.end(); ++psave_memory)
    delete *psave_memory;

  memory_depth_ = save_data_->depth_ - 1;

  int num = getPSView()->getOperandStack()->size();

  for (int i = num; i >= 1; i--) {
    PSViewToken *token1 = getPSView()->getOperandStack()->peek(i);

    if (token1->getMemoryDepth() > memory_depth_) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_RESTORE);

      return;
    }
  }

  delete save_data_;
}

char *
PSViewMemoryMgr::
alloc(uint size)
{
  char *memory;

  if (getGlobal())
    memory = allocGlobal(size);
  else
    memory = allocLocal(size);

  return memory;
}

char *
PSViewMemoryMgr::
allocGlobal(uint size)
{
  PSViewMemory *memory = (PSViewMemory *)
    new char [sizeof(PSViewMemory) + size];

  if (memory == NULL) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  memory->id    = MEMORY_ID;
  memory->size  = size;
  memory->type  = PSVIEW_MEMORY_TYPE_GLOBAL;
  memory->ref   = 1;
  memory->depth = memory_depth_;

  global_memory_list_.push_back(memory);

  memory_used_ += size;

  return(((char *) memory) + sizeof(PSViewMemory));
}

char *
PSViewMemoryMgr::
allocLocal(uint size)
{
  PSViewMemory *memory = (PSViewMemory *)
    new char [sizeof(PSViewMemory) + size];

  if (memory == NULL) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  memory->id    = MEMORY_ID;
  memory->size  = size;
  memory->type  = PSVIEW_MEMORY_TYPE_LOCAL;
  memory->ref   = 1;
  memory->depth = memory_depth_;

  local_memory_list_.push_back(memory);

  memory_used_ += size;

  return (((char *) memory) + sizeof(PSViewMemory));
}

void
PSViewMemoryMgr::
change(char **address)
{
  PSViewMemory *memory = (PSViewMemory *) (*address - sizeof(PSViewMemory));

  if (memory->id != MEMORY_ID) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  if (memory->type == PSVIEW_MEMORY_TYPE_GLOBAL ||
      (int) memory->depth >= memory_depth_)
    return;

  PSViewSaveMemory *save_memory = new PSViewSaveMemory;

  if (save_memory == NULL) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  char *address1 = allocLocal(memory->size);

  memcpy(address1, *address, memory->size);

  save_memory->new_memory = (PSViewMemory *) (address1 - sizeof(PSViewMemory));
  save_memory->old_memory = memory;
  save_memory->address    = address;

  save_data_->save_memory_list_.push_back(save_memory);

  *address = address1;
}

void
PSViewMemoryMgr::
free(char *)
{
  return;
}

void
PSViewMemoryMgr::
free(PSViewMemory *memory)
{
  delete memory;
}

void
PSViewMemoryMgr::
free(PSViewSaveMemory *save_memory)
{
  delete [] save_memory->new_memory;

  *save_memory->address = ((char *) save_memory->old_memory) + sizeof(PSViewMemory);

  delete save_memory;
}

void
PSViewMemoryMgr::
setGlobal(bool flag)
{
  if (flag)
    memory_type_ = PSVIEW_MEMORY_TYPE_GLOBAL;
  else
    memory_type_ = PSVIEW_MEMORY_TYPE_LOCAL;
}

int
PSViewMemoryMgr::
getDepth(char *address)
{
  PSViewMemory *memory = (PSViewMemory *) (address - sizeof(PSViewMemory));

  if (memory->id != MEMORY_ID) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  return memory->depth;
}

bool
PSViewMemoryMgr::
getGlobal(char *address)
{
  PSViewMemory *memory = (PSViewMemory *) (address - sizeof(PSViewMemory));

  if (memory->id != MEMORY_ID) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  return (memory->type == PSVIEW_MEMORY_TYPE_GLOBAL);
}

bool
PSViewMemoryMgr::
getLocal(char *address)
{
  PSViewMemory *memory = (PSViewMemory *) (address - sizeof(PSViewMemory));

  if (memory->id != MEMORY_ID) {
    CStrUtil::eprintf("PSView: Fatal Memory Error\n");
    exit(1);
  }

  return (memory->type == PSVIEW_MEMORY_TYPE_LOCAL);
}

bool
PSViewMemoryMgr::
getGlobal()
{
  return (memory_type_ == PSVIEW_MEMORY_TYPE_GLOBAL);
}

bool
PSViewMemoryMgr::
getLocal()
{
  return (memory_type_ == PSVIEW_MEMORY_TYPE_LOCAL);
}

int
PSViewMemoryMgr::
getDepth()
{
  return memory_depth_;
}
##concat##CPSViewName.cpp
#include <CPSViewI.h>

PSViewNameMgr::
PSViewNameMgr(CPSView *psview) :
 psview_(psview),
 names_ ()
{
}

const PSViewName &
PSViewNameMgr::
getName(const string &str)
{
  if (names_.find(str) != names_.end())
    return *names_[str];

  PSViewName *name = new PSViewName(str);

  names_[str] = name;

  return *name;
}

PSViewName::
PSViewName(const string &str) :
 str_(str)
{
}

PSViewName::
~PSViewName()
{
  CTHROW("Illegal Name deletion");
}

int
PSViewName::
compare(const PSViewName &name) const
{
  if      (str_ == name.str_)
    return 0;
  else if (str_ >  name.str_)
    return 1;
  else
    return -1;
}
##concat##CPSViewNameToken.cpp
#include <CPSViewI.h>

PSViewNameToken::
PSViewNameToken(CPSView *psview, const PSViewName &value) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_NAME,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_EXECUTABLE,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(value)
{
}

PSViewNameToken::
PSViewNameToken(CPSView *psview, const string &str) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_NAME,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_EXECUTABLE,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(psview->getNameMgr()->getName(str))
{
}

PSViewNameToken::
PSViewNameToken(PSViewStringToken *token) :
 PSViewToken(token->getPSView(), PSVIEW_TOKEN_TYPE_NAME,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_EXECUTABLE,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(token->getPSView()->getNameMgr()->getName(token->toString()))
{
}

PSViewNameToken::
PSViewNameToken(const PSViewNameToken &name_token) :
 PSViewToken(name_token), value_(name_token.value_)
{
}

PSViewNameToken::
~PSViewNameToken()
{
}

PSViewNameToken *
PSViewNameToken::
dup() const
{
  return new PSViewNameToken(*this);
}

int
PSViewNameToken::
compare(PSViewToken *token)
{
  if      (token->isType(type_)) {
    PSViewNameToken *name_token = dynamic_cast<PSViewNameToken *>(token);

    return value_.compare(name_token->value_);
  }
  else if (token->isType(PSVIEW_TOKEN_TYPE_STRING)) {
    PSViewStringToken *string_token = dynamic_cast<PSViewStringToken *>(token);

    PSViewNameToken name_token1 = PSViewNameToken(psview_, string_token->toString());

    return name_token1.compare(this);
  }
  else
    return type_ - token->getType();
}

void
PSViewNameToken::
executeToken()
{
  PSViewToken *value = psview_->getDictionaryMgr()->lookup(value_);

  if (value == NULL) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

    return;
  }

  if (value->isExecutable())
    value->execute();
  else
    psview_->getOperandStack()->push(value);
}

const PSViewName &
PSViewNameToken::
getName()
{
  return value_;
}

void
PSViewNameToken::
print()
{
  if (! isExecutable())
    CStrUtil::printf("/");

  CStrUtil::printf("%s" , value_.getString().c_str());
}

string
PSViewNameToken::
toString()
{
  return value_.getString();
}

const string &
PSViewNameToken::
getString()
{
  return value_.getString();
}

int
PSViewNameToken::
getLength()
{
  return value_.getLength();
}
##concat##CPSViewNullToken.cpp
#include <CPSViewI.h>

PSViewNullToken::
PSViewNullToken(CPSView *psview) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_NULL,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE)
{
}

PSViewNullToken::
PSViewNullToken(const PSViewNullToken &null_token) :
 PSViewToken(null_token)
{
}

PSViewNullToken::
~PSViewNullToken()
{
}

PSViewNullToken *
PSViewNullToken::
dup() const
{
 return new PSViewNullToken(psview_);
}

int
PSViewNullToken::
compare(PSViewToken *token)
{
  return type_ - token->getType();
}

void
PSViewNullToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for NULL Missing\n");
}

const PSViewName &
PSViewNullToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewNullToken::
print()
{
  CStrUtil::printf("null");
}

string
PSViewNullToken::
toString()
{
  return "--nostringval--";
}
##concat##CPSViewOperator.cpp
#include <CPSViewI.h>
#include <COSEnv.h>
#include <climits>

const int MAX_ARRAY_DIMENSION      = 65535;
const int MAX_DICTIONARY_DIMENSION = 65535;

struct PSViewOperatorData {
  const char         *name;
  PSViewOperatorProc  proc;
};

static PSViewOperatorData
system_operators[] = {
  /*   0 */
  { "abs"                     , PSViewOperatorMgr::absOp                      },
  { "add"                     , PSViewOperatorMgr::addOp                      },
  { "aload"                   , PSViewOperatorMgr::aloadOp                    },
  { "anchorsearch"            , PSViewOperatorMgr::anchorSearchOp             },
  { "and"                     , PSViewOperatorMgr::andOp                      },
  /*   5 */
  { "arc"                     , PSViewOperatorMgr::arcOp                      },
  { "arcn"                    , PSViewOperatorMgr::arcNOp                     },
  { "arct"                    , PSViewOperatorMgr::arcTOp                     },
  { "arcto"                   , PSViewOperatorMgr::arcToOp                    },
  { "array"                   , PSViewOperatorMgr::arrayOp                    },
  /*  10 */
  { "ashow"                   , PSViewOperatorMgr::ashowOp                    },
  { "astore"                  , PSViewOperatorMgr::astoreOp                   },
  { "awidthshow"              , PSViewOperatorMgr::awidthShowOp               },
  { "begin"                   , PSViewOperatorMgr::beginOp                    },
  { "bind"                    , PSViewOperatorMgr::bindOp                     },
  /*  15 */
  { "bitshift"                , PSViewOperatorMgr::bitShiftOp                 },
  { "ceiling"                 , PSViewOperatorMgr::ceilingOp                  },
  { "charpath"                , PSViewOperatorMgr::charPathOp                 },
  { "clear"                   , PSViewOperatorMgr::clearOp                    },
  { "cleartomark"             , PSViewOperatorMgr::clearToMarkOp              },
  /*  20 */
  { "clip"                    , PSViewOperatorMgr::clipOp                     },
  { "clippath"                , PSViewOperatorMgr::clipPathOp                 },
  { "closepath"               , PSViewOperatorMgr::closePathOp                },
  { "concat"                  , PSViewOperatorMgr::concatOp                   },
  { "concatmatrix"            , PSViewOperatorMgr::concatMatrixOp             },
  /*  25 */
  { "copy"                    , PSViewOperatorMgr::copyOp                     },
  { "count"                   , PSViewOperatorMgr::countOp                    },
  { "counttomark"             , PSViewOperatorMgr::countToMarkOp              },
  { "currentcmykcolor"        , PSViewOperatorMgr::currentCMYKColorOp         },
  { "currentdash"             , PSViewOperatorMgr::currentDashOp              },
  /*  30 */
  { "currentdict"             , PSViewOperatorMgr::currentDictOp              },
  { "currentfile"             , PSViewOperatorMgr::currentFileOp              },
  { "currentfont"             , PSViewOperatorMgr::currentFontOp              },
  { "currentgray"             , PSViewOperatorMgr::currentGrayOp              },
  { "currentgstate"           , PSViewOperatorMgr::currentGStateOp            },
  /*  35 */
  { "currenthsbcolor"         , PSViewOperatorMgr::currentHSBColorOp          },
  { "currentlinecap"          , PSViewOperatorMgr::currentLineCapOp           },
  { "currentlinejoin"         , PSViewOperatorMgr::currentLineJoinOp          },
  { "currentlinewidth"        , PSViewOperatorMgr::currentLineWidthOp         },
  { "currentmatrix"           , PSViewOperatorMgr::currentMatrixOp            },
  /*  40 */
  { "currentpoint"            , PSViewOperatorMgr::currentPointOp             },
  { "currentrgbcolor"         , PSViewOperatorMgr::currentRGBColorOp          },
  { "currentshared"           , PSViewOperatorMgr::unimplementedOp            },
  { "curveto"                 , PSViewOperatorMgr::curveToOp                  },
  { "cvi"                     , PSViewOperatorMgr::cviOp                      },
  /*  45 */
  { "cvlit"                   , PSViewOperatorMgr::cvlitOp                    },
  { "cvn"                     , PSViewOperatorMgr::cvnOp                      },
  { "cvr"                     , PSViewOperatorMgr::cvrOp                      },
  { "cvrs"                    , PSViewOperatorMgr::cvrsOp                     },
  { "cvs"                     , PSViewOperatorMgr::cvsOp                      },
  /*  50 */
  { "cvx"                     , PSViewOperatorMgr::cvxOp                      },
  { "def"                     , PSViewOperatorMgr::defOp                      },
  { "defineusername"          , PSViewOperatorMgr::unimplementedOp            },
  { "dict"                    , PSViewOperatorMgr::dictOp                     },
  { "div"                     , PSViewOperatorMgr::divOp                      },
  /*  55 */
  { "dtransform"              , PSViewOperatorMgr::dtransformOp               },
  { "dup"                     , PSViewOperatorMgr::dupOp                      },
  { "end"                     , PSViewOperatorMgr::endOp                      },
  { "eoclip"                  , PSViewOperatorMgr::eoclipOp                   },
  { "eofill"                  , PSViewOperatorMgr::eofillOp                   },
  /*  60 */
  { "eoviewclip"              , PSViewOperatorMgr::unimplementedOp            },
  { "eq"                      , PSViewOperatorMgr::eqOp                       },
  { "exch"                    , PSViewOperatorMgr::exchOp                     },
  { "exec"                    , PSViewOperatorMgr::execOp                     },
  { "exit"                    , PSViewOperatorMgr::exitOp                     },
  /*  65 */
  { "file"                    , PSViewOperatorMgr::fileOp                     },
  { "fill"                    , PSViewOperatorMgr::fillOp                     },
  { "findfont"                , PSViewOperatorMgr::findFontOp                 },
  { "flattenpath"             , PSViewOperatorMgr::flattenPathOp              },
  { "floor"                   , PSViewOperatorMgr::floorOp                    },
  /*  70 */
  { "flush"                   , PSViewOperatorMgr::flushOp                    },
  { "flushfile"               , PSViewOperatorMgr::flushFileOp                },
  { "for"                     , PSViewOperatorMgr::forOp                      },
  { "forall"                  , PSViewOperatorMgr::forAllOp                   },
  { "ge"                      , PSViewOperatorMgr::geOp                       },
  /*  75 */
  { "get"                     , PSViewOperatorMgr::getOp                      },
  { "getinterval"             , PSViewOperatorMgr::getIntervalOp              },
  { "grestore"                , PSViewOperatorMgr::grestoreOp                 },
  { "gsave"                   , PSViewOperatorMgr::gsaveOp                    },
  { "gstate"                  , PSViewOperatorMgr::gstateOp                   },
  /*  80 */
  { "gt"                      , PSViewOperatorMgr::gtOp                       },
  { "identmatrix"             , PSViewOperatorMgr::identMatrixOp              },
  { "idiv"                    , PSViewOperatorMgr::idivOp                     },
  { "idtransform"             , PSViewOperatorMgr::idtransformOp              },
  { "if"                      , PSViewOperatorMgr::ifOp                       },
  /*  85 */
  { "ifelse"                  , PSViewOperatorMgr::ifelseOp                   },
  { "image"                   , PSViewOperatorMgr::imageOp                    },
  { "imagemask"               , PSViewOperatorMgr::imageMaskOp                },
  { "index"                   , PSViewOperatorMgr::indexOp                    },
  { "ineofill"                , PSViewOperatorMgr::unimplementedOp            },
  /*  90 */
  { "infill"                  , PSViewOperatorMgr::unimplementedOp            },
  { "initviewclip"            , PSViewOperatorMgr::unimplementedOp            },
  { "inueofill"               , PSViewOperatorMgr::unimplementedOp            },
  { "inufill"                 , PSViewOperatorMgr::unimplementedOp            },
  { "invertmatrix"            , PSViewOperatorMgr::invertMatrixOp             },
  /*  95 */
  { "itransform"              , PSViewOperatorMgr::itransformOp               },
  { "known"                   , PSViewOperatorMgr::knownOp                    },
  { "le"                      , PSViewOperatorMgr::leOp                       },
  { "length"                  , PSViewOperatorMgr::lengthOp                   },
  { "lineto"                  , PSViewOperatorMgr::lineToOp                   },
  /* 100 */
  { "load"                    , PSViewOperatorMgr::loadOp                     },
  { "loop"                    , PSViewOperatorMgr::loopOp                     },
  { "lt"                      , PSViewOperatorMgr::ltOp                       },
  { "makefont"                , PSViewOperatorMgr::makeFontOp                 },
  { "matrix"                  , PSViewOperatorMgr::matrixOp                   },
  /* 105 */
  { "maxlength"               , PSViewOperatorMgr::maxLengthOp                },
  { "mod"                     , PSViewOperatorMgr::modOp                      },
  { "moveto"                  , PSViewOperatorMgr::moveToOp                   },
  { "mul"                     , PSViewOperatorMgr::mulOp                      },
  { "ne"                      , PSViewOperatorMgr::neOp                       },
  /* 110 */
  { "neg"                     , PSViewOperatorMgr::negOp                      },
  { "newpath"                 , PSViewOperatorMgr::newPathOp                  },
  { "not"                     , PSViewOperatorMgr::notOp                      },
  { "null"                    , PSViewOperatorMgr::nullOp                     },
  { "or"                      , PSViewOperatorMgr::orOp                       },
  /* 115 */
  { "pathbbox"                , PSViewOperatorMgr::pathBBoxOp                 },
  { "pathforall"              , PSViewOperatorMgr::pathForAllOp               },
  { "pop"                     , PSViewOperatorMgr::popOp                      },
  { "print"                   , PSViewOperatorMgr::printOp                    },
  { "printobject"             , PSViewOperatorMgr::unimplementedOp            },
  /* 120 */
  { "put"                     , PSViewOperatorMgr::putOp                      },
  { "putinterval"             , PSViewOperatorMgr::putIntervalOp              },
  { "rcurveto"                , PSViewOperatorMgr::rcurveToOp                 },
  { "read"                    , PSViewOperatorMgr::readOp                     },
  { "readhexstring"           , PSViewOperatorMgr::readHexStringOp            },
  /* 125 */
  { "readline"                , PSViewOperatorMgr::readLineOp                 },
  { "readstring"              , PSViewOperatorMgr::readStringOp               },
  { "rectclip"                , PSViewOperatorMgr::rectClipOp                 },
  { "rectfill"                , PSViewOperatorMgr::rectFillOp                 },
  { "rectstroke"              , PSViewOperatorMgr::rectStrokeOp               },
  /* 130 */
  { "rectviewclip"            , PSViewOperatorMgr::unimplementedOp            },
  { "repeat"                  , PSViewOperatorMgr::repeatOp                   },
  { "restore"                 , PSViewOperatorMgr::restoreOp                  },
  { "rlineto"                 , PSViewOperatorMgr::rlineToOp                  },
  { "rmoveto"                 , PSViewOperatorMgr::rmoveToOp                  },
  /* 135 */
  { "roll"                    , PSViewOperatorMgr::rollOp                     },
  { "rotate"                  , PSViewOperatorMgr::rotateOp                   },
  { "round"                   , PSViewOperatorMgr::roundOp                    },
  { "save"                    , PSViewOperatorMgr::saveOp                     },
  { "scale"                   , PSViewOperatorMgr::scaleOp                    },
  /* 140 */
  { "scalefont"               , PSViewOperatorMgr::scaleFontOp                },
  { "search"                  , PSViewOperatorMgr::searchOp                   },
  { "selectfont"              , PSViewOperatorMgr::selectFontOp               },
  { "setbbox"                 , PSViewOperatorMgr::unimplementedOp            },
  { "setcachedevice"          , PSViewOperatorMgr::setCacheDeviceOp           },
  /* 145 */
  { "setcachedevice2"         , PSViewOperatorMgr::unimplementedOp            },
  { "setcharwidth"            , PSViewOperatorMgr::setCharWidthOp             },
  { "setcmykcolor"            , PSViewOperatorMgr::setCMYKColorOp             },
  { "setdash"                 , PSViewOperatorMgr::setDashOp                  },
  { "setfont"                 , PSViewOperatorMgr::setFontOp                  },
  /* 150 */
  { "setgray"                 , PSViewOperatorMgr::setGrayOp                  },
  { "setgstate"               , PSViewOperatorMgr::setGStateOp                },
  { "sethsbcolor"             , PSViewOperatorMgr::setHSBColorOp              },
  { "setlinecap"              , PSViewOperatorMgr::setLineCapOp               },
  { "setlinejoin"             , PSViewOperatorMgr::setLineJoinOp              },
  /* 155 */
  { "setlinewidth"            , PSViewOperatorMgr::setLineWidthOp             },
  { "setmatrix"               , PSViewOperatorMgr::setMatrixOp                },
  { "setrgbcolor"             , PSViewOperatorMgr::setRGBColorOp              },
  { "setshared"               , PSViewOperatorMgr::unimplementedOp            },
  { "shareddict"              , PSViewOperatorMgr::globalDictOp               },
  /* 160 */
  { "show"                    , PSViewOperatorMgr::showOp                     },
  { "showpage"                , PSViewOperatorMgr::showPageOp                 },
  { "stop"                    , PSViewOperatorMgr::stopOp                     },
  { "stopped"                 , PSViewOperatorMgr::stoppedOp                  },
  { "store"                   , PSViewOperatorMgr::storeOp                    },
  /* 165 */
  { "string"                  , PSViewOperatorMgr::stringOp                   },
  { "stringwidth"             , PSViewOperatorMgr::stringWidthOp              },
  { "stroke"                  , PSViewOperatorMgr::strokeOp                   },
  { "strokepath"              , PSViewOperatorMgr::strokePathOp               },
  { "sub"                     , PSViewOperatorMgr::subOp                      },
  /* 170 */
  { "systemdict"              , PSViewOperatorMgr::systemDictOp               },
  { "token"                   , PSViewOperatorMgr::tokenOp                    },
  { "transform"               , PSViewOperatorMgr::transformOp                },
  { "translate"               , PSViewOperatorMgr::translateOp                },
  { "truncate"                , PSViewOperatorMgr::truncateOp                 },
  /* 175 */
  { "type"                    , PSViewOperatorMgr::typeOp                     },
  { "uappend"                 , PSViewOperatorMgr::unimplementedOp            },
  { "ucache"                  , PSViewOperatorMgr::unimplementedOp            },
  { "ueofill"                 , PSViewOperatorMgr::unimplementedOp            },
  { "ufill"                   , PSViewOperatorMgr::unimplementedOp            },
  /* 180 */
  { "undef"                   , PSViewOperatorMgr::undefOp                    },
  { "upath"                   , PSViewOperatorMgr::unimplementedOp            },
  { "userdict"                , PSViewOperatorMgr::userDictOp                 },
  { "ustroke"                 , PSViewOperatorMgr::unimplementedOp            },
  { "viewclip"                , PSViewOperatorMgr::unimplementedOp            },
  /* 185 */
  { "viewclippath"            , PSViewOperatorMgr::unimplementedOp            },
  { "where"                   , PSViewOperatorMgr::whereOp                    },
  { "widthshow"               , PSViewOperatorMgr::widthShowOp                },
  { "write"                   , PSViewOperatorMgr::writeOp                    },
  { "writehexstring"          , PSViewOperatorMgr::writeHexStringOp           },
  /* 190 */
  { "writeobject"             , PSViewOperatorMgr::unimplementedOp            },
  { "writestring"             , PSViewOperatorMgr::writeStringOp              },
  { "wtranslation"            , PSViewOperatorMgr::unimplementedOp            },
  { "xor"                     , PSViewOperatorMgr::xorOp                      },
  { "xshow"                   , PSViewOperatorMgr::xshowOp                    },
  /* 195 */
  { "xyshow"                  , PSViewOperatorMgr::xyshowOp                   },
  { "yshow"                   , PSViewOperatorMgr::yshowOp                    },

  /* ... */

  /* 212 */
  { "execuserobject"          , PSViewOperatorMgr::execUserObjectOp           },
  { "currentcolor"            , PSViewOperatorMgr::currentColorOp             },
  { "currentcolorspace"       , PSViewOperatorMgr::currentColorSpaceOp        },
  /* 215 */
  { "currentglobal"           , PSViewOperatorMgr::currentGlobalOp            },
  { "execform"                , PSViewOperatorMgr::execFormOp                 },
  { "filter"                  , PSViewOperatorMgr::filterOp                   },
  { "findresource"            , PSViewOperatorMgr::findResourceOp             },
  { "globaldict"              , PSViewOperatorMgr::globalDictOp               },
  /* 220 */
  { "makepattern"             , PSViewOperatorMgr::makePatternOp              },
  { "setcolor"                , PSViewOperatorMgr::setColorOp                 },
  { "setcolorspace"           , PSViewOperatorMgr::setColorSpaceOp            },
  { "setglobal"               , PSViewOperatorMgr::setGlobalOp                },
  { "setpagedevice"           , PSViewOperatorMgr::unimplementedOp            },
  /* 225 */
  { "setpattern"              , PSViewOperatorMgr::setPatternOp               },
  { "="                       , PSViewOperatorMgr::print1Op                   },
  { "=="                      , PSViewOperatorMgr::print2Op                   },

  /* ... */

  /* 260 */
  { "["                       , PSViewOperatorMgr::startArrayOp               },
  { "]"                       , PSViewOperatorMgr::endArrayOp                 },
  { "atan"                    , PSViewOperatorMgr::atanOp                     },
  { "banddevice"              , PSViewOperatorMgr::unimplementedOp            },
  { "bytesavailable"          , PSViewOperatorMgr::bytesAvailableOp           },
  /* 265 */
  { "cachestatus"             , PSViewOperatorMgr::unimplementedOp            },
  { "closefile"               , PSViewOperatorMgr::closeFileOp                },
  { "colorimage"              , PSViewOperatorMgr::unimplementedOp            },
  { "condition"               , PSViewOperatorMgr::unimplementedOp            },
  { "copypage"                , PSViewOperatorMgr::unimplementedOp            },
  /* 270 */
  { "cos"                     , PSViewOperatorMgr::cosOp                      },
  { "countdictstack"          , PSViewOperatorMgr::countDictStackOp           },
  { "countexecstack"          , PSViewOperatorMgr::countExecStackOp           },
  { "cshow"                   , PSViewOperatorMgr::unimplementedOp            },
  { "currentblackgeneration"  , PSViewOperatorMgr::currentBlackGenerationOp   },
  /* 275 */
  { "currentcacheparams"      , PSViewOperatorMgr::unimplementedOp            },
  { "currentcolorscreen"      , PSViewOperatorMgr::unimplementedOp            },
  { "currentcolortransfer"    , PSViewOperatorMgr::unimplementedOp            },
  { "currentcontext"          , PSViewOperatorMgr::unimplementedOp            },
  { "currentflat"             , PSViewOperatorMgr::currentFlatOp              },
  /* 280 */
  { "currenthalftone"         , PSViewOperatorMgr::unimplementedOp            },
  { "currenthalftonephase"    , PSViewOperatorMgr::unimplementedOp            },
  { "currentmiterlimit"       , PSViewOperatorMgr::currentMitreLimitOp        },
  { "currentobjectformat"     , PSViewOperatorMgr::unimplementedOp            },
  { "currentpacking"          , PSViewOperatorMgr::currentPackingOp           },
  /* 285 */
  { "currentscreen"           , PSViewOperatorMgr::unimplementedOp            },
  { "currentstrokeadjust"     , PSViewOperatorMgr::currentStrokeAdjustOp      },
  { "currenttransfer"         , PSViewOperatorMgr::unimplementedOp            },
  { "currentundercolorremoval", PSViewOperatorMgr::currentUnderColorRemovalOp },
  { "defaultmatrix"           , PSViewOperatorMgr::defaultMatrixOp            },
  /* 290 */
  { "definefont"              , PSViewOperatorMgr::defineFontOp               },
  { "deletefile"              , PSViewOperatorMgr::deleteFileOp               },
  { "detach"                  , PSViewOperatorMgr::unimplementedOp            },
  { "deviceinfo"              , PSViewOperatorMgr::unimplementedOp            },
  { "dictstack"               , PSViewOperatorMgr::dictStackOp                },
  /* 295 */
  { "echo"                    , PSViewOperatorMgr::echoOp                     },
  { "erasepage"               , PSViewOperatorMgr::erasePageOp                },

  /* ... */

  /* 298 */
  { "execstack"               , PSViewOperatorMgr::execStackOp                },
  { "executeonly"             , PSViewOperatorMgr::executeOnlyOp              },
  /* 300 */
  { "exp"                     , PSViewOperatorMgr::expOp                      },
  { "false"                   , PSViewOperatorMgr::falseOp                    },
  { "filenameforall"          , PSViewOperatorMgr::filenameForAllOp           },
  { "fileposition"            , PSViewOperatorMgr::filePositionOp             },
  { "fork"                    , PSViewOperatorMgr::unimplementedOp            },
  /* 305 */
  { "framedevice"             , PSViewOperatorMgr::unimplementedOp            },
  { "grestoreall"             , PSViewOperatorMgr::grestoreAllOp              },
  { "handleerror"             , PSViewOperatorMgr::handleErrorOp              },
  { "initclip"                , PSViewOperatorMgr::initClipOp                 },
  { "initgraphics"            , PSViewOperatorMgr::initGraphicsOp             },
  /* 310 */
  { "initmatrix"              , PSViewOperatorMgr::initMatrixOp               },
  { "instroke"                , PSViewOperatorMgr::unimplementedOp            },
  { "inustroke"               , PSViewOperatorMgr::unimplementedOp            },
  { "join"                    , PSViewOperatorMgr::unimplementedOp            },
  { "kshow"                   , PSViewOperatorMgr::kshowOp                    },
  /* 315 */
  { "ln"                      , PSViewOperatorMgr::lnOp                       },
  { "lock"                    , PSViewOperatorMgr::unimplementedOp            },
  { "log"                     , PSViewOperatorMgr::logOp                      },
  { "mark"                    , PSViewOperatorMgr::markOp                     },
  { "monitor"                 , PSViewOperatorMgr::unimplementedOp            },
  /* 320 */
  { "noaccess"                , PSViewOperatorMgr::noAccessOp                 },
  { "notify"                  , PSViewOperatorMgr::unimplementedOp            },
  { "nulldevice"              , PSViewOperatorMgr::unimplementedOp            },
  { "packedarray"             , PSViewOperatorMgr::packedArrayOp              },
  { "quit"                    , PSViewOperatorMgr::quitOp                     },
  /* 325 */
  { "rand"                    , PSViewOperatorMgr::randOp                     },
  { "rcheck"                  , PSViewOperatorMgr::rcheckOp                   },
  { "readonly"                , PSViewOperatorMgr::readOnlyOp                 },
  { "realtime"                , PSViewOperatorMgr::realTimeOp                 },
  { "renamefile"              , PSViewOperatorMgr::renameFileOp               },
  /* 330 */
  { "renderbands"             , PSViewOperatorMgr::unimplementedOp            },
  { "resetfile"               , PSViewOperatorMgr::resetFileOp                },
  { "reversepath"             , PSViewOperatorMgr::reversePathOp              },
  { "rootfont"                , PSViewOperatorMgr::rootFontOp                 },
  { "rrand"                   , PSViewOperatorMgr::rrandOp                    },
  /* 335 */
  { "run"                     , PSViewOperatorMgr::runOp                      },
  { "scheck"                  , PSViewOperatorMgr::gcheckOp                   },
  { "setblackgeneration"      , PSViewOperatorMgr::setBlackGenerationOp       },
  { "setcachelimit"           , PSViewOperatorMgr::unimplementedOp            },
  { "setcacheparams"          , PSViewOperatorMgr::unimplementedOp            },
  /* 340 */
  { "setcolorscreen"          , PSViewOperatorMgr::unimplementedOp            },
  { "setcolortransfer"        , PSViewOperatorMgr::unimplementedOp            },
  { "setfileposition"         , PSViewOperatorMgr::setFilePositionOp          },
  { "setflat"                 , PSViewOperatorMgr::setFlatOp                  },
  { "sethalftone"             , PSViewOperatorMgr::unimplementedOp            },
  /* 345 */
  { "sethalftonephase"        , PSViewOperatorMgr::unimplementedOp            },
  { "setmiterlimit"           , PSViewOperatorMgr::setMitreLimitOp            },
  { "setobjectformat"         , PSViewOperatorMgr::unimplementedOp            },
  { "setpacking"              , PSViewOperatorMgr::setPackingOp               },
  { "setscreen"               , PSViewOperatorMgr::unimplementedOp            },
  /* 350 */
  { "setstrokeadjust"         , PSViewOperatorMgr::setStrokeAdjustOp          },
  { "settransfer"             , PSViewOperatorMgr::unimplementedOp            },
  { "setucacheparams"         , PSViewOperatorMgr::unimplementedOp            },
  { "setundercolorremoval"    , PSViewOperatorMgr::setUnderColorRemovalOp     },
  { "sin"                     , PSViewOperatorMgr::sinOp                      },
  /* 355 */
  { "sqrt"                    , PSViewOperatorMgr::sqrtOp                     },
  { "srand"                   , PSViewOperatorMgr::srandOp                    },
  { "stack"                   , PSViewOperatorMgr::stackOp                    },
  { "status"                  , PSViewOperatorMgr::statusOp                   },

  /* ... */

  /* 360 */
  { "true"                    , PSViewOperatorMgr::trueOp                     },
  { "ucachestatus"            , PSViewOperatorMgr::unimplementedOp            },
  { "undefinefont"            , PSViewOperatorMgr::undefineFontOp             },
  { "usertime"                , PSViewOperatorMgr::userTimeOp                 },
  { "ustrokepath"             , PSViewOperatorMgr::unimplementedOp            },
  /* 365 */
  { "version"                 , PSViewOperatorMgr::versionOp                  },
  { "vmreclaim"               , PSViewOperatorMgr::unimplementedOp            },
  { "vmstatus"                , PSViewOperatorMgr::vmStatusOp                 },
  { "wait"                    , PSViewOperatorMgr::unimplementedOp            },
  { "wcheck"                  , PSViewOperatorMgr::wcheckOp                   },
  /* 370 */
  { "xcheck"                  , PSViewOperatorMgr::xcheckOp                   },
  { "yield"                   , PSViewOperatorMgr::unimplementedOp            },
  { "defineuserobject"        , PSViewOperatorMgr::defineUserObjectOp         },
  { "undefineuserobject"      , PSViewOperatorMgr::undefineUserObjectOp       },

  /* ... */

  /* 375 */
  { "cleardictstack"          , PSViewOperatorMgr::clearDictStackOp           },

  /* ... */

  /* 428 */
  { "setvmthreshold"          , PSViewOperatorMgr::unimplementedOp            },
  { "<<"                      , PSViewOperatorMgr::startDictionaryOp          },
  /* 430 */
  { ">>"                      , PSViewOperatorMgr::endDictionaryOp            },
  { "currentcolorrendering"   , PSViewOperatorMgr::unimplementedOp            },
  { "currentdevparams"        , PSViewOperatorMgr::unimplementedOp            },
  { "currentoverprint"        , PSViewOperatorMgr::unimplementedOp            },
  { "currentpagedevice"       , PSViewOperatorMgr::unimplementedOp            },
  /* 435 */
  { "currentsystemparams"     , PSViewOperatorMgr::unimplementedOp            },
  { "currentuserparams"       , PSViewOperatorMgr::unimplementedOp            },
  { "defineresource"          , PSViewOperatorMgr::defineResourceOp           },
  { "findencoding"            , PSViewOperatorMgr::unimplementedOp            },
  { "gcheck"                  , PSViewOperatorMgr::gcheckOp                   },
  /* 440 */
  { "glyphshow"               , PSViewOperatorMgr::glyphShowOp                },
  { "languagelevel"           , PSViewOperatorMgr::languageLevelOp            },
  { "product"                 , PSViewOperatorMgr::productOp                  },
  { "pstack"                  , PSViewOperatorMgr::pstackOp                   },
  { "resourceforall"          , PSViewOperatorMgr::resourceForAllOp           },
  /* 445 */
  { "resourcestatus"          , PSViewOperatorMgr::unimplementedOp            },
  { "revision"                , PSViewOperatorMgr::revisionOp                 },
  { "serialnumber"            , PSViewOperatorMgr::serialNumberOp             },
  { "setcolorrendering"       , PSViewOperatorMgr::unimplementedOp            },
  { "setdevparams"            , PSViewOperatorMgr::unimplementedOp            },
  /* 450 */
  { "setoverprint"            , PSViewOperatorMgr::unimplementedOp            },
  { "setsystemparams"         , PSViewOperatorMgr::unimplementedOp            },
  { "setuserparams"           , PSViewOperatorMgr::unimplementedOp            },
  { "startjob"                , PSViewOperatorMgr::unimplementedOp            },
  { "undefineresource"        , PSViewOperatorMgr::unimplementedOp            },

  /* ... */

  /* 478 */
  { "eexec"                   , PSViewOperatorMgr::eexecOp                    },
  { "executive"               , PSViewOperatorMgr::executiveOp                },
  { "internaldict"            , PSViewOperatorMgr::internalDictOp             },
  { "prompt"                  , PSViewOperatorMgr::promptOp                   },
};

static uint num_system_operators = sizeof(system_operators)/sizeof(system_operators[0]);

static PSViewOperatorData
private_operators[] = {
  { "charpathfill"       , PSViewOperatorMgr::charPathFillOp        },
  { "charpathstroketrue" , PSViewOperatorMgr::charPathStrokeTrueOp  },
  { "charpathstrokefalse", PSViewOperatorMgr::charPathStrokeFalseOp },
};

static uint num_private_operators = sizeof(private_operators)/sizeof(private_operators[0]);

static char base_chars_[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

PSViewOperatorMgr::
PSViewOperatorMgr(CPSView *psview) :
 psview_               (psview),
 random_seed_          (0),
 system_operators_     (),
 private_operators_    (),
 num_private_operators_(0)
{
}

PSViewOperatorMgr::
~PSViewOperatorMgr()
{
  uint num_system_operators = system_operators_.size();

  for (uint i = 0; i < num_system_operators; ++i)
    delete system_operators_[i];

  uint num_private_operators = private_operators_.size();

  for (uint i = 0; i < num_private_operators; ++i)
    delete private_operators_[i];
}

void
PSViewOperatorMgr::
init()
{
  random_seed_ = 1;

  system_operators_.resize(num_system_operators);

  for (uint i = 0; i < num_system_operators; ++i)
    system_operators_[i] =
      new PSViewOperator(this, system_operators[i].name, system_operators[i].proc);

  private_operators_.resize(num_private_operators);

  for (uint i = 0; i < num_private_operators; ++i)
    private_operators_[i] =
      new PSViewOperator(this, private_operators[i].name, private_operators[i].proc);
}

PSViewOperator *
PSViewOperatorMgr::
lookup(const string &name)
{
  uint num_system_operators = system_operators_.size();

  for (uint i = 0; i < num_system_operators; ++i)
    if (system_operators_[i]->getName().getString() == name)
      return system_operators_[i];

  uint num_private_operators = private_operators_.size();

  for (uint i = 0; i < num_private_operators; ++i)
    if (private_operators_[i]->getName().getString() == name)
      return private_operators_[i];

  CTHROW("Unknown Operator Name");

  return NULL;
}

void
PSViewOperatorMgr::
addSystemOperators(PSViewDictionaryToken *dictionary)
{
  uint num_system_operators = system_operators_.size();

  for (uint i = 0; i < num_system_operators; ++i) {
    PSViewOperatorToken *value = new PSViewOperatorToken(psview_, system_operators_[i]);

    dictionary->addValue(system_operators_[i]->getName(), value);
  }
}

void
PSViewOperatorMgr::
startArrayOp(PSViewOperatorMgr *mgr)
{
  markOp(mgr);
}

void
PSViewOperatorMgr::
endArrayOp(PSViewOperatorMgr *mgr)
{
  mgr->endArrayOp();
}

void
PSViewOperatorMgr::
endArrayOp()
{
  int num_tokens = psview_->getOperandStack()->countToMark();

  if (num_tokens < 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNMATCHED_MARK);
    return;
  }

  PSViewArrayToken *array_token = new PSViewArrayToken(psview_, num_tokens);

  for (int i = num_tokens; i > 0; i--) {
    PSViewToken *sub_token = psview_->getOperandStack()->pop();

    array_token->setValue(i, sub_token);
  }

  psview_->getOperandStack()->pop();

  psview_->getOperandStack()->push(array_token);
}

void
PSViewOperatorMgr::
startDictionaryOp(PSViewOperatorMgr *mgr)
{
  markOp(mgr);
}

void
PSViewOperatorMgr::
endDictionaryOp(PSViewOperatorMgr *mgr)
{
  mgr->endDictionaryOp();
}

void
PSViewOperatorMgr::
endDictionaryOp()
{
  PSVinteger num_tokens = psview_->getOperandStack()->countToMark();

  if (num_tokens < 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNMATCHED_MARK);
    return;
  }

  if (num_tokens > 0) {
    if (num_tokens % 2 == 1) {
      psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
      return;
    }

    num_tokens /= 2;

    PSViewDictionaryToken *token =
      new PSViewDictionaryToken(psview_->getDictionaryMgr(), num_tokens);

    vector<PSViewToken *> keys;
    vector<PSViewToken *> values;

    keys  .resize(num_tokens);
    values.resize(num_tokens);

    for (int i = num_tokens - 1; i >= 0; i--) {
      values[i] = psview_->getOperandStack()->pop();
      keys  [i] = psview_->getOperandStack()->pop();
    }

    for (int i = 0; i < num_tokens; i++)
      token->addValue(keys[i], values[i]);

    psview_->getOperandStack()->pop();

    psview_->getOperandStack()->push(token);
  }
  else
    psview_->getOperandStack()->pop();
}

void
PSViewOperatorMgr::
print1Op(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  CStrUtil::printf("%s\n", token->toString().c_str());
}

void
PSViewOperatorMgr::
print2Op(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  token->print();

  CStrUtil::printf("\n");
}

void
PSViewOperatorMgr::
absOp(PSViewOperatorMgr *mgr)
{
  PSViewToken  *token1;

  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  if (token->isInteger()) {
    PSVinteger integer = token->getIntegerValue();

    if (integer != LONG_MIN)
      token1 = new PSViewIntegerToken(mgr->getPSView(), labs(integer));
    else
      token1 = new PSViewRealToken(mgr->getPSView(), fabs((double) integer));
  }
  else {
    PSVreal real = token->getRealValue();

    token1 = new PSViewRealToken(mgr->getPSView(), fabs(real));
  }

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
addOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewToken *token;

  if (token1->isInteger() && token2->isInteger()) {
    PSVinteger result = token1->getIntegerValue() + token2->getIntegerValue();

    token = new PSViewIntegerToken(mgr->getPSView(), result);
  }
  else {
    PSVreal result = token1->getRealValue() + token2->getRealValue();

    token = new PSViewRealToken(mgr->getPSView(), result);
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
aloadOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if ((! token->isArray() && ! token->isPackedArray()) || ! token->isLiteral()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  if (token->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token;

    PSVinteger num_tokens = array_token->getNumValues();

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      mgr->getPSView()->getOperandStack()->push(sub_token);
    }
  }
  else {
    PSViewPackedArrayToken *array_token = (PSViewPackedArrayToken *) token;

    PSVinteger num_tokens = array_token->getNumValues();

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      mgr->getPSView()->getOperandStack()->push(sub_token);
    }
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
anchorSearchOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger len1 = string_token1->getLength();
  PSVinteger len2 = string_token2->getLength();

  if (len1 >= len2 && string_token1->compareN(string_token2, len2) == 0) {
    PSViewToken *token3 = new PSViewStringToken(*string_token1, 1, len2);
    PSViewToken *token4 = new PSViewStringToken(*string_token1, len2 + 1);

    mgr->getPSView()->getOperandStack()->push(token4);
    mgr->getPSView()->getOperandStack()->push(token3);

    trueOp(mgr);
  }
  else {
    mgr->getPSView()->getOperandStack()->push(token1);

    falseOp(mgr);
  }
}

void
PSViewOperatorMgr::
andOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if ((! token1->isBoolean() && ! token1->isInteger()) ||
      (! token2->isBoolean() && ! token2->isInteger()) ||
      ! token1->isType(token2->getType())) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  if (token1->isBoolean()) {
    PSVboolean boolean1 = token1->getBooleanValue();
    PSVboolean boolean2 = token2->getBooleanValue();

    if (boolean1 & boolean2)
      trueOp(mgr);
    else
      falseOp(mgr);
  }
  else {
    PSVinteger integer1 = token1->getIntegerValue();
    PSVinteger integer2 = token2->getIntegerValue();

    PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), integer1 & integer2);

    mgr->getPSView()->getOperandStack()->push(token);
  }
}

void
PSViewOperatorMgr::
arcOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL || token5 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber() ||
      ! token5->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVreal x      = token1->getRealValue();
  PSVreal y      = token2->getRealValue();
  PSVreal r      = token3->getRealValue();
  PSVreal angle1 = token4->getRealValue();
  PSVreal angle2 = token5->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->arc(x, y, r,
                    CMathGen::DegToRad(angle1),
                    CMathGen::DegToRad(angle2));
}

void
PSViewOperatorMgr::
arcNOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL || token5 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber() ||
      ! token5->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

  PSVreal x      = token1->getRealValue();
  PSVreal y      = token2->getRealValue();
  PSVreal r      = token3->getRealValue();
  PSVreal angle1 = token4->getRealValue();
  PSVreal angle2 = token5->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->arcN(x, y, r,
                     CMathGen::DegToRad(angle1),
                     CMathGen::DegToRad(angle2));
}

void
PSViewOperatorMgr::
arcTOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL || token5 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber() ||
      ! token5->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVreal x1 = token1->getRealValue();
  PSVreal y1 = token2->getRealValue();
  PSVreal x2 = token3->getRealValue();
  PSVreal y2 = token4->getRealValue();
  PSVreal r  = token5->getRealValue();

  PSVreal xt1, yt1, xt2, yt2;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->arcTo(x1, y1, x2, y2, r, &xt1, &yt1, &xt2, &yt2);
}

void
PSViewOperatorMgr::
arcToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL || token5 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber() ||
      ! token5->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVreal x1 = token1->getRealValue();
  PSVreal y1 = token2->getRealValue();
  PSVreal x2 = token3->getRealValue();
  PSVreal y2 = token4->getRealValue();
  PSVreal r  = token5->getRealValue();

  PSVreal xt1, yt1, xt2, yt2;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->arcTo(x1, y1, x2, y2, r, &xt1, &yt1, &xt2, &yt2);

  token1 = new PSViewRealToken(mgr->getPSView(), xt1);
  token2 = new PSViewRealToken(mgr->getPSView(), yt1);
  token3 = new PSViewRealToken(mgr->getPSView(), xt2);
  token4 = new PSViewRealToken(mgr->getPSView(), yt2);

  mgr->getPSView()->getOperandStack()->push(token1);
  mgr->getPSView()->getOperandStack()->push(token2);
  mgr->getPSView()->getOperandStack()->push(token3);
  mgr->getPSView()->getOperandStack()->push(token4);
}

void
PSViewOperatorMgr::
arrayOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  if (! token1->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger dimension = token1->getIntegerValue();

  if (dimension < 0 || dimension > MAX_ARRAY_DIMENSION) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = new PSViewArrayToken(mgr->getPSView(), dimension);

  for (int i = 1; i <= dimension; i++) {
    PSViewNullToken *sub_token = new PSViewNullToken(mgr->getPSView());

    array_token->setValue(i, sub_token);
  }

  mgr->getPSView()->getOperandStack()->push(array_token);
}

void
PSViewOperatorMgr::
ashowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() || ! token3->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double ax = token1->getRealValue();
  double ay = token2->getRealValue();

  PSViewStringToken *string_token3 = (PSViewStringToken *) token3;

  string str = string_token3->toString();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->ashow(ax, ay, str);
}

void
PSViewOperatorMgr::
astoreOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (token == NULL || ! token->isArray() || ! token->isLiteral()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  PSVinteger num_tokens = array_token->getNumValues();

  for (int i = num_tokens; i >= 1; i--) {
    PSViewToken *sub_token = mgr->getPSView()->getOperandStack()->pop();

    if (sub_token == NULL)
      return;

    array_token->setValue(i, sub_token);
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
atanOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real1 = token1->getRealValue();
  PSVreal real2 = token2->getRealValue();

  if (real1 == 0.0 && real2 == 0.0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  PSVreal result;

  if (real2 == 0.0) {
    if (real1 > 0.0)
      result = 90.0;
    else
      result = 270.0;
  }
  else if (real2 < 0.0)
    result = CMathGen::RadToDeg(atan(real1/real2)) + 180.0;
  else if (real1 < 0.0)
    result = CMathGen::RadToDeg(atan(real1/real2)) + 360.0;
  else
    result = CMathGen::RadToDeg(atan(real1/real2));

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), result);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
awidthShowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token6 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL ||
      token5 == NULL || token6 == NULL)
    return;

  if (! token1->isNumber () || ! token2->isNumber() ||
      ! token3->isInteger() || ! token4->isNumber() ||
      ! token4->isNumber () || ! token6->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double cx = token1->getRealValue();
  double cy = token2->getRealValue();

  int c = token3->getIntegerValue();

  double ax = token4->getRealValue();
  double ay = token5->getRealValue();

  PSViewStringToken *string_token6 = (PSViewStringToken *) token6;

  string str = string_token6->toString();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->awidthShow(cx, cy, c, ax, ay, str);
}

void
PSViewOperatorMgr::
beginOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict = (PSViewDictionaryToken *) token;

  mgr->getPSView()->getDictionaryMgr()->beginDictionary(dict);
}

void
PSViewOperatorMgr::
bindOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  mgr->bind1(token);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
bind1(PSViewToken *token)
{
  if (token->isArray() && ! token->getWritable())
    return;

  PSViewArrayToken *array_token = (PSViewArrayToken *) token;

  PSVinteger num_tokens = array_token->getNumValues();

  for (int i = 1; i <= num_tokens; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (sub_token->isName() && sub_token->isExecutable()) {
      PSViewToken *token1 = getPSView()->getDictionaryMgr()->lookup(sub_token);

      if (token1 != NULL && token1->isOperator())
        array_token->setValue(i, token1);
    }
    else if (sub_token->isArray() && sub_token->isExecutable()) {
      bind1(sub_token);

      sub_token->setReadOnly();
    }
    else if (sub_token->isPackedArray() && sub_token->isExecutable())
      bind1(sub_token);
  }
}

void
PSViewOperatorMgr::
bitShiftOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isInteger() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger integer1 = token1->getIntegerValue();
  PSVinteger integer2 = token2->getIntegerValue();

  PSVinteger result;

  if (integer2 >= 0)
    result = integer1 <<  integer2;
  else
    result = integer1 >> -integer2;

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), result);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
bytesAvailableOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token;

  PSVinteger size = file_token->bytesAvailable();

  PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), size);

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
ceilingOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isReal()) {
    PSVreal real = token->getRealValue();

    PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), ceil(real));

    mgr->getPSView()->getOperandStack()->push(token1);
  }
  else {
    PSViewToken *token1 = token->dup();

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
charPathOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() || ! token2->isBoolean()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

  string str = string_token1->toString();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->charPath(str, token2->getBooleanValue());
}

void
PSViewOperatorMgr::
clearOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getOperandStack()->clear();
}

void
PSViewOperatorMgr::
clearDictStackOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getDictionaryMgr()->emptyDictionaryStack();
}

void
PSViewOperatorMgr::
clearToMarkOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  while (token != NULL && token != mgr->getPSView()->getMarkToken())
    token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNMATCHED_MARK);

    return;
  }
}

void
PSViewOperatorMgr::
clipOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->clip();
}

void
PSViewOperatorMgr::
clipPathOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->clipPath();
}

void
PSViewOperatorMgr::
closeFileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token;

  file_token->close();
}

void
PSViewOperatorMgr::
closePathOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->closePath();
}

void
PSViewOperatorMgr::
concatOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  CAutoPtr<CMatrix2D> matrix;

  matrix = token->getMatrix();

  if (matrix == NULL)
    return;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->postMultiplyCTMMatrix(matrix);
}

void
PSViewOperatorMgr::
concatMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();

  if (token3 == NULL)
    return;

  if (! token3->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token2 == NULL)
    return;

  CAutoPtr<CMatrix2D> matrix2;

  matrix2 = token2->getMatrix();

  if (matrix2 == NULL)
    return;

  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  CAutoPtr<CMatrix2D> matrix1;

  matrix1 = token1->getMatrix();

  if (matrix1 == NULL)
    return;

  CMatrix2D matrix = (*matrix2) * (*matrix1);

  token3->setMatrix(&matrix);

  mgr->getPSView()->getOperandStack()->push(token3);
}

void
PSViewOperatorMgr::
copyOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token2 == NULL)
    return;

  if (token2->isInteger()) {
    PSVinteger num_copies = token2->getIntegerValue();

    if (num_copies < 0) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    if (num_copies == 0)
      return;

    PSViewToken **tokens = new PSViewToken * [num_copies*2];

    for (int i = num_copies - 1; i >= 0; i--) {
      tokens[i] = mgr->getPSView()->getOperandStack()->pop();

      if (tokens[i] == NULL) {
        delete [] tokens;
        return;
      }

      tokens[i + num_copies] = tokens[i]->dup();
    }

    for (int i = 0; i < num_copies*2; i++)
      mgr->getPSView()->getOperandStack()->push(tokens[i]);
  }
  else if (token2->isArray() || token2->isDictionary() ||
           token2->isString() || token2->isGState()) {
    PSViewToken  *token1;

    token1 = mgr->getPSView()->getOperandStack()->pop();

    if (! token1->isType(token2->getType()) &&
        (! token1->isPackedArray() || ! token2->isArray())) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    if (token1->isArray()) {
      PSViewArrayToken *array_token1 = (PSViewArrayToken *) token1;
      PSViewArrayToken *array_token2 = (PSViewArrayToken *) token2;

      PSVinteger num_tokens1 = array_token1->getNumValues();
      PSVinteger num_tokens2 = array_token2->getNumValues();

      if (num_tokens1 > num_tokens2) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      for (int i = 1; i <= num_tokens1; i++) {
        PSViewToken *sub_value1 = array_token1->getValue(i);

        PSViewToken *sub_value2 = sub_value1->dup();

        array_token2->setValue(i, sub_value2);
      }

      array_token2->setBounds(1, num_tokens1);

      mgr->getPSView()->getOperandStack()->push(token2);
    }
    else if (token1->isDictionary()) {
      PSViewDictionaryToken *dictionary_token1 = (PSViewDictionaryToken *) token1;
      PSViewDictionaryToken *dictionary_token2 = (PSViewDictionaryToken *) token2;

      PSVinteger num_tokens1 = dictionary_token1->getNumValues();
      PSVinteger num_tokens2 = dictionary_token2->getMaxValues();

      if (num_tokens1 > num_tokens2) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      dictionary_token2->clear();

      for (int i = 1; i <= num_tokens1; i++) {
        PSViewKeyValue *keyval = dictionary_token1->getKeyValue(i);

        PSViewToken *new_key   = keyval->getKey  ()->dup();
        PSViewToken *new_value = keyval->getValue()->dup();

        dictionary_token2->addValue(new_key, new_value);
      }

      mgr->getPSView()->getOperandStack()->push(token2);
    }
    else if (token1->isString()) {
      PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
      PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

      PSVinteger length1 = string_token1->getLength();
      PSVinteger length2 = string_token1->getLength();

      if (length1 > length2) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      for (int i = 1; i <= length1; i++) {
        int c = string_token1->getChar(i);

        string_token2->setChar(i, c);
      }

      string_token2->setBounds(1, length1);

      mgr->getPSView()->getOperandStack()->push(token2);
    }
    else if (token1->isPackedArray()) {
      PSViewPackedArrayToken *array_token1 = (PSViewPackedArrayToken *) token1;
      PSViewArrayToken       *array_token2 = (PSViewArrayToken *) token2;

      PSVinteger num_tokens1 = array_token1->getNumValues();
      PSVinteger num_tokens2 = array_token2->getNumValues();

      if (num_tokens1 > num_tokens2) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      for (int i = 1; i <= num_tokens1; i++) {
        PSViewToken *sub_value1 = array_token1->getValue(i);
        PSViewToken *sub_value2 = sub_value1->dup();

        array_token2->setValue(i, sub_value2);
      }

      array_token2->setBounds(1, num_tokens1);

      mgr->getPSView()->getOperandStack()->push(token2);
    }
    else {
      CStrUtil::eprintf("PSView: Copy not Implemented for Token\n");

      return;
    }
  }
  else
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
}

void
PSViewOperatorMgr::
cosOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real = token->getRealValue();

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), cos(CMathGen::DegToRad(real)));

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
countOp(PSViewOperatorMgr *mgr)
{
  int num_stack = mgr->getPSView()->getOperandStack()->size();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), num_stack);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
countDictStackOp(PSViewOperatorMgr *mgr)
{
  int num_dictionaries = mgr->getPSView()->getDictionaryMgr()->getNumDictionaries();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), num_dictionaries);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
countExecStackOp(PSViewOperatorMgr *mgr)
{
  int num_stack = mgr->getPSView()->getExecutionStack()->size();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), num_stack);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
countToMarkOp(PSViewOperatorMgr *mgr)
{
  int count = mgr->getPSView()->getOperandStack()->countToMark();

  if (count < 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNMATCHED_MARK);

    return;
  }

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), count);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentBlackGenerationOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewToken *token = gstate_token->getBlackGeneration();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentCMYKColorOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token;

  CCMYK cmyk;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->getCMYKColor(cmyk);

  token = new PSViewRealToken(mgr->getPSView(), cmyk.getCyan());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), cmyk.getMagenta());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), cmyk.getYellow());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), cmyk.getBlack());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentColorOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  const PSViewName &color_space = gstate_token->getColorSpace();

  if      (color_space.compare(mgr->getPSView()->getGStateMgr()->getCMYKColorSpace()) == 0)
    currentCMYKColorOp(mgr);
  else if (color_space.compare(mgr->getPSView()->getGStateMgr()->getRGBColorSpace()) == 0)
    currentRGBColorOp(mgr);
  else if (color_space.compare(mgr->getPSView()->getGStateMgr()->getGrayColorSpace()) == 0)
    currentGrayOp(mgr);
}

void
PSViewOperatorMgr::
currentColorSpaceOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  bool pattern = gstate_token->getPatternColor();

  PSViewNameToken *color_space_token = gstate_token->getColorSpaceToken();

  if (pattern) {
    PSViewArrayToken *array_token = new PSViewArrayToken(mgr->getPSView(), 2);

    array_token->setValue(2, color_space_token);

    PSViewNameToken *sub_token = new PSViewNameToken(mgr->getPSView(), "Pattern");

    array_token->setValue(1, sub_token);

    mgr->getPSView()->getOperandStack()->push(array_token);
  }
  else {
    PSViewArrayToken *array_token = new PSViewArrayToken(mgr->getPSView(), 1);

    array_token->setValue(1, color_space_token);

    mgr->getPSView()->getOperandStack()->push(array_token);
  }
}

void
PSViewOperatorMgr::
currentDashOp(PSViewOperatorMgr *mgr)
{
  int           num_dashes;
  const double *dash_array;
  double        dash_offset;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->getDashPattern(&dash_array, &num_dashes, &dash_offset);

  PSViewArrayToken *array_token =
    new PSViewArrayToken(mgr->getPSView(), num_dashes);

  for (int i = 1; i <= num_dashes; i++) {
    PSViewRealToken *sub_token = new PSViewRealToken(mgr->getPSView(), dash_array[i - 1]);

    array_token->setValue(i, sub_token);
  }

  mgr->getPSView()->getOperandStack()->push(array_token);

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), dash_offset);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentDictOp(PSViewOperatorMgr *mgr)
{
  PSViewDictionaryToken *token = mgr->getPSView()->getDictionaryMgr()->getCurrentDictionary();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentFileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getCurrentFile();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentFlatOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  double flat = gstate_token->getFlat();

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), flat);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentFontOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewToken *token = gstate_token->getCurrentFont();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentGlobalOp(PSViewOperatorMgr *mgr)
{
  if (mgr->getPSView()->getMemoryMgr()->getGlobal())
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
currentGrayOp(PSViewOperatorMgr *mgr)
{
  double gray;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->getGray(&gray);

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), gray);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentGStateOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isGState()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  delete token;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewGStateToken *gstate_token1 = new PSViewGStateToken(*gstate_token);

  mgr->getPSView()->getOperandStack()->push(gstate_token1);
}

void
PSViewOperatorMgr::
currentHSBColorOp(PSViewOperatorMgr *mgr)
{
  CHSB hsb;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->getHSBColor(hsb);

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), hsb.getHue());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), hsb.getSaturation());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), hsb.getBrightness());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentLineCapOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  CLineCapType line_cap = gstate_token->getLineCap();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), line_cap - 1);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentLineJoinOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  CLineJoinType line_join = gstate_token->getLineJoin();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), line_join);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentLineWidthOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  double line_width = gstate_token->getLineWidth();

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), line_width);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  CMatrix2D *matrix = gstate_token->getCTMMatrix();

  token->setMatrix(matrix);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentMitreLimitOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  double mitre_limit = gstate_token->getMitreLimit();

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), mitre_limit);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentPackingOp(PSViewOperatorMgr *mgr)
{
  int packing = mgr->getPSView()->getTokenMgr()->getPacking();

  if (packing)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
currentPointOp(PSViewOperatorMgr *mgr)
{
  double x, y;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  bool flag = gstate_token->getCurrentPoint(&x, &y);

  if (! flag) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);

    return;
  }

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), x);
  PSViewRealToken *token2 = new PSViewRealToken(mgr->getPSView(), y);

  mgr->getPSView()->getOperandStack()->push(token1);
  mgr->getPSView()->getOperandStack()->push(token2);
}

void
PSViewOperatorMgr::
currentRGBColorOp(PSViewOperatorMgr *mgr)
{
  CRGBA rgba;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->getRGBColor(rgba);

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), rgba.getRed());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), rgba.getGreen());

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewRealToken(mgr->getPSView(), rgba.getBlue());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
currentStrokeAdjustOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  bool flag = gstate_token->getStrokeAdjust();

  if (flag)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
currentUnderColorRemovalOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewToken *token = gstate_token->getUnderColorRemoval();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
curveToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token6 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL ||
      token4 == NULL || token5 == NULL || token6 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token2->isNumber() || ! token3->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double x1 = token1->getRealValue();
  double y1 = token2->getRealValue();
  double x2 = token3->getRealValue();
  double y2 = token4->getRealValue();
  double x3 = token5->getRealValue();
  double y3 = token6->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->curveTo(x1, y1, x2, y2, x3, y3);
}

void
PSViewOperatorMgr::
cviOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (token->isInteger())
    mgr->getPSView()->getOperandStack()->push(token);
  else if (token->isReal()) {
    PSVreal real = token->getRealValue();

    PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), (long) real);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
  else if (token->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) token;

    string str = string_token->toString();

    PSVinteger pos = 0;

    PSViewToken *token1 = mgr->readStringFileToken(str, &pos);

    if (token1 == NULL || ! token1->isNumber()) {
      mgr->getPSView()->getErrorMgr()->
        raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

      return;
    }

    PSVreal real = token1->getRealValue();

    PSViewIntegerToken *token2 = new PSViewIntegerToken(mgr->getPSView(), (long) real);

    mgr->getPSView()->getOperandStack()->push(token2);
  }
  else
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
}

void
PSViewOperatorMgr::
cvlitOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  token->setLiteral();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
cvnOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token = (PSViewStringToken *) token;

  string str = string_token->toString();

  PSViewNameToken *token1 = new PSViewNameToken(mgr->getPSView(), str);

  if (token->isLiteral())
    token1->setLiteral();
  else
    token1->setExecutable();

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
cvrOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (token->isReal())
    mgr->getPSView()->getOperandStack()->push(token);
  else if (token->isInteger()) {
    PSVinteger integer = token->getIntegerValue();

    PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), (double) integer);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
  else if (token->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) token;

    string str = string_token->toString();

    PSVinteger pos = 0;

    PSViewToken *token1 = mgr->readStringFileToken(str, &pos);

    if (token1 == NULL || ! token1->isNumber()) {
      mgr->getPSView()->getErrorMgr()->
        raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

      return;
    }

    PSVreal real = token1->getRealValue();

    PSViewRealToken *token2 = new PSViewRealToken(mgr->getPSView(), real);

    mgr->getPSView()->getOperandStack()->push(token2);
  }
  else
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
}

void
PSViewOperatorMgr::
cvrsOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (! token1->isNumber() || ! token2->isInteger() || ! token3->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  int base = token2->getIntegerValue();

  if (base < 1 || base > 36) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  if (base == 10) {
    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token3);

    cvsOp(mgr);

    return;
  }

  PSViewStringToken *string_token3 = (PSViewStringToken *) token3;

  size_t length = string_token3->getLength();

  string str;

  uint num = (uint) token1->getRealValue();

  while (num > (uint) base) {
    uint num1 = num/base;
    uint num2 = num - num1*base;

    if (str.size() > length) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    str = base_chars_[num2] + str;

    num = num1;
  }

  if (str.size() > length) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  str = base_chars_[num] + str;

  string_token3->setChars(str, 1);

  PSViewToken *token = string_token3->subString(1, str.size());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
cvsOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger length = string_token2->getLength();

  string str = token1->toString();

  if (str.size() > (uint) length) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  string_token2->setChars(str, 1);

  PSViewToken *token = string_token2->subString(1, str.size());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
cvxOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  token->setExecutable();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
defOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  mgr->getPSView()->getDictionaryMgr()->addToCurrent(token1, token2);
}

void
PSViewOperatorMgr::
defaultMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  CMatrix2D *matrix = gstate_token->getDefaultMatrix();

  token->setMatrix(matrix);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
defineFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token2->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dictionary = (PSViewDictionaryToken *) token2;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->defineFont(token1, dictionary);
}

void
PSViewOperatorMgr::
defineResourceOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token3->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewNameToken *name_token = (PSViewNameToken *) token3;

  const PSViewName &name = name_token->getValue();

  if (! mgr->getPSView()->getResourceMgr()->checkInstance(token2, name))
    return;

  mgr->getPSView()->getResourceMgr()->define(token1, token2, name);
}

void
PSViewOperatorMgr::
defineUserObjectOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger ind = token1->getIntegerValue();

  if (ind < 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict = mgr->getPSView()->getDictionaryMgr()->getUserDictionary();

  PSViewNameToken *key = new PSViewNameToken(mgr->getPSView(), "UserObjects");

  PSViewToken *user_objects = dict->getValue(key);

  if (user_objects != NULL && ! user_objects->isArray()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) user_objects;

  PSVinteger len = 0;

  if (user_objects != NULL)
    len = array_token->getNumValues();

  if (ind >= len) {
    PSViewArrayToken *user_objects1 = new PSViewArrayToken(mgr->getPSView(), ind + 10);

    if (user_objects1 == NULL) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_VM_ERROR);

      return;
    }

    for (int i = 1; i <= len; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      user_objects1->setValue(i, sub_token);
    }

    delete user_objects;

    user_objects = user_objects1;

    array_token = (PSViewArrayToken *) user_objects;

    dict->addValue(key, user_objects);
  }
  else
    delete key;

  array_token->setValue(ind + 1, token2);
}

void
PSViewOperatorMgr::
deleteFileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token = (PSViewStringToken *) token;

  string filename = string_token->toString();

  remove(filename.c_str());
}

void
PSViewOperatorMgr::
dictOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  if (! token1->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger max_entries = token1->getIntegerValue();

  if (max_entries < 0 || max_entries > MAX_DICTIONARY_DIMENSION) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewDictionaryToken *token =
    new PSViewDictionaryToken(mgr->getPSView()->getDictionaryMgr(), max_entries);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
dictStackOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  if (! token1->isArray()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewArrayToken *array_token1 = (PSViewArrayToken *) token1;

  PSVinteger array_size = array_token1->getNumValues();

  int num_dictionaries = mgr->getPSView()->getDictionaryMgr()->getNumDictionaries();

  if (array_size < num_dictionaries) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = new PSViewArrayToken(mgr->getPSView(), num_dictionaries);

  for (int i = 1; i <= num_dictionaries; i++) {
    PSViewToken *sub_token = mgr->getPSView()->getDictionaryMgr()->getDictionary(i);

    array_token->setValue(i, sub_token);
  }

  mgr->getPSView()->getOperandStack()->push(array_token);
}

void
PSViewOperatorMgr::
divOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real1 = token1->getRealValue();
  PSVreal real2 = token2->getRealValue();

  if (real2 == 0.0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), real1/real2);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
dtransformOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal x = token1->getRealValue();
    PSVreal y = token2->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    CMatrix2D *matrix = gstate_token->getCTMMatrix();

    PSVreal x1, y1, x2, y2;

    matrix->multiplyPoint(0.0, 0.0, &x1, &y1);
    matrix->multiplyPoint(  x,   y, &x2, &y2);

    token1 = new PSViewRealToken(mgr->getPSView(), x2 - x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y2 - y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
  else {
    CAutoPtr<CMatrix2D> matrix;

    matrix = token2->getMatrix();

    if (matrix == NULL)
      return;

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x = token0->getRealValue();
    PSVreal y = token1->getRealValue();

    PSVreal x1, y1, x2, y2;

    matrix->multiplyPoint(0.0, 0.0, &x1, &y1);
    matrix->multiplyPoint(  x,   y, &x2, &y2);

    token1 = new PSViewRealToken(mgr->getPSView(), x2 - x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y2 - y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
}

void
PSViewOperatorMgr::
dupOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSViewToken *token1 = token->dup();

  mgr->getPSView()->getOperandStack()->push(token);
  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
echoOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isBoolean()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

/*
  PSVboolean boolean = token->getBooleanValue();

  PSViewSetEcho(boolean);
*/
}

void
PSViewOperatorMgr::
endOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getDictionaryMgr()->endDictionary();
}

void
PSViewOperatorMgr::
eexecOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString() && ! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token;

  if (token->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) token;

    string str = string_token->toString();

    file_token = new PSViewStringFileToken(mgr->getPSView(), str);
  }
  else
    file_token = (PSViewFileToken *) token;

  PSViewFilterFileToken *filter_token = new PSViewFilterFileToken(file_token, "EExecDecode");

  mgr->getPSView()->setCurrentFile(filter_token);

  PSViewDictionaryToken *dict = mgr->getPSView()->getDictionaryMgr()->getSystemDictionary();

  mgr->getPSView()->getDictionaryMgr()->beginDictionary(dict);

  mgr->getPSView()->executeCurrentFile();

  mgr->getPSView()->closeCurrentFile();

  mgr->getPSView()->getDictionaryMgr()->endDictionary();
}

void
PSViewOperatorMgr::
eoclipOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->eoclip();
}

void
PSViewOperatorMgr::
eofillOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->eofill();
}

void
PSViewOperatorMgr::
eqOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (token1->compare(token2) == 0)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
erasePageOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->erasePage();
}

void
PSViewOperatorMgr::
exchOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getOperandStack()->exch();
}

void
PSViewOperatorMgr::
execOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  token->execute();
}

void
PSViewOperatorMgr::
execFormOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict = (PSViewDictionaryToken *) token;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->execForm(dict);
}

void
PSViewOperatorMgr::
execStackOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  if (! token1->isArray()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewArrayToken *array_token1 = (PSViewArrayToken *) token1;

  PSVinteger array_size = array_token1->getNumValues();

  PSVinteger num_stack = mgr->getPSView()->getExecutionStack()->size();

  if (array_size < num_stack) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = new PSViewArrayToken(mgr->getPSView(), num_stack);

  for (int i = 1; i <= num_stack; i++) {
    PSViewToken *sub_token = mgr->getPSView()->getExecutionStack()->peek(i);

    array_token->setValue(i, sub_token);
  }

  mgr->getPSView()->getOperandStack()->push(array_token);
}

void
PSViewOperatorMgr::
execUserObjectOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger ind = token->getIntegerValue();

  if (ind < 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict = mgr->getPSView()->getDictionaryMgr()->getUserDictionary();

  PSViewNameToken *key = new PSViewNameToken(mgr->getPSView(), "UserObjects");

  PSViewToken *user_objects = dict->getValue(key);

  if (user_objects == NULL || ! user_objects->isArray()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) user_objects;

  PSVinteger len = array_token->getNumValues();

  if (ind >= len) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewToken *sub_token = array_token->getValue(ind + 1);

  sub_token->execute();

  delete key;
}

void
PSViewOperatorMgr::
executeOnlyOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isArray() && ! token->isPackedArray() &&
      ! token->isFile () && ! token->isString     ()){
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  token->setExecuteOnly();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
executiveOp(PSViewOperatorMgr *mgr)
{
  CStrUtil::printf("%s\n", "PSView Executive");
  CStrUtil::printf("\n");

  while (true) {
    PSViewNameToken *key = new PSViewNameToken(mgr->getPSView(), "prompt");

    PSViewToken *token = mgr->getPSView()->getDictionaryMgr()->lookup(key);

    token->execute();

    if (mgr->getPSView()->getErrorMgr()->getError()) {
      mgr->getPSView()->getErrorMgr()->setError(false);
      break;
    }

    string line;

    if (! mgr->getPSView()->getLine(line))
      break;

    PSViewStringFileToken *file_token = new PSViewStringFileToken(mgr->getPSView(), line);

    PSViewToken *token1 = file_token->readToken();

    while (token1 != NULL) {
      if (token1->isProcedure())
        mgr->getPSView()->getOperandStack()->push(token1);
      else
        token1->execute();

      if (mgr->getPSView()->getErrorMgr()->getError()) {
        mgr->getPSView()->getErrorMgr()->setError(false);
        break;
      }

      token1 = file_token->readToken();
    }

    file_token->close();
  }
}

void
PSViewOperatorMgr::
exitOp(PSViewOperatorMgr *mgr)
{
  PSViewOperatorToken *token = new PSViewOperatorToken(mgr->getPSView(), "exit");

  mgr->getPSView()->getExecutionStack()->push(token);

  mgr->getPSView()->setExitFlag(true);
}

void
PSViewOperatorMgr::
expOp(PSViewOperatorMgr *mgr)
{
  PSViewToken  *token;

  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal base     = token1->getRealValue();
  PSVreal exponent = token2->getRealValue();

  bool integer_exponent = false;

  if (token2->isInteger())
    integer_exponent = true;
  else {
    if (exponent == (double)((long) exponent))
      integer_exponent = true;
  }

  if (base == 0.0 && exponent <= 0.0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  if (base < 0.0 && ! integer_exponent) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  token = new PSViewRealToken(mgr->getPSView(), pow(base, exponent));

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
falseOp(PSViewOperatorMgr *mgr)
{
  PSViewBooleanToken *token = new PSViewBooleanToken(mgr->getPSView(), false);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
fileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL && token2 == NULL)
    return;

  if (! token1->isString() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  string filename = string_token1->toString();
  string access   = string_token2->toString();

  PSViewTextFileToken *token = new PSViewTextFileToken(mgr->getPSView(), filename, access);

  if (token == NULL) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_FILENAME);

    return;
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
fillOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->fill();
}

void
PSViewOperatorMgr::
filterOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (! token1->isFile() || ! token2->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token1;
  PSViewNameToken *name_token = (PSViewNameToken *) token2;

  const PSViewName &name = name_token->getValue();

  PSViewFilterFileToken *token = new PSViewFilterFileToken(file_token, name);

  if (token == NULL) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);
    return;
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
filenameForAllOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (! token1->isString() || ! token2->isProcedure() || ! token3->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
  PSViewStringToken *string_token3 = (PSViewStringToken *) token3;

  string templ   = string_token1->toString();
  string scratch = string_token3->toString();

  size_t scratch_len = scratch.size();

  void   *dir;
  string  prefix;

  if (templ.find("%font%") == 0) {
    string font_dir = COSEnv::getenv("PSVIEW_FONT_DIR");

    if (font_dir != "")
      font_dir = mgr->getPSView()->getGStateMgr()->getFontDir();

    dir = COSFile::openDir(font_dir);

    templ = templ.substr(6);

    prefix = "%font%";
  }
  else
    dir = COSFile::openDir(".");

  CGlob pattern(templ);

  string filename;

  while (COSFile::readDir(dir, filename)) {
    if (filename == "." || filename == "..")
      continue;

    if (! pattern.compare(filename))
      continue;

    size_t len1 = prefix.size();
    size_t len2 = filename.size();

    if (len1 + len2 > scratch_len) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      break;
    }

    size_t j = 0;

    for (size_t i = 0; i < len1; i++)
      scratch[j++] = prefix[i];

    for (size_t i = 0; i < len2; i++)
      scratch[j++] = filename[i];

    string_token3->setChars(scratch, 1);

    PSViewStringToken *string_token = new PSViewStringToken(*string_token3, 1, len1 + len2);

    mgr->getPSView()->getOperandStack()->push(string_token);

    token2->execute();
  }

  COSFile::closeDir(dir);
}

void
PSViewOperatorMgr::
filePositionOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token;

  uint pos;

  if (file_token->getPosition(&pos)) {
    PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), pos);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
findFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewToken *font = gstate_token->findFont(token);

  mgr->getPSView()->getOperandStack()->push(font);
}

void
PSViewOperatorMgr::
findResourceOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token2->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewNameToken *name_token = (PSViewNameToken *) token2;

  const PSViewName &name = name_token->getValue();

  PSViewToken *token = mgr->getPSView()->getResourceMgr()->findInstance(token1, name);

  if (token != NULL)
    mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
flattenPathOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->flattenPath();
}

void
PSViewOperatorMgr::
floorOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isReal()) {
    PSVreal real = token->getRealValue();

    PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), floor(real));

    mgr->getPSView()->getOperandStack()->push(token1);
  }
  else {
    PSViewToken *token1 = token->dup();

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
flushOp(PSViewOperatorMgr *)
{
  fflush(stdout);
}

void
PSViewOperatorMgr::
flushFileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token;

  file_token->flush();
}

void
PSViewOperatorMgr::
forOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  if (token1->isReal() || token2->isReal() || token3->isReal()) {
    PSVreal initial   = token1->getRealValue();
    PSVreal increment = token2->getRealValue();
    PSVreal limit     = token3->getRealValue();

    if (increment >= 0) {
      for (PSVreal i = initial; i <= limit; i += increment) {
        PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), i);

        mgr->getPSView()->getOperandStack()->push(token);

        token4->execute();

        if (mgr->getPSView()->getExitFlag()) {
          mgr->getPSView()->getExecutionStack()->popToExit();
          break;
        }
      }
    }
    else {
      for (PSVreal i = initial; i >= limit; i += increment) {
        PSViewRealToken *token = new PSViewRealToken(mgr->getPSView(), i);

        mgr->getPSView()->getOperandStack()->push(token);

        token4->execute();

        if (mgr->getPSView()->getExitFlag()) {
          mgr->getPSView()->getExecutionStack()->popToExit();
          break;
        }
      }
    }
  }
  else {
    PSVinteger initial   = token1->getIntegerValue();
    PSVinteger increment = token2->getIntegerValue();
    PSVinteger limit     = token3->getIntegerValue();

    if (increment >= 0) {
      for (PSVinteger i = initial; i <= limit; i += increment) {
        PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), i);

        mgr->getPSView()->getOperandStack()->push(token);

        token4->execute();

        if (mgr->getPSView()->getExitFlag()) {
          mgr->getPSView()->getExecutionStack()->popToExit();
          break;
        }
      }
    }
    else {
      for (PSVinteger i = initial; i >= limit; i += increment) {
        PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), i);

        mgr->getPSView()->getOperandStack()->push(token);

        token4->execute();

        if (mgr->getPSView()->getExitFlag()) {
          mgr->getPSView()->getExecutionStack()->popToExit();
          break;
        }
      }
    }
  }
}

void
PSViewOperatorMgr::
forAllOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token2->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token1->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token1;

    PSVinteger num_tokens = array_token->getNumValues();

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_value = array_token->getValue(i);

      mgr->getPSView()->getOperandStack()->push(sub_value);

      token2->execute();

      if (mgr->getPSView()->getExitFlag()) {
        mgr->getPSView()->getExecutionStack()->popToExit();
        break;
      }
    }
  }
  else if (token1->isPackedArray()) {
    PSViewPackedArrayToken *array_token = (PSViewPackedArrayToken *) token1;

    PSVinteger num_tokens = array_token->getNumValues();

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_value = array_token->getValue(i);

      mgr->getPSView()->getOperandStack()->push(sub_value);

      token2->execute();

      if (mgr->getPSView()->getExitFlag()) {
        mgr->getPSView()->getExecutionStack()->popToExit();
        break;
      }
    }
  }
  else if (token1->isString()) {
    PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

    PSVinteger num_tokens = string_token1->getLength();

    for (int i = 1; i <= num_tokens; i++) {
      PSVchar c = string_token1->getChar(i);

      PSViewIntegerToken *sub_value = new PSViewIntegerToken(mgr->getPSView(), c & 0xFF);

      mgr->getPSView()->getOperandStack()->push(sub_value);

      token2->execute();

      if (mgr->getPSView()->getExitFlag()) {
        mgr->getPSView()->getExecutionStack()->popToExit();
        break;
      }
    }
  }
  else if (token1->isDictionary()) {
    PSViewDictionaryToken *dictionary_token1 = (PSViewDictionaryToken *) token1;

    PSVinteger num_tokens = dictionary_token1->getNumValues();

    for (int i = 1; i <= num_tokens; i++) {
      PSViewKeyValue *keyval = dictionary_token1->getKeyValue(i);

      mgr->getPSView()->getOperandStack()->push(keyval->getKey()  );
      mgr->getPSView()->getOperandStack()->push(keyval->getValue());

      token2->execute();

      if (mgr->getPSView()->getExitFlag()) {
        mgr->getPSView()->getExecutionStack()->popToExit();
        break;
      }
    }
  }
  else {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }
}

void
PSViewOperatorMgr::
gcheckOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isComposite() || token->getGlobal())
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
geOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  PSVinteger flag = token1->compare(token2);

  if (flag >= 0)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
getOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (token1->isArray() || token1->isPackedArray() || token1->isString()) {
    if (! token1->getReadable()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);

      return;
    }

    if (! token2->isInteger()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVinteger ind = token2->getIntegerValue();

    PSViewToken *sub_token;

    if (token1->isArray()) {
      PSViewArrayToken *array_token = (PSViewArrayToken *) token1;

      PSVinteger num_tokens = array_token->getNumValues();

      if (ind < 0 || ind >= num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      sub_token = array_token->getValue(ind + 1);
    }
    else if (token1->isPackedArray()) {
      PSViewPackedArrayToken *array_token = (PSViewPackedArrayToken *) token1;

      PSVinteger num_tokens = array_token->getNumValues();

      if (ind < 0 || ind >= num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      sub_token = array_token->getValue(ind + 1);
    }
    else {
      PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

      PSVinteger num_tokens = string_token1->getLength();

      if (ind < 0 || ind >= num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      int c = string_token1->getChar(ind + 1);

      sub_token = new PSViewIntegerToken(mgr->getPSView(), c);
    }

    mgr->getPSView()->getOperandStack()->push(sub_token);
  }
  else if (token1->isDictionary()) {
    PSViewDictionaryToken *dictionary_token1 = (PSViewDictionaryToken *) token1;

    PSViewToken *sub_token = dictionary_token1->getValue(token2);

    if (sub_token == NULL) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

      return;
    }

    mgr->getPSView()->getOperandStack()->push(sub_token);
  }
  else {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }
}

void
PSViewOperatorMgr::
getIntervalOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token1->isArray() && ! token1->isPackedArray() &&
      ! token1->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (! token2->isInteger() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger ind   = token2->getIntegerValue();
  PSVinteger count = token3->getIntegerValue();

  if (token1->isArray()) {
    PSViewArrayToken *array_token1 = (PSViewArrayToken *) token1;

    PSVinteger num_tokens = array_token1->getNumValues();

    if (ind < 0 || count < 0 || ind + count > num_tokens) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    PSViewArrayToken *array_token = new PSViewArrayToken(mgr->getPSView(), count);

    for (int i = 1; i <= count; i++) {
      PSViewToken *sub_token = array_token1->getValue(ind + i);

      array_token->setValue(i, sub_token);
    }

    mgr->getPSView()->getOperandStack()->push(array_token);
  }
  else if (token1->isPackedArray()) {
    PSViewPackedArrayToken *array_token1 = (PSViewPackedArrayToken *) token1;

    PSVinteger num_tokens = array_token1->getNumValues();

    if (ind < 0 || count < 0 || ind + count > num_tokens) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    PSViewPackedArrayToken *array_token = new PSViewPackedArrayToken(mgr->getPSView(), count);

    for (int i = 1; i <= count; i++) {
      PSViewToken *sub_token = array_token1->getValue(ind + i);

      array_token->setValue(i, sub_token);
    }

    mgr->getPSView()->getOperandStack()->push(array_token);
  }
  else {
    PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

    PSVinteger num_tokens = string_token1->getLength();

    if (ind < 0 || count < 0 || ind + count > num_tokens) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    PSViewStringToken *token = new PSViewStringToken(mgr->getPSView(), count);

    for (int i = 1; i <= count; i++) {
      int c = string_token1->getChar(ind + i);

      token->setChar(i, c);
    }

    mgr->getPSView()->getOperandStack()->push(token);
  }
}

void
PSViewOperatorMgr::
globalDictOp(PSViewOperatorMgr *mgr)
{
  PSViewDictionaryToken *token = mgr->getPSView()->getDictionaryMgr()->getGlobalDictionary();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
glyphShowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewNameToken *name_token = (PSViewNameToken *) token;

  const PSViewName &name = name_token->getValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->glyphShow(name);
}

void
PSViewOperatorMgr::
grestoreOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getGStateTokenMgr()->restore();
}

void
PSViewOperatorMgr::
grestoreAllOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getGStateTokenMgr()->restoreAll();
}

void
PSViewOperatorMgr::
gsaveOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getGStateTokenMgr()->save();
}

void
PSViewOperatorMgr::
gstateOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *token = new PSViewGStateToken(mgr->getPSView());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
gtOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  PSVinteger flag = token1->compare(token2);

  if (flag > 0)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
handleErrorOp(PSViewOperatorMgr *mgr)
{
  PSViewNameToken *key = new PSViewNameToken(mgr->getPSView(), "errordict");

  PSViewDictionaryToken *dict =
    (PSViewDictionaryToken *) mgr->getPSView()->getDictionaryMgr()->lookup(key);

  PSViewNameToken *key1 = new PSViewNameToken(mgr->getPSView(), "handleerror");

  PSViewToken *value1 = dict->getValue(key1);

  if (value1 != NULL && value1->isNull())
    mgr->getPSView()->getErrorMgr()->defaultErrorHandler();
  else
    value1->execute();
}

void
PSViewOperatorMgr::
identMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  CMatrix2D matrix;

  matrix.setIdentity();

  token->setMatrix(&matrix);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
idivOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isInteger() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger integer2 = token2->getIntegerValue();

  if (integer2 == 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  PSVinteger integer1 = token1->getIntegerValue();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), integer1/integer2);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
idtransformOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal x = token1->getRealValue();
    PSVreal y = token2->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    CMatrix2D *matrix = gstate_token->getInverseCTMMatrix();

    PSVreal x1, y1, x2, y2;

    matrix->multiplyPoint(0.0, 0.0, &x1, &y1);
    matrix->multiplyPoint(  x,   y, &x2, &y2);

    token1 = new PSViewRealToken(mgr->getPSView(), x2 - x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y2 - y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
  else {
    CAutoPtr<CMatrix2D> matrix;

    matrix = token2->getMatrix();

    if (matrix == NULL)
      return;

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x = token0->getRealValue();
    PSVreal y = token1->getRealValue();

    CMatrix2D imatrix;

    if (! matrix->invert(imatrix)) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

      return;
    }

    PSVreal x1, y1, x2, y2;

    matrix->multiplyPoint(0.0, 0.0, &x1, &y1);
    matrix->multiplyPoint(  x,   y, &x2, &y2);

    token1 = new PSViewRealToken(mgr->getPSView(), x2 - x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y2 - y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
}

void
PSViewOperatorMgr::
ifOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isBoolean() || ! token2->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token1->getBooleanValue())
    token2->execute();
}

void
PSViewOperatorMgr::
ifelseOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token1->isBoolean() || ! token2->isProcedure() || ! token3->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  if (token1->getBooleanValue())
    token2->execute();
  else
    token3->execute();
}

void
PSViewOperatorMgr::
imageOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();

  if (token5 == NULL)
    return;

  PSViewToken *token1, *token2, *token3, *token4;

  int decode_size = 0;

  vector<double> decode_array;

  if (token5->isDictionary()) {
    PSViewDictionaryToken *dictionary_token = (PSViewDictionaryToken *) token5;

    PSViewToken *decode = dictionary_token->getValue("Decode");

    token1 = dictionary_token->getValue("Width");
    token2 = dictionary_token->getValue("Height");
    token3 = dictionary_token->getValue("BitsPerComponent");
    token4 = dictionary_token->getValue("ImageMatrix");
    token5 = dictionary_token->getValue("DataSource");

    if (token1 == NULL || token2 == NULL || token3 == NULL ||
        token4 == NULL || token5 == NULL || decode == NULL) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);
      return;
    }

    if (! token1->isInteger() || ! token2->isInteger() || ! token3->isInteger() ||
        ! token4->isMatrix () || ! decode->isArray()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    PSViewArrayToken *array_token = (PSViewArrayToken *) decode;

    decode_size = array_token->getNumValues();

    decode_array.resize(decode_size);

    for (int i = 1; i <= decode_size; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
        return;
      }

      decode_array[i - 1] = sub_token->getRealValue();
    }
  }
  else {
    token4 = mgr->getPSView()->getOperandStack()->pop();
    token3 = mgr->getPSView()->getOperandStack()->pop();
    token2 = mgr->getPSView()->getOperandStack()->pop();
    token1 = mgr->getPSView()->getOperandStack()->pop();

    if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL) {
      return;
    }

    if (! token1->isInteger() || ! token2->isInteger() || ! token3->isInteger() ||
        ! token4->isMatrix ()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }
  }

  if (! token5->isProcedure() && ! token5->isString() && ! token5->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVinteger width           = token1->getIntegerValue();
  PSVinteger height          = token2->getIntegerValue();
  PSVinteger bits_per_sample = token3->getIntegerValue();
  CMatrix2D  matrix          = *token4->getMatrix();

  if (width <= 0 || height <= 0 ||
      (bits_per_sample != 1 && bits_per_sample != 2 && bits_per_sample != 4 &&
       bits_per_sample != 8 && bits_per_sample != 12)) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  if (token5->isFile()) {
    PSViewFileToken *file_token = (PSViewFileToken *) token5;

    string str;

    int c = file_token->readChar();

    while (c != EOF) {
      str += c;

      c = file_token->readChar();
    }

    token5 = new PSViewStringToken(token5->getPSView(), str);
  }

  if (token5->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) token5;

    PSVinteger length = string_token->getLength();

    if ((width % 8) != 0)
      width -= (width % 8);

    PSVinteger num_bits = width*height*bits_per_sample;

    PSVinteger num_bytes = num_bits/8;

    char *image_data = new char [num_bytes];

    memset(image_data, 0, num_bytes*sizeof(char));

    int bit_num  = 7;
    int byte_num = 0;

    int bit_mask = 1 << bit_num;

    for (int i = 0; i < length; i++) {
      int c = string_token->getChar(i + 1);

      for (int j = 0; j < 8; j++) {
        int char_mask = 1 << (7 - j);

        if (c & char_mask)
          image_data[byte_num] |= bit_mask;

        bit_num--;

        if (bit_num < 0) {
          bit_num = 7;

          byte_num++;

          if (byte_num == num_bytes)
            break;
        }

        bit_mask = 1 << bit_num;
      }

      if (byte_num == num_bytes)
        break;
    }

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->image(image_data, (int) width, (int) height, (int) bits_per_sample, &matrix,
                        &decode_array[0], decode_size);

    delete [] image_data;
  }
  else {
    PSVinteger width1 = width;

    if ((width % 8) != 0)
      width1 += 8 - (width % 8);

    PSVinteger num_bits = width1*height*bits_per_sample;

    PSVinteger num_bytes = num_bits/8;

    char *image_data = new char [num_bytes];

    for (int i = 0; i < num_bytes; i++)
      image_data[i] = '\0';

    int bit_num  = 7;
    int byte_num = 0;

    int bit_mask = 1 << bit_num;

    while (byte_num < num_bytes) {
      token5->execute();

      PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

      if (token == NULL)
        break;

      if (! token->isString()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
        break;
      }

      PSViewStringToken *string_token = (PSViewStringToken *) token;

      PSVinteger length = string_token->getLength();

      if (length == 0) {
        byte_num = num_bytes;

        break;
      }

      for (int i = 0; i < length; i++) {
        int c = string_token->getChar(i + 1);

        for (int j = 0; j < 8; j++) {
          int char_mask = 1 << (7 - j);

          if (c & char_mask)
            image_data[byte_num] |= bit_mask;

          bit_num--;

          if (bit_num < 0) {
            bit_num = 7;

            byte_num++;

            if (byte_num == num_bytes)
              break;
          }

          bit_mask = 1 << bit_num;
        }

        if (byte_num == num_bytes)
          break;
      }
    }

    if (byte_num == num_bytes) {
      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->image(image_data, (int) width, (int) height, (int) bits_per_sample, &matrix,
                          &decode_array[0], decode_size);
    }

    delete [] image_data;
  }
}

void
PSViewOperatorMgr::
imageMaskOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();

  if (token5 == NULL)
    return;

  PSViewToken *token1, *token2, *token3, *token4;

  if (token5->isDictionary()) {
    PSViewDictionaryToken *dictionary_token = (PSViewDictionaryToken *) token5;

    PSViewToken *decode = dictionary_token->getValue("Decode");

    token1 = dictionary_token->getValue("Width");
    token2 = dictionary_token->getValue("Height");
    token4 = dictionary_token->getValue("ImageMatrix");
    token5 = dictionary_token->getValue("DataSource");

    if (token1 == NULL || token2 == NULL || token4 == NULL || token5 == NULL || decode == NULL) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);
      return;
    }

    if (! token1->isInteger() || ! token2->isInteger() || ! token4->isMatrix() ||
        ! decode->isArray()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    PSViewArrayToken *array_token = (PSViewArrayToken *) decode;

    int decode_size = array_token->getNumValues();

    if (decode_size != 2) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    vector<double> decode_array;

    decode_array.resize(decode_size);

    for (int i = 1; i <= decode_size; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
        return;
      }

      decode_array[i - 1] = sub_token->getRealValue();
    }

    if      (decode_array[0] == 1 && decode_array[1] == 0)
      token3 = new PSViewBooleanToken(mgr->getPSView(), false);
    else if (decode_array[0] == 0 && decode_array[1] == 1)
      token3 = new PSViewBooleanToken(mgr->getPSView(), true);
    else {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }
  }
  else {
    token4 = mgr->getPSView()->getOperandStack()->pop();
    token3 = mgr->getPSView()->getOperandStack()->pop();
    token2 = mgr->getPSView()->getOperandStack()->pop();
    token1 = mgr->getPSView()->getOperandStack()->pop();

    if (token1 == NULL || token2 == NULL || token3 == NULL || token4 == NULL)
      return;

    if (! token1->isInteger() || ! token2->isInteger() || ! token3->isBoolean() ||
        ! token4->isMatrix ()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }
  }

  if (! token5->isProcedure() && ! token5->isString() && ! token5->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVinteger width    = token1->getIntegerValue();
  PSVinteger height   = token2->getIntegerValue();
  PSVboolean polarity = token3->getBooleanValue();
  CMatrix2D  matrix   = *token4->getMatrix();

  if (width <= 0 || height <= 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  if (token5->isFile()) {
    PSViewFileToken *file_token = (PSViewFileToken *) token5;

    string str;

    int c = file_token->readChar();

    while (c != EOF) {
      str += c;

      c = file_token->readChar();
    }

    token5 = new PSViewStringToken(token5->getPSView(), str);
  }

  if (token5->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) token5;

    PSVinteger length = string_token->getLength();

    if ((width % 8) != 0)
      width -= (width % 8);

    PSVinteger num_bits = width*height;

    PSVinteger num_bytes = num_bits/8;

    char *image_data = new char [num_bytes];

    memset(image_data, 0, num_bytes*sizeof(char));

    int bit_num  = 7;
    int byte_num = 0;

    int bit_mask = 1 << bit_num;

    for (int i = 0; i < length; i++) {
      int c = string_token->getChar(i + 1);

      for (int j = 0; j < 8; j++) {
        int char_mask = 1 << (7 - j);

        if (c & char_mask)
          image_data[byte_num] |= bit_mask;

        bit_num--;

        if (bit_num < 0) {
          bit_num = 7;

          byte_num++;

          if (byte_num == num_bytes)
            break;
        }

        bit_mask = 1 << bit_num;
      }

      if (byte_num == num_bytes)
        break;
    }

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->imageMask(image_data, (int) width, (int) height, (int) polarity, &matrix);

    delete [] image_data;
  }
  else {
    PSVinteger width1 = width;

    if ((width % 8) != 0)
      width1 += 8 - (width % 8);

    PSVinteger num_bits = width1*height;

    PSVinteger num_bytes = num_bits/8;

    char *image_data = new char [num_bytes];

    for (int i = 0; i < num_bytes; i++)
      image_data[i] = '\0';

    PSVinteger bit_num  = 7;
    PSVinteger byte_num = 0;

    int bit_mask = 1 << bit_num;

    while (byte_num < num_bytes) {
      token5->execute();

      PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

      if (token == NULL)
        break;

      if (! token->isString()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        break;
      }

      PSViewStringToken *string_token = (PSViewStringToken *) token;

      PSVinteger length = string_token->getLength();

      if (length == 0) {
        byte_num = num_bytes;

        break;
      }

      for (int i = 0; i < length; i++) {
        int c = string_token->getChar(i + 1);

        for (int j = 0; j < 8; j++) {
          int char_mask = 1 << (7 - j);

          if (c & char_mask)
            image_data[byte_num] |= bit_mask;

          bit_num--;

          if (bit_num < 0) {
            bit_num = 7;

            byte_num++;

            if (byte_num == num_bytes)
              break;
          }

          bit_mask = 1 << bit_num;
        }

        if (byte_num == num_bytes)
          break;
      }
    }

    if (byte_num == num_bytes) {
      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->imageMask(image_data, (int) width, (int) height, (int) polarity, &matrix);
    }

    delete [] image_data;
  }
}

void
PSViewOperatorMgr::
indexOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger count = token->getIntegerValue();

  if (count < 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSVinteger num_stack = mgr->getPSView()->getOperandStack()->size();

  if (count >= num_stack) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);

    return;
  }

  token = mgr->getPSView()->getOperandStack()->peek((int) (num_stack - count));

  PSViewToken *token1 = token->dup();

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
initClipOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->initClip();
}

void
PSViewOperatorMgr::
initGraphicsOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->initGraphics();
}

void
PSViewOperatorMgr::
initMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->initMatrix();
}

void
PSViewOperatorMgr::
internalDictOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  int integer = token->getIntegerValue();

  if (integer != 1183615869) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);

    return;
  }

  PSViewDictionaryToken *dict = mgr->getPSView()->getDictionaryMgr()->getInternalDictionary();

  mgr->getPSView()->getOperandStack()->push(dict);
}

void
PSViewOperatorMgr::
invertMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token2 == NULL)
    return;

  if (! token2->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  CAutoPtr<CMatrix2D> matrix1;

  matrix1 = token1->getMatrix();

  if (matrix1 == NULL)
    return;

  CMatrix2D imatrix;

  if (! matrix1->invert(imatrix)) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  token2->setMatrix(&imatrix);

  mgr->getPSView()->getOperandStack()->push(token2);
}

void
PSViewOperatorMgr::
itransformOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal x = token1->getRealValue();
    PSVreal y = token2->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    CMatrix2D *matrix = gstate_token->getInverseCTMMatrix();

    PSVreal x1, y1;

    matrix->multiplyPoint(x, y, &x1, &y1);

    token1 = new PSViewRealToken(mgr->getPSView(), x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
  else {
    CAutoPtr<CMatrix2D> matrix;

    matrix = token2->getMatrix();

    if (matrix == NULL)
      return;

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x = token0->getRealValue();
    PSVreal y = token1->getRealValue();

    CMatrix2D imatrix;

    if (! matrix->invert(imatrix)) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

      return;
    }

    PSVreal x1, y1;

    imatrix.multiplyPoint(x, y, &x1, &y1);

    token1 = new PSViewRealToken(mgr->getPSView(), x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
}

void
PSViewOperatorMgr::
knownOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dictionary_token1 = (PSViewDictionaryToken *) token1;

  PSViewToken *token = dictionary_token1->getValue(token2);

  if (token != NULL)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
kshowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isProcedure() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  string str = string_token2->toString();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->kshow(token1, str);
}

void
PSViewOperatorMgr::
languageLevelOp(PSViewOperatorMgr *mgr)
{
  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), 2);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
leOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  PSVinteger flag = token1->compare(token2);

  if (flag <= 0)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
lengthOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSVinteger length;

  if      (token->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token;

    length = array_token->getNumValues();
  }
  else if (token->isPackedArray()) {
    PSViewPackedArrayToken *array_token = (PSViewPackedArrayToken *) token;

    length = array_token->getNumValues();
  }
  else if (token->isDictionary()) {
    PSViewDictionaryToken *dictionary_token = (PSViewDictionaryToken *) token;

    length = dictionary_token->getNumValues();
  }
  else if (token->isString()) {
    PSViewStringToken *string_token = (PSViewStringToken *) token;

    length = string_token->getLength();
  }
  else if (token->isName()) {
    PSViewNameToken *name_token = (PSViewNameToken *) token;

    length = name_token->getLength();
  }
  else {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), length);

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
lineToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal x = token1->getRealValue();
  PSVreal y = token2->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->lineTo(x, y);
}

void
PSViewOperatorMgr::
lnOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real = token->getRealValue();

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), log(real));

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
loadOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSViewToken *token1 = mgr->getPSView()->getDictionaryMgr()->lookup(token);

  if (token1 == NULL) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

    return;
  }

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
logOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real = token->getRealValue();

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), log10(real));

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
loopOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  for (;;) {
    token->execute();

    if (mgr->getPSView()->getExitFlag()) {
      mgr->getPSView()->getExecutionStack()->popToExit();
      break;
    }
  }
}

void
PSViewOperatorMgr::
ltOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  PSVinteger flag = token1->compare(token2);

  if (flag < 0)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
makeFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isDictionary() || ! token2->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  CAutoPtr<CMatrix2D> matrix;

  matrix = token2->getMatrix();

  PSViewDictionaryToken *dict = (PSViewDictionaryToken *) token1;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewDictionaryToken *font = gstate_token->makeFont(dict, matrix);

  mgr->getPSView()->getOperandStack()->push(font);
}

void
PSViewOperatorMgr::
makePatternOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isDictionary() || ! token2->isMatrix()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  CAutoPtr<CMatrix2D> matrix;

  matrix = token2->getMatrix();

  PSViewDictionaryToken *dict = (PSViewDictionaryToken *) token1;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewDictionaryToken *pattern = gstate_token->makePattern(dict, matrix);

  mgr->getPSView()->getOperandStack()->push(pattern);
}

void
PSViewOperatorMgr::
markOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getOperandStack()->push(mgr->getPSView()->getMarkToken());
}

void
PSViewOperatorMgr::
matrixOp(PSViewOperatorMgr *mgr)
{
  CMatrix2D matrix;

  matrix.setIdentity();

  PSViewArrayToken *token = new PSViewArrayToken(mgr->getPSView(), &matrix);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
maxLengthOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dictionary_token = (PSViewDictionaryToken *) token;

  PSVinteger length = dictionary_token->getMaxValues();

  PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), length);

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
modOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isInteger() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger integer2 = token2->getIntegerValue();

  if (integer2 == 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESULT);

    return;
  }

  PSVinteger integer1 = token1->getIntegerValue();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), integer1 % integer2);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
moveToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal x = token1->getRealValue();
  PSVreal y = token2->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->moveTo(x, y);
}

void
PSViewOperatorMgr::
mulOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewToken *token;

  if (token1->isInteger() && token2->isInteger()) {
    PSVinteger result = token1->getIntegerValue() *
                        token2->getIntegerValue();

    token = new PSViewIntegerToken(mgr->getPSView(), result);
  }
  else {
    PSVreal result = token1->getRealValue()*token2->getRealValue();

    token = new PSViewRealToken(mgr->getPSView(), result);
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
neOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (token1->compare(token2) == 0)
    falseOp(mgr);
  else
    trueOp(mgr);
}

void
PSViewOperatorMgr::
negOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewToken *token1;

  if (token->isInteger()) {
    PSVinteger integer = token->getIntegerValue();

    if (integer != LONG_MIN)
      token1 = new PSViewIntegerToken(mgr->getPSView(), -integer);
    else
      token1 = new PSViewRealToken(mgr->getPSView(), -((double) integer));
  }
  else {
    PSVreal real = token->getRealValue();

    token1 = new PSViewRealToken(mgr->getPSView(), -real);
  }

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
newPathOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->newPath();
}

void
PSViewOperatorMgr::
noAccessOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isArray() && ! token->isPackedArray() &&
      ! token->isDictionary() && ! token->isFile() && ! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  token->setNoAccess();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
notOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isBoolean() && ! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isBoolean()) {
    if (! token->getBooleanValue())
      trueOp(mgr);
    else
      falseOp(mgr);
  }
  else {
    PSVinteger integer = token->getIntegerValue();

    PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), ~integer);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
nullOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = new PSViewNullToken(mgr->getPSView());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
orOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if ((! token1->isBoolean() && ! token1->isInteger()) ||
      (! token2->isBoolean() && ! token2->isInteger()) ||
      ! token1->isType(token2->getType())) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token1->isBoolean()) {
    PSVboolean boolean1 = token1->getBooleanValue();
    PSVboolean boolean2 = token2->getBooleanValue();

    if (boolean1 | boolean2)
      trueOp(mgr);
    else
      falseOp(mgr);
  }
  else {
    PSVinteger integer1 = token1->getIntegerValue();
    PSVinteger integer2 = token2->getIntegerValue();

    PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), integer1 | integer2);

    mgr->getPSView()->getOperandStack()->push(token);
  }
}

void
PSViewOperatorMgr::
packedArrayOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  if (! token1->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger dimension = token1->getIntegerValue();

  if (dimension < 0 || dimension > MAX_ARRAY_DIMENSION) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewPackedArrayToken *packed_array = new PSViewPackedArrayToken(mgr->getPSView(), dimension);

  for (int i = 1; i <= dimension; i++) {
    PSViewToken *sub_token = mgr->getPSView()->getOperandStack()->pop();

    if (sub_token == NULL)
      return;

    packed_array->setValue(dimension - i + 1, sub_token);
  }

  mgr->getPSView()->getOperandStack()->push(packed_array);
}

void
PSViewOperatorMgr::
pathBBoxOp(PSViewOperatorMgr *mgr)
{
  double llx, lly, urx, ury;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->pathBBox(&llx, &lly, &urx, &ury);

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), llx);
  PSViewRealToken *token2 = new PSViewRealToken(mgr->getPSView(), lly);
  PSViewRealToken *token3 = new PSViewRealToken(mgr->getPSView(), urx);
  PSViewRealToken *token4 = new PSViewRealToken(mgr->getPSView(), ury);

  mgr->getPSView()->getOperandStack()->push(token1);
  mgr->getPSView()->getOperandStack()->push(token2);
  mgr->getPSView()->getOperandStack()->push(token3);
  mgr->getPSView()->getOperandStack()->push(token4);
}

void
PSViewOperatorMgr::
pathForAllOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL ||
      token3 == NULL || token4 == NULL)
    return;

  if (! token1->isProcedure() || ! token2->isProcedure() ||
      ! token3->isProcedure() || ! token4->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->pathForAll(token1, token2, token3, token4);
}

void
PSViewOperatorMgr::
popOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->getOperandStack()->pop();
}

void
PSViewOperatorMgr::
printOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token = (PSViewStringToken *) token;

  string str = string_token->toString();

  CStrUtil::printf("%s", str.c_str());
}

void
PSViewOperatorMgr::
productOp(PSViewOperatorMgr *mgr)
{
  static string product = "PSView";

  PSViewStringToken *token = new PSViewStringToken(mgr->getPSView(), product);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
promptOp(PSViewOperatorMgr *)
{
  CStrUtil::printf("%s", "PS> ");
}

void
PSViewOperatorMgr::
pstackOp(PSViewOperatorMgr *mgr)
{
  int num_stack = mgr->getPSView()->getOperandStack()->size();

  for (int i = num_stack; i >= 1; i--) {
    PSViewToken *token = mgr->getPSView()->getOperandStack()->peek(i);

    token->print();

    CStrUtil::printf("\n");
  }
}

void
PSViewOperatorMgr::
putOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (token1->isArray() || token1->isString()) {
    if (! token2->isInteger()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVinteger ind = token2->getIntegerValue();

    PSVinteger num_tokens;

    if (token1->isArray()) {
      PSViewArrayToken *array_token = (PSViewArrayToken *) token1;

      num_tokens = array_token->getNumValues();

      if (ind < 0 || ind >= num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      array_token->setValue(ind + 1, token3);
    }
    else if (token1->isPackedArray()) {
      PSViewPackedArrayToken *array_token = (PSViewPackedArrayToken *) token1;

      num_tokens = array_token->getNumValues();

      if (ind < 0 || ind >= num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      array_token->setValue(ind + 1, token3);
    }
    else {
      PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

      num_tokens = string_token1->getLength();

      if (ind < 0 || ind >= num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      if (! token3->isInteger()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }

      PSVinteger c = token3->getIntegerValue();

      string_token1->setChar(ind + 1, c);
    }
  }
  else if (token1->isDictionary()) {
    PSViewDictionaryToken *dict = (PSViewDictionaryToken *) token1;

    dict->addValue(token2, token3);
  }
  else {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }
}

void
PSViewOperatorMgr::
putIntervalOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token1->isArray() && ! token1->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token1->isArray()) {
    if (! token3->isArray() && ! token3->isPackedArray()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }
  }
  else {
    if (! token3->isString()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }
  }

  PSVinteger ind = token2->getIntegerValue();

  PSVinteger num_tokens1;

  if (token1->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token1;

    num_tokens1 = array_token->getNumValues();
  }
  else {
    PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

    num_tokens1 = string_token1->getLength();
  }

  PSVinteger num_tokens3;

  if (token3->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token3;

    num_tokens3 = array_token->getNumValues();
  }
  else if (token3->isPackedArray()) {
    PSViewPackedArrayToken *array_token = (PSViewPackedArrayToken *) token3;

    num_tokens3 = array_token->getNumValues();
  }
  else {
    PSViewStringToken *string_token3 = (PSViewStringToken *) token3;

    num_tokens3 = string_token3->getLength();
  }

  if (ind < 0 || ind + num_tokens3 > num_tokens1) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  if (token1->isArray()) {
    PSViewToken **tokens = new PSViewToken * [num_tokens3 + 1];

    if (token3->isArray()) {
      PSViewArrayToken *array_token3 = (PSViewArrayToken *) token3;

      for (int i = 1; i <= num_tokens3; i++)
        tokens[i - 1] = array_token3->getValue(i);
    }
    else {
      PSViewPackedArrayToken *packed_array_token3 = (PSViewPackedArrayToken *) token3;

      for (int i = 1; i <= num_tokens3; i++)
        tokens[i - 1] = packed_array_token3->getValue(i);
    }

    PSViewArrayToken *array_token1 = (PSViewArrayToken *) token1;

    array_token1->setSubValues(ind + 1, tokens, num_tokens3);
  }
  else {
    PSViewStringToken *string_token3 = (PSViewStringToken *) token3;

    string str;

    for (int i = 1; i <= num_tokens3; i++)
      str += string_token3->getChar(i);

    PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

    string_token1->setChars(str, ind + 1);
  }
}

void
PSViewOperatorMgr::
quitOp(PSViewOperatorMgr *mgr)
{
  mgr->getPSView()->term();

  exit(0);
}

void
PSViewOperatorMgr::
randOp(PSViewOperatorMgr *mgr)
{
  long r = COSRand::rand();

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), r);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
rcheckOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isArray() && ! token->isPackedArray() && ! token->isDictionary() &&
      ! token->isFile() && ! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  if (token->getReadable())
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
rcurveToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token6 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL ||
      token4 == NULL || token5 == NULL || token6 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber() ||
      ! token5->isNumber() || ! token6->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double x1 = token1->getRealValue();
  double y1 = token2->getRealValue();
  double x2 = token3->getRealValue();
  double y2 = token4->getRealValue();
  double x3 = token5->getRealValue();
  double y3 = token6->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->rcurveTo(x1, y1, x2, y2, x3, y3);
}

void
PSViewOperatorMgr::
readOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token;

  int c = file_token->readChar();

  if (c != EOF) {
    PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), c);

    mgr->getPSView()->getOperandStack()->push(token1);

    trueOp(mgr);
  }
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
readHexStringOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken   *file_token1   = (PSViewFileToken   *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger length = string_token2->getLength();

  int i = 1;

  string hex_string;

  while (i <= length) {
    int c = file_token1->readChar();

    if (c == EOF)
      break;

    if (! isxdigit(c))
      continue;

    hex_string += c;

    if (hex_string.size() == 2) {
      int hex_value = CStrUtil::toBaseInteger(hex_string, 16);

      string_token2->setChar(i++, hex_value);

      hex_string = "";
    }
  }

  if (hex_string.size() == 1) {
    hex_string += '0';

    int hex_value = CStrUtil::toBaseInteger(hex_string, 16);

    string_token2->setChar(i++, (PSVchar) hex_value);
  }

  PSViewToken *token;

  if (i - 1 <= length)
    token = string_token2->subString(1, i - 1);
  else
    token = string_token2->subString(1, length);

  mgr->getPSView()->getOperandStack()->push(token);

  if (i - 1 == length)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
readLineOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken   *file_token1   = (PSViewFileToken   *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger length = string_token2->getLength();

  int c = file_token1->readChar();

  int i = 1;

  while (c != '\n' && c != EOF) {
    if (i > length) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    string_token2->setChar(i++, c);

    c = file_token1->readChar();
  }

  PSViewToken *token = string_token2->subString(1, i);

  mgr->getPSView()->getOperandStack()->push(token);

  if (c == '\n')
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
readOnlyOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isArray() && ! token->isPackedArray() &&
      ! token->isDictionary() && ! token->isFile() &&
      ! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  token->setReadOnly();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
readStringOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken   *file_token1   = (PSViewFileToken   *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger length = string_token2->getLength();

  int i;

  for (i = 1; i <= length; i++) {
    int c = file_token1->readChar();

    if (c == EOF)
      break;

    string_token2->setChar(i, c);
  }

  PSViewToken *token;

  if (i <= length)
    token = string_token2->subString(1, i);
  else
    token = string_token2->subString(1, length);

  mgr->getPSView()->getOperandStack()->push(token);

  if (i == length)
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
realTimeOp(PSViewOperatorMgr *mgr)
{
  time_t real_time = time(NULL);

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), (int) real_time);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
rectClipOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();

  if (token4 == NULL)
    return;

  if (token4->isNumber()) {
    PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
    PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
    PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

    if (token1 == NULL || token2 == NULL || token3 == NULL)
      return;

    if (! token1->isNumber() || ! token2->isNumber() ||
        ! token3->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x      = token1->getRealValue();
    PSVreal y      = token2->getRealValue();
    PSVreal width  = token3->getRealValue();
    PSVreal height = token4->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->rectClip(&x, &y, &width, &height, 1);
  }
  else if (token4->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token4;

    PSVinteger num_tokens = array_token->getNumValues();

    if (num_tokens % 4 != 0) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }
    }

    PSVinteger num_arrays = num_tokens/4;

    vector<double> x, y, width, height;

    x     .resize(num_arrays);
    y     .resize(num_arrays);
    width .resize(num_arrays);
    height.resize(num_arrays);

    PSViewToken *tokens[4];

    for (int i = 0; i < num_arrays; i++) {
      tokens[0] = array_token->getValue(4*i + 1);
      tokens[1] = array_token->getValue(4*i + 2);
      tokens[2] = array_token->getValue(4*i + 3);
      tokens[3] = array_token->getValue(4*i + 4);

      x     [i] = tokens[0]->getRealValue();
      y     [i] = tokens[1]->getRealValue();
      width [i] = tokens[2]->getRealValue();
      height[i] = tokens[3]->getRealValue();
    }

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->rectClip(&x[0], &y[0], &width[0], &height[0],
                           (int) num_arrays);
  }
  else if (token4->isString())
    CStrUtil::eprintf("PSView: RectClip not implemented for Strings\n");
  else
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
}

void
PSViewOperatorMgr::
rectFillOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();

  if (token4 == NULL)
    return;

  if (token4->isNumber()) {
    PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
    PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
    PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

    if (token1 == NULL || token2 == NULL || token3 == NULL)
      return;

    if (! token1->isNumber() || ! token2->isNumber() ||
        ! token3->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x      = token1->getRealValue();
    PSVreal y      = token2->getRealValue();
    PSVreal width  = token3->getRealValue();
    PSVreal height = token4->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->rectFill(x, y, width, height);
  }
  else if (token4->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token4;

    PSVinteger num_tokens = array_token->getNumValues();

    if (num_tokens % 4 != 0) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    for (int i = 1; i < num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }
    }

    PSVinteger num_arrays = num_tokens/4;

    PSViewToken *tokens[4];

    for (int i = 0; i < num_arrays; i++) {
      tokens[0] = array_token->getValue(4*i + 1);
      tokens[1] = array_token->getValue(4*i + 2);
      tokens[2] = array_token->getValue(4*i + 3);
      tokens[3] = array_token->getValue(4*i + 4);

      double x      = tokens[0]->getRealValue();
      double y      = tokens[1]->getRealValue();
      double width  = tokens[2]->getRealValue();
      double height = tokens[3]->getRealValue();

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->rectFill(x, y, width, height);
    }
  }
  else if (token4->isString())
    CStrUtil::eprintf("PSView: RectFill not implemented for Strings\n");
  else
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
}

void
PSViewOperatorMgr::
rectStrokeOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  CAutoPtr<CMatrix2D> matrix;

  PSViewToken *token4;

  if (token->isMatrix()) {
    matrix = token->getMatrix();

    token4 = mgr->getPSView()->getOperandStack()->pop();

    if (token4 == NULL)
      return;
  }
  else
    token4 = token;

  if (token4->isNumber()) {
    PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
    PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
    PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

    if (token1 == NULL || token2 == NULL || token3 == NULL)
      return;

    if (! token1->isNumber() || ! token2->isNumber() || ! token3->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x      = token1->getRealValue();
    PSVreal y      = token2->getRealValue();
    PSVreal width  = token3->getRealValue();
    PSVreal height = token4->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->rectStroke(x, y, width, height, matrix);
  }
  else if (token4->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token4;

    PSVinteger num_tokens = array_token->getNumValues();

    if (num_tokens % 4 != 0) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    for (int i = 1; i <= num_tokens; i++) {
      token = array_token->getValue(i);

      if (! token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }
    }

    PSVinteger num_arrays = num_tokens/4;

    PSViewToken *tokens[4];

    for (int i = 0; i < num_arrays; i++) {
      tokens[0] = array_token->getValue(4*i + 1);
      tokens[1] = array_token->getValue(4*i + 2);
      tokens[2] = array_token->getValue(4*i + 3);
      tokens[3] = array_token->getValue(4*i + 4);

      double x      = tokens[0]->getRealValue();
      double y      = tokens[1]->getRealValue();
      double width  = tokens[2]->getRealValue();
      double height = tokens[3]->getRealValue();

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->rectStroke(x, y, width, height, matrix);
    }
  }
  else if (token4->isString())
    CStrUtil::eprintf("PSView: RectStroke not implemented for Strings\n");
  else
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
}

void
PSViewOperatorMgr::
renameFileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  string filename1 = string_token1->toString();
  string filename2 = string_token2->toString();

  rename(filename1.c_str(), filename2.c_str());
}

void
PSViewOperatorMgr::
repeatOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isProcedure() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger num_iterations = token2->getIntegerValue();

  if (num_iterations < 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  mgr->getPSView()->getExecutionStack()->push(mgr->getPSView()->getMarkToken());

  for (int i = 0; i < num_iterations; i++)
    mgr->getPSView()->getExecutionStack()->push(token1);

  token1 = mgr->getPSView()->getExecutionStack()->pop();

  while (token1 != NULL && token1 != mgr->getPSView()->getMarkToken()) {
    token1->execute();

    if (mgr->getPSView()->getExitFlag()) {
      mgr->getPSView()->getExecutionStack()->popToExit();
      break;
    }

    token1 = mgr->getPSView()->getExecutionStack()->pop();
  }
}

void
PSViewOperatorMgr::
resetFileOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token = (PSViewFileToken *) token;

  file_token->reset();
}

void
PSViewOperatorMgr::
resourceForAllOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (! token1->isString() || ! token2->isProcedure() ||
      ! token3->isString() || ! token4->isName     ()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
  PSViewStringToken *string_token3 = (PSViewStringToken *) token3;

  string templ   = string_token1->toString();
  string scratch = string_token3->toString();

  size_t scratch_len = scratch.size();

  CGlob pattern(templ);

  PSViewNameToken *name_token = (PSViewNameToken *) token2;

  vector<PSViewResource *> resources =
    mgr->getPSView()->getResourceMgr()->getResources(name_token->getValue());

  int num = resources.size();

  for (int i = 0; i < num; i++) {
    PSViewToken *resource = resources[i]->getKey();

    string str;

    if (resource->isName()) {
      PSViewNameToken *name_token = (PSViewNameToken *) resource;

      string str = name_token->getString();
    }

    if (! pattern.compare(str))
      continue;

    if (str.size() > scratch_len) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      break;
    }

    if (resource->isName()) {
      scratch = str;

      string_token3->setChars(scratch, 1);

      mgr->getPSView()->getOperandStack()->push(token3);
    }
    else
      mgr->getPSView()->getOperandStack()->push(resource);

    token2->execute();
  }
}

void
PSViewOperatorMgr::
restoreOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (! token->isSave()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  mgr->getPSView()->getMemoryMgr()->restore(token);
}

void
PSViewOperatorMgr::
reversePathOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->reversePath();
}

void
PSViewOperatorMgr::
revisionOp(PSViewOperatorMgr *mgr)
{
  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), 0);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
rlineToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal x = token1->getRealValue();
  PSVreal y = token2->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->rlineTo(x, y);
}

void
PSViewOperatorMgr::
rmoveToOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal x = token1->getRealValue();
  PSVreal y = token2->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->rmoveTo(x, y);
}

void
PSViewOperatorMgr::
rollOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isInteger() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger integer1 = token1->getIntegerValue();
  PSVinteger integer2 = token2->getIntegerValue();

  mgr->getPSView()->getOperandStack()->roll(integer2, integer1);
}

void
PSViewOperatorMgr::
rootFontOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewToken *token = gstate_token->getRootFont();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
rotateOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL)
    return;

  if (token1->isNumber()) {
    PSVreal angle = token1->getRealValue();

    CMatrix2D matrix;

    matrix.setRotation(-CMathGen::DegToRad(angle));

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->postMultiplyCTMMatrix(&matrix);
  }
  else {
    if (! token1->isMatrix()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
      return;
    }

    PSVreal angle = token0->getRealValue();

    CMatrix2D matrix;

    matrix.setRotation(-CMathGen::DegToRad(angle));

    token1->setMatrix(&matrix);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
roundOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isReal()) {
    PSVreal real = token->getRealValue();

    real = CMathGen::Round(real);

    PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), real);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
  else {
    PSViewToken *token1 = token->dup();

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
runOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token = (PSViewStringToken *) token;

  string filename = string_token->toString();

  mgr->getPSView()->openCurrentFile(filename);

  mgr->getPSView()->executeCurrentFile();

  mgr->getPSView()->closeCurrentFile();
}

void
PSViewOperatorMgr::
rrandOp(PSViewOperatorMgr *mgr)
{
  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), mgr->getRandomSeed());

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
saveOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getMemoryMgr()->save();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
scaleOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal x = token1->getRealValue();
    PSVreal y = token2->getRealValue();

    CMatrix2D matrix;

    matrix.setScale(x, y);

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->postMultiplyCTMMatrix(&matrix);
  }
  else {
    if (! token2->isMatrix()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x = token0->getRealValue();
    PSVreal y = token1->getRealValue();

    CMatrix2D matrix;

    matrix.setScale(x, y);

    token2->setMatrix(&matrix);

    mgr->getPSView()->getOperandStack()->push(token2);
  }
}

void
PSViewOperatorMgr::
scaleFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isDictionary() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict = (PSViewDictionaryToken *) token1;

  PSVreal scale = token2->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  PSViewDictionaryToken *font = gstate_token->scaleFont(dict, scale);

  mgr->getPSView()->getOperandStack()->push(font);
}

void
PSViewOperatorMgr::
searchOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger pos = string_token1->isSubString(string_token2);

  if (pos > -1) {
    PSVinteger len2 = string_token2->getLength();

    PSViewToken *token3 = string_token1->split(pos + len2 - 1);
    PSViewToken *token4 = string_token1->split(pos - 1);

    mgr->getPSView()->getOperandStack()->push(token3);
    mgr->getPSView()->getOperandStack()->push(token4);
    mgr->getPSView()->getOperandStack()->push(token1);

    trueOp(mgr);
  }
  else {
    mgr->getPSView()->getOperandStack()->push(token1);

    falseOp(mgr);
  }
}

void
PSViewOperatorMgr::
selectFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal scale = token2->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->selectScaleFont(token1, scale);
  }
  else if (token2->isMatrix()) {
    CMatrix2D *matrix = token2->getMatrix();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->selectMakeFont(token1, matrix);
  }
  else {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }
}

void
PSViewOperatorMgr::
serialNumberOp(PSViewOperatorMgr *mgr)
{
  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), 0);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
setBlackGenerationOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setBlackGeneration(token);
}

void
PSViewOperatorMgr::
setCacheDeviceOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token6 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token5 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL ||
      token4 == NULL || token5 == NULL || token6 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber() ||
      ! token5->isNumber() || ! token6->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double wx  = token1->getRealValue();
  double wy  = token2->getRealValue();
  double llx = token3->getRealValue();
  double lly = token4->getRealValue();
  double urx = token5->getRealValue();
  double ury = token6->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setCacheDevice(wx, wy, llx, lly, urx, ury);
}

void
PSViewOperatorMgr::
setCharWidthOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double wx = token1->getRealValue();
  double wy = token2->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setCharWidth(wx, wy);
}

void
PSViewOperatorMgr::
setCMYKColorOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL ||
      token3 == NULL || token4 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() ||
      ! token3->isNumber() || ! token4->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal cyan    = token1->getRealValue();
  PSVreal magenta = token2->getRealValue();
  PSVreal yellow  = token3->getRealValue();
  PSVreal black   = token4->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setColorSpace(mgr->getPSView()->getGStateMgr()->getCMYKColorSpace());

  gstate_token->setPatternColor(false);

  gstate_token->setCMYKColor(CCMYK(cyan, magenta, yellow, black));
}

void
PSViewOperatorMgr::
setColorOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  const PSViewName &color_space = gstate_token->getColorSpace();

  bool pattern = gstate_token->getPatternColor();

  PSViewToken *token;

  if (pattern) {
    token = mgr->getPSView()->getOperandStack()->pop();

    if (token == NULL)
      return;

    if (! token->isDictionary()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }
  }

  if      (color_space.compare(
             mgr->getPSView()->getGStateMgr()->getRGBColorSpace()) == 0)
    setRGBColorOp(mgr);
  else if (color_space.compare(
             mgr->getPSView()->getGStateMgr()->getCMYKColorSpace()) == 0)
    setCMYKColorOp(mgr);
  else if (color_space.compare(
             mgr->getPSView()->getGStateMgr()->getGrayColorSpace()) == 0)
    setGrayOp(mgr);

  if (pattern) {
    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->setPatternColor(true);

    mgr->getPSView()->getOperandStack()->push(token);

    setPatternOp(mgr);
  }
}

void
PSViewOperatorMgr::
setColorSpaceOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isArray() && ! token->isName()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token;

    int num_tokens = array_token->getNumValues();

    if (num_tokens < 1) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

      return;
    }

    PSViewToken *sub_token = array_token->getValue(1);

    if (! sub_token->isName()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSViewNameToken *name_token = (PSViewNameToken *) sub_token;

    const PSViewName &color_space = name_token->getValue();

    if (color_space.compare(
          mgr->getPSView()->getGStateMgr()->getPatternColorSpace()) == 0) {
      if (num_tokens < 2) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      sub_token = array_token->getValue(2);

      if (! sub_token->isName()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }

      PSViewNameToken *name_token = (PSViewNameToken *) sub_token;

      const PSViewName &color_space1 = name_token->getValue();

      if (color_space1.compare(
            mgr->getPSView()->getGStateMgr()->getCMYKColorSpace()) != 0 &&
          color_space1.compare(
            mgr->getPSView()->getGStateMgr()->getRGBColorSpace ()) != 0 &&
          color_space1.compare(
            mgr->getPSView()->getGStateMgr()->getGrayColorSpace()) != 0) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

        return;
      }

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->setColorSpace(color_space1);
      gstate_token->setPatternColor(true);
    }
    else {
      if (num_tokens != 1) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      if (color_space.compare(
            mgr->getPSView()->getGStateMgr()->getCMYKColorSpace()) != 0 &&
          color_space.compare(
            mgr->getPSView()->getGStateMgr()->getRGBColorSpace ()) != 0 &&
          color_space.compare(
            mgr->getPSView()->getGStateMgr()->getGrayColorSpace()) != 0) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

        return;
      }

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->setColorSpace(color_space);
      gstate_token->setPatternColor(false);
    }
  }
  else {
    PSViewNameToken *name_token = (PSViewNameToken *) token;

    const PSViewName &color_space = name_token->getValue();

    if (color_space.compare(
          mgr->getPSView()->getGStateMgr()->getCMYKColorSpace()) != 0 &&
        color_space.compare(
          mgr->getPSView()->getGStateMgr()->getRGBColorSpace ()) != 0  &&
        color_space.compare(
          mgr->getPSView()->getGStateMgr()->getGrayColorSpace()) != 0) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

      return;
    }

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->setColorSpace(color_space);
    gstate_token->setPatternColor(false);
  }
}

void
PSViewOperatorMgr::
setDashOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isArray() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) token1;

  PSVinteger num_tokens = array_token->getNumValues();

  int zero_count = 0;

  vector<double> dash_array;

  dash_array.resize(num_tokens);

  for (int i = 1; i <= num_tokens; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    dash_array[i - 1] = sub_token->getRealValue();

    if (dash_array[i - 1] < 0.0) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_LIMIT_CHECK);

      return;
    }

    if (dash_array[i - 1] == 0.0)
      zero_count++;
  }

  if (zero_count > 0 && zero_count == num_tokens) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_LIMIT_CHECK);

    return;
  }

  double dash_offset = token2->getRealValue();

  if (dash_offset < 0.0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_LIMIT_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setDashPattern(&dash_array[0], (int) num_tokens, dash_offset);
}

void
PSViewOperatorMgr::
setFilePositionOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger pos = token2->getIntegerValue();

  PSViewFileToken *file_token1 = (PSViewFileToken *) token1;

  file_token1->setPosition(pos);
}

void
PSViewOperatorMgr::
setFlatOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal flat = token->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setFlat(flat);
}

void
PSViewOperatorMgr::
setFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewDictionaryToken *dict_token = (PSViewDictionaryToken *) token;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setFont(dict_token);
}

void
PSViewOperatorMgr::
setGlobalOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isBoolean()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVboolean boolean = token->getBooleanValue();

  mgr->getPSView()->getMemoryMgr()->setGlobal(boolean);
}

void
PSViewOperatorMgr::
setGrayOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal gray = token->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setColorSpace(mgr->getPSView()->getGStateMgr()->getGrayColorSpace());

  gstate_token->setPatternColor(false);

  gstate_token->setGray(gray);
}

void
PSViewOperatorMgr::
setGStateOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isGState()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = (PSViewGStateToken *) token;

  mgr->getPSView()->getGStateTokenMgr()->setCurrent(gstate_token);
}

void
PSViewOperatorMgr::
setHSBColorOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() || ! token3->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal hue        = token1->getRealValue();
  PSVreal saturation = token2->getRealValue();
  PSVreal brightness = token3->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setColorSpace(mgr->getPSView()->getGStateMgr()->getRGBColorSpace());

  gstate_token->setPatternColor(false);

  gstate_token->setHSBColor(CHSB(hue, saturation, brightness));
}

void
PSViewOperatorMgr::
setLineCapOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVinteger line_cap = token->getIntegerValue();

  if (line_cap < 0 || line_cap > 2) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setLineCap((CLineCapType) (line_cap + 1));
}

void
PSViewOperatorMgr::
setLineJoinOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSVinteger line_join = token->getIntegerValue();

  if (line_join < 0 || line_join > 2) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setLineJoin((CLineJoinType) (line_join + 1));
}

void
PSViewOperatorMgr::
setLineWidthOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal line_width = token->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setLineWidth(line_width);
}

void
PSViewOperatorMgr::
setMatrixOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  CAutoPtr<CMatrix2D> matrix;

  matrix = token->getMatrix();

  if (matrix == NULL)
    return;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setCTMMatrix(matrix);
}

void
PSViewOperatorMgr::
setMitreLimitOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal mitre_limit = token->getRealValue();

  if (mitre_limit < 1.0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setMitreLimit(mitre_limit);
}

void
PSViewOperatorMgr::
setPackingOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isBoolean()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVboolean boolean = token->getBooleanValue();

  mgr->getPSView()->getTokenMgr()->setPacking(boolean);
}

void
PSViewOperatorMgr::
setPatternOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict_token = (PSViewDictionaryToken *) token;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setPattern(dict_token);
}

void
PSViewOperatorMgr::
setRGBColorOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL || token3 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber() || ! token3->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal red   = token1->getRealValue();
  PSVreal green = token2->getRealValue();
  PSVreal blue  = token3->getRealValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setColorSpace(mgr->getPSView()->getGStateMgr()->getRGBColorSpace());

  gstate_token->setPatternColor(false);

  gstate_token->setRGBColor(CRGBA(red, green, blue));
}

void
PSViewOperatorMgr::
setStrokeAdjustOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isBoolean()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVboolean boolean = token->getBooleanValue();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setStrokeAdjust(boolean);
}

void
PSViewOperatorMgr::
setUnderColorRemovalOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isProcedure()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->setUnderColorRemoval(token);
}

void
PSViewOperatorMgr::
showOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewStringToken *string_token = (PSViewStringToken *) token;

  string str = string_token->toString();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->show(str);
}

void
PSViewOperatorMgr::
showPageOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->showPage();
}

void
PSViewOperatorMgr::
sinOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real = token->getRealValue();

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), sin(CMathGen::DegToRad(real)));

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
sqrtOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVreal real = token->getRealValue();

  if (real < 0.0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), sqrt(real));

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
srandOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  mgr->setRandomSeed(token->getIntegerValue());

  COSRand::srand((long) mgr->getRandomSeed());
}

void
PSViewOperatorMgr::
stackOp(PSViewOperatorMgr *mgr)
{
  int num_stack = mgr->getPSView()->getOperandStack()->size();

  for (int i = num_stack; i >= 1; i--) {
    PSViewToken *token = mgr->getPSView()->getOperandStack()->peek(i);

    const string &str = token->toString();

    CStrUtil::printf("%s\n", str.c_str());
  }
}

void
PSViewOperatorMgr::
statusOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile() && ! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isFile()) {
    PSViewFileToken *file_token = (PSViewFileToken *) token;

    if (file_token->isValid())
      trueOp(mgr);
    else
      falseOp(mgr);
  }
  else {
    PSViewStringToken *string_token = (PSViewStringToken *) token;

    string filename = string_token->toString();

    struct stat file_stat;

    int error = stat(filename.c_str(), &file_stat);

    if (error == 0) {
      PSViewIntegerToken *token1 = new PSViewIntegerToken(mgr->getPSView(), 1);

      mgr->getPSView()->getOperandStack()->push(token1);

      token1 = new PSViewIntegerToken(mgr->getPSView(), file_stat.st_size);

      mgr->getPSView()->getOperandStack()->push(token1);

      token1 = new PSViewIntegerToken(mgr->getPSView(), file_stat.st_atime);

      mgr->getPSView()->getOperandStack()->push(token1);

      token1 = new PSViewIntegerToken(mgr->getPSView(), file_stat.st_ctime);

      mgr->getPSView()->getOperandStack()->push(token1);
    }

    if (error == 0)
      trueOp(mgr);
    else
      falseOp(mgr);
  }
}

void
PSViewOperatorMgr::
stopOp(PSViewOperatorMgr *mgr)
{
  int num = mgr->getPSView()->getOperandStack()->size();

  int i = 1;

  for ( ; i <= num; i++) {
    PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

    if (token->isOperator() && token->toString() == "stopped")
      break;
  }

  if (i <= num)
    return;

  PSViewNameToken *key = new PSViewNameToken(mgr->getPSView(), "handleerror");

  PSViewToken *value = mgr->getPSView()->getDictionaryMgr()->lookup(key);

  if (value->isNull())
    mgr->getPSView()->getErrorMgr()->defaultErrorHandler();
  else
    value->execute();
}

void
PSViewOperatorMgr::
stoppedOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSViewOperatorToken *token1 = new PSViewOperatorToken(mgr->getPSView(), "stopped");

  mgr->getPSView()->getOperandStack()->push(token1);

  token->execute();

  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();

  if (token2 != NULL && token2->isOperator() &&
      token2->toString() == "stopped")
    falseOp(mgr);
  else {
    if (token2 != NULL)
      mgr->getPSView()->getOperandStack()->push(token2);

    trueOp(mgr);
  }
}

void
PSViewOperatorMgr::
storeOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  PSViewDictionaryToken *dictionary =
    mgr->getPSView()->getDictionaryMgr()->lookupDictionary(token1);

  if (dictionary != NULL)
    dictionary->addValue(token1, token2);
  else
    mgr->getPSView()->getDictionaryMgr()->addToCurrent(token1, token2);
  }

void
PSViewOperatorMgr::
stringOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger length = token->getIntegerValue();

  PSViewStringToken *string_token = new PSViewStringToken(mgr->getPSView(), length);

  mgr->getPSView()->getOperandStack()->push(string_token);
}

void
PSViewOperatorMgr::
stringWidthOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewStringToken *string_token = (PSViewStringToken *) token;

  string str = string_token->toString();

  double x, y;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->stringWidth(str, &x, &y);

  PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), x);

  mgr->getPSView()->getOperandStack()->push(token1);

  token1 = new PSViewRealToken(mgr->getPSView(), y);

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
strokeOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->stroke();
}

void
PSViewOperatorMgr::
strokePathOp(PSViewOperatorMgr *mgr)
{
  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->strokePath();
}

void
PSViewOperatorMgr::
subOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber() || ! token2->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewToken *token;

  if (token1->isInteger() && token2->isInteger()) {
    PSVinteger result = token1->getIntegerValue() - token2->getIntegerValue();

    token = new PSViewIntegerToken(mgr->getPSView(), result);
  }
  else {
    PSVreal result = token1->getRealValue() - token2->getRealValue();

    token = new PSViewRealToken(mgr->getPSView(), result);
  }

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
systemDictOp(PSViewOperatorMgr *mgr)
{
  PSViewDictionaryToken *token = mgr->getPSView()->getDictionaryMgr()->getSystemDictionary();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
tokenOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isFile() && ! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  PSViewToken *token1;

  if (token->isFile()) {
    PSViewFileToken *file_token = (PSViewFileToken *) token;

    token1 = file_token->readToken();
  }
  else {
    PSViewStringToken *string_token = (PSViewStringToken *) token;

    string str = string_token->toString();

    PSVinteger pos = 0;

    token1 = mgr->readStringFileToken(str, &pos);

    if (token1 != NULL) {
      string_token->setBounds(pos + 1, str.size() - pos);

      mgr->getPSView()->getOperandStack()->push(token);
    }
  }

  if (token1 != NULL) {
    mgr->getPSView()->getOperandStack()->push(token1);
    trueOp(mgr);
  }
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
transformOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal x = token1->getRealValue();
    PSVreal y = token2->getRealValue();

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    CMatrix2D *matrix = gstate_token->getCTMMatrix();

    PSVreal x1, y1;

    matrix->multiplyPoint(x, y, &x1, &y1);

    token1 = new PSViewRealToken(mgr->getPSView(), x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
  else {
    CAutoPtr<CMatrix2D> matrix;

    matrix = token2->getMatrix();

    if (matrix == NULL)
      return;

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x = token0->getRealValue();
    PSVreal y = token1->getRealValue();

    PSVreal x1, y1;

    matrix->multiplyPoint(x, y, &x1, &y1);

    token1 = new PSViewRealToken(mgr->getPSView(), x1);
    token2 = new PSViewRealToken(mgr->getPSView(), y1);

    mgr->getPSView()->getOperandStack()->push(token1);
    mgr->getPSView()->getOperandStack()->push(token2);
  }
}

void
PSViewOperatorMgr::
translateOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token2->isNumber()) {
    PSVreal x = token1->getRealValue();
    PSVreal y = token2->getRealValue();

    CMatrix2D matrix;

    matrix.setTranslation(x, y);

    PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

    gstate_token->postMultiplyCTMMatrix(&matrix);
  }
  else {
    if (! token2->isMatrix()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSViewToken *token0 = mgr->getPSView()->getOperandStack()->pop();

    if (! token0->isNumber()) {
      mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return;
    }

    PSVreal x = token0->getRealValue();
    PSVreal y = token1->getRealValue();

    CMatrix2D matrix;

    matrix.setTranslation(x, y);

    token2->setMatrix(&matrix);

    mgr->getPSView()->getOperandStack()->push(token2);
  }
}

void
PSViewOperatorMgr::
trueOp(PSViewOperatorMgr *mgr)
{
  PSViewBooleanToken *token = new PSViewBooleanToken(mgr->getPSView(), true);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
truncateOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isNumber()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->isReal()) {
    PSVreal real = token->getRealValue();

    if (real >= 0)
      real = (double) ((long) real);
    else
      real = (double) ((long) real);

    PSViewRealToken *token1 = new PSViewRealToken(mgr->getPSView(), real);

    mgr->getPSView()->getOperandStack()->push(token1);
  }
  else {
    PSViewToken *token1 = token->dup();

    mgr->getPSView()->getOperandStack()->push(token1);
  }
}

void
PSViewOperatorMgr::
typeOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSViewToken *token1 = token->toName();

  mgr->getPSView()->getOperandStack()->push(token1);
}

void
PSViewOperatorMgr::
undefOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isDictionary()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewDictionaryToken *dictionary_token1 = (PSViewDictionaryToken *) token1;

  dictionary_token1->deleteValue(token2);
}

void
PSViewOperatorMgr::
undefineFontOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->undefineFont(token);
}

void
PSViewOperatorMgr::
undefineUserObjectOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSVinteger ind = token->getIntegerValue();

  if (ind < 0) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewDictionaryToken *dict = mgr->getPSView()->getDictionaryMgr()->getUserDictionary();

  PSViewNameToken *key = new PSViewNameToken(mgr->getPSView(), "UserObjects");

  PSViewToken *user_objects = dict->getValue(key);

  if (user_objects == NULL || ! user_objects->isArray()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

    return;
  }

  PSViewArrayToken *array_token = (PSViewArrayToken *) user_objects;

  PSVinteger len = array_token->getNumValues();

  if (ind >= len) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return;
  }

  PSViewNullToken *sub_token = new PSViewNullToken(mgr->getPSView());

  array_token->setValue(ind + 1, sub_token);

  delete key;
}

void
PSViewOperatorMgr::
userDictOp(PSViewOperatorMgr *mgr)
{
  PSViewDictionaryToken *token = mgr->getPSView()->getDictionaryMgr()->getUserDictionary();

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
userTimeOp(PSViewOperatorMgr *mgr)
{
  time_t real_time = time(NULL);

  int dt = (int) (real_time - mgr->getPSView()->getStartTime());

  PSViewToken *token = new PSViewIntegerToken(mgr->getPSView(), dt);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
versionOp(PSViewOperatorMgr *mgr)
{
  static string version = "1.0";

  PSViewStringToken *token = new PSViewStringToken(mgr->getPSView(), version);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
vmStatusOp(PSViewOperatorMgr *mgr)
{
  int depth, used, max;

  mgr->getPSView()->getMemoryMgr()->getStatus(&depth, &used, &max);

  PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), depth);

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewIntegerToken(mgr->getPSView(), used);

  mgr->getPSView()->getOperandStack()->push(token);

  token = new PSViewIntegerToken(mgr->getPSView(), max);

  mgr->getPSView()->getOperandStack()->push(token);
}

void
PSViewOperatorMgr::
wcheckOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (! token->isArray() && ! token->isPackedArray() &&
      ! token->isDictionary() && ! token->isFile() && ! token->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token->getWritable())
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
whereOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  PSViewDictionaryToken *token1 = mgr->getPSView()->getDictionaryMgr()->lookupDictionary(token);

  if (token1 != NULL) {
    mgr->getPSView()->getOperandStack()->push(token1);

    trueOp(mgr);
  }
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
widthShowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token4 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token3 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL ||
      token3 == NULL || token4 == NULL)
    return;

  if (! token1->isNumber () || ! token2->isNumber() ||
      ! token3->isInteger() || ! token4->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double cx = token1->getRealValue();
  double cy = token2->getRealValue();

  int c = token3->getIntegerValue();

  PSViewStringToken *string_token4 = (PSViewStringToken *) token4;

  string str = string_token4->toString();

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  gstate_token->widthShow(cx, cy, c, str);
}

void
PSViewOperatorMgr::
writeOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isInteger()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken *file_token1 = (PSViewFileToken *) token1;

  PSVinteger c = token2->getIntegerValue();

  file_token1->writeChar((PSVchar) c);
}

void
PSViewOperatorMgr::
writeHexStringOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken   *file_token1   = (PSViewFileToken   *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger length = string_token2->getLength();

  for (PSVinteger i = 1; i <= length; i++) {
    PSVinteger c = string_token2->getChar(i);

    char hex_string[16];

    sprintf(hex_string, "%02x", (int) c);

    file_token1->writeChar(hex_string[0]);
    file_token1->writeChar(hex_string[1]);
  }
}

void
PSViewOperatorMgr::
writeStringOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isFile() || ! token2->isString()) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewFileToken   *file_token1   = (PSViewFileToken   *) token1;
  PSViewStringToken *string_token2 = (PSViewStringToken *) token2;

  PSVinteger length = string_token2->getLength();

  for (PSVinteger i = 1; i <= length; i++) {
    PSVinteger c = string_token2->getChar(i);

    file_token1->writeChar((PSVchar) c);
  }
}

void
PSViewOperatorMgr::
xcheckOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token = mgr->getPSView()->getOperandStack()->pop();

  if (token == NULL)
    return;

  if (token->isExecutable())
    trueOp(mgr);
  else
    falseOp(mgr);
}

void
PSViewOperatorMgr::
xorOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if ((! token1->isBoolean() && ! token1->isInteger()) ||
      (! token2->isBoolean() && ! token2->isInteger()) ||
      ! token1->isType(token2->getType())) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  if (token1->isBoolean()) {
    PSVboolean boolean1 = token1->getBooleanValue();
    PSVboolean boolean2 = token2->getBooleanValue();

    if (boolean1 ^ boolean2)
      trueOp(mgr);
    else
      falseOp(mgr);
  }
  else {
    PSVinteger integer1 = token1->getIntegerValue();
    PSVinteger integer2 = token2->getIntegerValue();

    PSViewIntegerToken *token = new PSViewIntegerToken(mgr->getPSView(), integer1 ^ integer2);

    mgr->getPSView()->getOperandStack()->push(token);
  }
}

void
PSViewOperatorMgr::
xshowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() ||
      (! token2->isArray() && ! token2->isString())) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double current_x, current_y;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  bool flag = gstate_token->getCurrentPoint(&current_x, &current_y);

  if (! flag) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);

    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

  if (token2->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token2;

    PSVinteger num_tokens = array_token->getNumValues();

    vector<double> x;

    x.resize(num_tokens);

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }

      x[i - 1] = sub_token->getRealValue();
    }

    string str = " ";

    PSVinteger length = string_token1->getLength();

    for (int i = 1; i <= length; i++) {
      if (i > num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

        return;
      }

      str[0] = string_token1->getChar(i);

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->moveTo(current_x, current_y);

      gstate_token->show(str);

      current_x += x[i - 1];
    }
  }
  else
    CStrUtil::eprintf("PSView: NumString not supported for XShow\n");
}

void
PSViewOperatorMgr::
xyshowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() ||
      (! token2->isArray() && ! token2->isString())) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  double current_x, current_y;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  bool flag = gstate_token->getCurrentPoint(&current_x, &current_y);

  if (! flag) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);

    return;
  }

  if (token2->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token2;

    PSVinteger num_tokens = array_token->getNumValues();

    vector<double> x, y;

    x.resize(num_tokens/2 + 1);
    y.resize(num_tokens/2 + 1);

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

        return;
      }

      if (i & 1)
        x[i/2    ] = sub_token->getRealValue();
      else
        y[i/2 - 1] = sub_token->getRealValue();
    }

    string str = " ";

    PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

    PSVinteger length = string_token1->getLength();

    for (int i = 1; i <= length; i++) {
      if (2*(i - 1) > num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
        return;
      }

      str[0] = string_token1->getChar(i);

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->moveTo(current_x, current_y);

      gstate_token->show(str);

      current_x += x[i - 1];
      current_y += y[i - 1];
    }
  }
  else
    CStrUtil::eprintf("PSView: NumString not supported for XYShow\n");
}

void
PSViewOperatorMgr::
yshowOp(PSViewOperatorMgr *mgr)
{
  PSViewToken *token2 = mgr->getPSView()->getOperandStack()->pop();
  PSViewToken *token1 = mgr->getPSView()->getOperandStack()->pop();

  if (token1 == NULL || token2 == NULL)
    return;

  if (! token1->isString() || (! token2->isArray() && ! token2->isString())) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
    return;
  }

  double current_x, current_y;

  PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

  bool flag = gstate_token->getCurrentPoint(&current_x, &current_y);

  if (! flag) {
    mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_NO_CURRENT_POINT);
    return;
  }

  PSViewStringToken *string_token1 = (PSViewStringToken *) token1;

  if (token2->isArray()) {
    PSViewArrayToken *array_token = (PSViewArrayToken *) token2;

    PSVinteger num_tokens = array_token->getNumValues();

    vector<double> y;

    y.resize(num_tokens);

    for (int i = 1; i <= num_tokens; i++) {
      PSViewToken *sub_token = array_token->getValue(i);

      if (! sub_token->isNumber()) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);
        return;
      }

      y[i - 1] = sub_token->getRealValue();
    }

    string str = " ";

    PSVinteger length = string_token1->getLength();

    for (int i = 1; i <= length; i++) {
      if (i > num_tokens) {
        mgr->getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
        return;
      }

      str[0] = string_token1->getChar(i);

      PSViewGStateToken *gstate_token = mgr->getPSView()->getGStateTokenMgr()->getCurrent();

      gstate_token->moveTo(current_x, current_y);

      gstate_token->show(str);

      current_y += y[i - 1];
    }
  }
  else
    CStrUtil::eprintf("PSView: NumString not supported for XShow\n");
}

void
PSViewOperatorMgr::
unimplementedOp(PSViewOperatorMgr *mgr)
{
  CStrUtil::eprintf("PSView: Operator Unimplemented\n");

  CStrUtil::eprintf("  Last Executed ");

  PSViewToken *token = mgr->getPSView()->getTokenMgr()->getLastExecuteToken();

  token->print();

  CStrUtil::printf("\n");
}

void
PSViewOperatorMgr::
charPathFillOp(PSViewOperatorMgr *)
{
}

void
PSViewOperatorMgr::
charPathStrokeTrueOp(PSViewOperatorMgr *)
{
  CStrUtil::eprintf(
    "PSView: Conversion from Stroke Path to Fill Path Unimplemented\n");
}

void
PSViewOperatorMgr::
charPathStrokeFalseOp(PSViewOperatorMgr *)
{
}

PSViewToken *
PSViewOperatorMgr::
readStringFileToken(const string &str, PSVinteger *pos)
{
  PSViewStringFileToken *token = new PSViewStringFileToken(getPSView(), str.substr(*pos));

  PSViewToken *token1 = token->readToken();

  *pos += token->getFile()->bytesUsed();

  delete token;

  return token1;
}

//---------------

PSViewOperator::
PSViewOperator(PSViewOperatorMgr *mgr, const string &name,
               PSViewOperatorProc proc) :
 mgr_(mgr), name_(mgr_->getPSView()->getNameMgr()->getName(name)),
 proc_(proc) {
}

int
PSViewOperator::
compare(PSViewOperator *opr)
{
  return name_.compare(opr->name_);
}

void
PSViewOperator::
invoke()
{
  (*proc_)(mgr_);
}
##concat##CPSViewOperatorToken.cpp
#include <CPSViewI.h>

PSViewOperatorToken::
PSViewOperatorToken(CPSView *psview, const string &name) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_OPERATOR,
             PSVIEW_TOKEN_NON_COMPOSITE, PSVIEW_TOKEN_EXECUTABLE,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 operator_  ()
{
  operator_ = psview_->getOperatorMgr()->lookup(name);
}

PSViewOperatorToken::
PSViewOperatorToken(CPSView *psview, PSViewOperator *opr) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_OPERATOR,
             PSVIEW_TOKEN_NON_COMPOSITE, PSVIEW_TOKEN_EXECUTABLE,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 operator_  ()
{
  operator_ = opr;
}

PSViewOperatorToken::
PSViewOperatorToken(const PSViewOperatorToken &operator_token) :
 PSViewToken(operator_token),
 operator_  (operator_token.operator_)
{
}

PSViewOperatorToken::
~PSViewOperatorToken()
{
}

PSViewOperatorToken *
PSViewOperatorToken::
dup() const
{
  return new PSViewOperatorToken(*this);
}

int
PSViewOperatorToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewOperatorToken *operator_token = dynamic_cast<PSViewOperatorToken *>(token);

    return operator_->compare(operator_token->operator_);
  }
  else
    return type_ - token->getType();
}

void
PSViewOperatorToken::
executeToken()
{
  operator_->invoke();
}

const PSViewName &
PSViewOperatorToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewOperatorToken::
print()
{
  CStrUtil::printf("--%s--", operator_->getName().getString().c_str());
}

string
PSViewOperatorToken::
toString()
{
  return operator_->getName().getString();
}
##concat##CPSViewPackedArray.cpp
#include <CPSViewI.h>

PSViewPackedArray::
PSViewPackedArray(PSVinteger max_length) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(max_length);
}

PSViewPackedArray::
PSViewPackedArray(const PSViewPackedArray &array) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(array.tokens_);
}

PSViewPackedArray::
PSViewPackedArray(const PSViewPackedArray &array, PSVinteger n) :
 tokens_()
{
  tokens_ = new PSViewSharedToken(array.tokens_, n);
}

PSViewPackedArray::
~PSViewPackedArray()
{
}

int
PSViewPackedArray::
compare(PSViewPackedArray *array)
{
  int num_values1 = getNumValues();
  int num_values2 = array->getNumValues();

  if      (num_values1 > num_values2)
    return  1;
  else if (num_values1 < num_values2)
    return -1;

  for (int i = 1; i <= num_values1; ++i) {
    PSViewToken *token1 = getValue(i);
    PSViewToken *token2 = array->getValue(i);

    int cmp = token1->compare(token2);

    if (cmp != 0)
      return cmp;
  }

  return 0;
}

PSVinteger
PSViewPackedArray::
getNumValues()
{
  return tokens_->getLen();
}

PSViewToken *
PSViewPackedArray::
getValue(int i)
{
  return tokens_->getValue(i - 1);
}

void
PSViewPackedArray::
setValue(int i, PSViewToken *value)
{
  tokens_->setValue(i - 1, value);
}
##concat##CPSViewPackedArrayToken.cpp
#include <CPSViewI.h>

PSViewPackedArrayToken::
PSViewPackedArrayToken(CPSView *psview, PSVinteger max_length) :
 PSViewToken  (psview, PSVIEW_TOKEN_TYPE_PACKED_ARRAY,
               PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
               PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 packed_array_()
{
  packed_array_ = new PSViewPackedArray(max_length);
}

PSViewPackedArrayToken::
PSViewPackedArrayToken(const PSViewPackedArrayToken &packed_array_token) :
 PSViewToken  (packed_array_token),
 packed_array_()
{
  packed_array_ = new PSViewPackedArray(*packed_array_token.packed_array_);
}

PSViewPackedArrayToken::
~PSViewPackedArrayToken()
{
}

PSViewPackedArrayToken *
PSViewPackedArrayToken::
dup() const
{
  return new PSViewPackedArrayToken(*this);
}

int
PSViewPackedArrayToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewPackedArrayToken *packed_array_token = dynamic_cast<PSViewPackedArrayToken *>(token);

    return packed_array_->compare(packed_array_token->packed_array_);
  }
  else
    return type_ - token->getType();
}

PSVinteger
PSViewPackedArrayToken::
getNumValues()
{
  return packed_array_->getNumValues();
}

PSViewToken *
PSViewPackedArrayToken::
getValue(int i)
{
  return packed_array_->getValue(i);
}

void
PSViewPackedArrayToken::
setValue(int i, PSViewToken *token)
{
  packed_array_->setValue(i, token);
}

void
PSViewPackedArrayToken::
executeToken()
{
  psview_->getOperandStack()->push(this);
}

const PSViewName &
PSViewPackedArrayToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewPackedArrayToken::
print()
{
  CStrUtil::printf("[");

  for (int i = 1; i <= packed_array_->getNumValues(); i++) {
    if (i > 1)
      CStrUtil::printf(" ");

    PSViewToken *token = packed_array_->getValue(i);

    token->print();
  }

  CStrUtil::printf("]");
}

string
PSViewPackedArrayToken::
toString()
{
  return "--nostringval--";
}
##concat##CPSViewPath.cpp
#include <CPSViewI.h>
#include <CFuncs.h>
#include <CLineList2D.h>
#include <CTriangle2D.h>
#include <CFreeType.h>
#include <CArcToBezier.h>
#include <CBezierToLine.h>
#include <algorithm>

class PSViewPathCharRenderer : public CFreeTypePathRenderer {
 public:
  PSViewPathCharRenderer(PSViewPath *path, const CMatrix2D &m, const CPoint2D &p) :
   path_(path), m_(m), p_(p), scale_(1.0) {
    CFontPtr font = CFreeTypeMgrInst->getFont();

    scale_ = 1.0/font->getSize();
  }

  void init() {
    path_->init();
  }

  void moveTo(const CPoint2D &p) {
    CPoint2D tp = adjustPoint(p);

    path_->moveTo(tp);
  }

  void lineTo(const CPoint2D &p) {
    CPoint2D tp = adjustPoint(p);

    path_->lineTo(tp);
  }

  void bezier2To(const CPoint2D &p1, const CPoint2D &p2) {
    CPoint2D tp1 = adjustPoint(p1);
    CPoint2D tp2 = adjustPoint(p2);

    path_->bezier2To(tp1, tp2);
  }

  void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    CPoint2D tp1 = adjustPoint(p1);
    CPoint2D tp2 = adjustPoint(p2);
    CPoint2D tp3 = adjustPoint(p3);

    path_->bezier3To(tp1, tp2, tp3);
  }

  void close() {
    path_->close();
  }

  void stroke() { }

  void fill() { }

  CPoint2D adjustPoint(const CPoint2D &p) {
    CPoint2D tp;

    m_.multiplyPoint(p*scale_, tp);

    return p_ + tp;
  }

 private:
  PSViewPath      *path_;
  const CMatrix2D &m_;
  CPoint2D         p_;
  double           scale_;

 private:
  PSViewPathCharRenderer(PSViewPathCharRenderer &rhs);
  PSViewPathCharRenderer &operator=(PSViewPathCharRenderer &rhs);
};

class PSViewPathBBoxVisitor : public PSViewPathVisitor {
 public:
  PSViewPathBBoxVisitor() :
   bbox_() {
  }

 ~PSViewPathBBoxVisitor() { }

  void moveTo(const CPoint2D &p) {
    bbox_ += p;
  }

  void lineTo(const CPoint2D &p) {
    bbox_ += p;
  }

  void bezier2To(const CPoint2D &p1, const CPoint2D &p2) {
    bbox_ += p1;
    bbox_ += p2;
  }

  void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    bbox_ += p1;
    bbox_ += p2;
    bbox_ += p3;
  }

  void arcTo(const CPoint2D &c, double xr, double yr, double theta, double delta) {
    vector<C3Bezier2D> beziers;

    CArcToBezier::ArcToBeziers(c.x, c.y, xr, yr, theta, theta + delta, beziers);

    uint num_beziers = beziers.size();

    for (uint i = 0; i < num_beziers; ++i) {
      const C3Bezier2D &bezier = beziers[i];

      bezier3To(bezier.getControlPoint1(), bezier.getControlPoint2(), bezier.getLastPoint());
    }

#if 0
    CMathGeom2D::EllipsePointAtAngle(c.x, c.y, xr, yr, theta        , &x1, &y1);
    CMathGeom2D::EllipsePointAtAngle(c.x, c.y, xr, yr, theta + delta, &x2, &y2);

    bbox_ += CPoint2D(x1, y1);
    bbox_ += CPoint2D(x2, y2);

    double a1 = CMathGen::RadToDeg(theta);
    double a2 = CMathGen::RadToDeg(theta + delta);

    if (a1 < 0) a1 += 360; if (a1 > 360) a1 -= 360;
    if (a2 < 0) a2 += 360; if (a2 > 360) a2 -= 360;

    double da = 0.0;

    if      (a2 - a1 > 270) da = (a2 - a1)/8;
    else if (a2 - a1 > 180) da = (a2 - a1)/6;
    else if (a2 - a1 >  90) da = (a2 - a1)/4;
    else                    da = (a2 - a1)/2;

    for (double a = a1 + da; a < a2; a += da) {
      double x, y;

      CMathGeom2D::EllipsePointAtAngle(c.x, c.y, xr, yr, CMathGen::DegToRad(a), &x, &y);

      bbox_ += CPoint2D(x, y);
    }
#endif
  }

  void close() {
  }

  const CBBox2D &getBBox() const { return bbox_; }

 private:
  CBBox2D bbox_;
};

class PSViewPathFlattenVisitor : public PSViewPathVisitor {
 public:
  PSViewPathFlattenVisitor() :
   flatPath_() {
  }

 ~PSViewPathFlattenVisitor() { }

  void moveTo(const CPoint2D &p) {
    flatPath_.moveTo(p);
  }

  void lineTo(const CPoint2D &p) {
    flatPath_.lineTo(p);
  }

  void bezier2To(const CPoint2D &p1, const CPoint2D &p2) {
    CPoint2D p;

    flatPath_.getCurrentPoint(p);

    C2Bezier2D bezier(p, p1, p2);

    vector<CPoint2D> points;

    CBezierToLine b_to_l;

    b_to_l.toLines(bezier, points);

    uint num_points = points.size();

    for (uint i = 1; i < num_points; ++i)
      flatPath_.lineTo(points[i]);
  }

  void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) {
    CPoint2D p;

    flatPath_.getCurrentPoint(p);

    C3Bezier2D bezier(p, p1, p2, p3);

    vector<CPoint2D> points;

    CBezierToLine b_to_l;

    b_to_l.toLines(bezier, points);

    uint num_points = points.size();

    for (uint i = 1; i < num_points; ++i)
      flatPath_.lineTo(points[i]);
  }

  void arcTo(const CPoint2D &c, double xr, double yr, double theta, double delta) {
    vector<C3Bezier2D> beziers;

    CArcToBezier::ArcToBeziers(c.x, c.y, xr, yr, theta, theta + delta, beziers);

    uint num_beziers = beziers.size();

    for (uint i = 0; i < num_beziers; ++i) {
      const C3Bezier2D &bezier = beziers[i];

      bezier3To(bezier.getControlPoint1(), bezier.getControlPoint2(), bezier.getLastPoint());
    }
  }

  void close() {
    flatPath_.close();
  }

  const PSViewPath &getPath() const { return flatPath_; }

 private:
  PSViewPath flatPath_;
};

//-------

PSViewPath::
PSViewPath() :
 parts_      (),
 closed_     (false),
 start_      (0,0),
 current_    (0,0),
 current_set_(false)
{
}

PSViewPath::
PSViewPath(const PSViewPath &path) :
 parts_      (),
 closed_     (path.closed_),
 start_      (path.start_),
 current_    (path.current_),
 current_set_(path.current_set_)
{
  PartList::const_iterator p1, p2;

  for (p1 = path.parts_.begin(), p2 = path.parts_.end(); p1 != p2; ++p1)
    parts_.push_back((*p1)->dup());
}

PSViewPath::
~PSViewPath()
{
  reset();
}

PSViewPath &
PSViewPath::
operator=(const PSViewPath &path)
{
  reset();

  PartList::const_iterator p1, p2;

  for (p1 = path.parts_.begin(), p2 = path.parts_.end(); p1 != p2; ++p1)
    parts_.push_back((*p1)->dup());

  closed_      = path.closed_;
  start_       = path.start_;
  current_     = path.current_;
  current_set_ = path.current_set_;

  return *this;
}

PSViewPath *
PSViewPath::
dup() const
{
  return new PSViewPath(*this);
}

void
PSViewPath::
init()
{
  reset();
}

void
PSViewPath::
reset()
{
  std::for_each(parts_.begin(), parts_.end(), CDeletePointer());

  parts_.clear();

  closed_      = false;
  current_set_ = false;
}

bool
PSViewPath::
moveTo(const CPoint2D &p)
{
  uint numParts = parts_.size();

  if (numParts > 0 && parts_[numParts - 1]->getId() == PSVIEW_PATH_MOVE_TO) {
    delete parts_[numParts - 1];

    parts_.pop_back();
  }

  parts_.push_back(new PSViewPathMoveTo(p));

  closed_      = false;
  start_       = p;
  current_     = start_;
  current_set_ = true;

  return true;
}

bool
PSViewPath::
rmoveTo(const CPoint2D &p)
{
  if (current_set_)
    return moveTo(current_ + p);
  else
    return moveTo(p);
}

bool
PSViewPath::
lineTo(const CPoint2D &p)
{
  if (! current_set_)
    return moveTo(p);

  if (closed_)
    moveTo(start_);

  parts_.push_back(new PSViewPathLineTo(p));

  closed_  = false;
  current_ = p;

  return true;
}

bool
PSViewPath::
rlineTo(const CPoint2D &p)
{
  if (current_set_)
    return lineTo(current_ + p);
  else
    return moveTo(p);
}

bool
PSViewPath::
bezier2To(const CPoint2D &p1, const CPoint2D &p2)
{
  if (! current_set_)
    moveTo(CPoint2D(0, 0));

  parts_.push_back(new PSViewPathBezier2To(p1, p2));

  closed_  = false;
  current_ = p2;

  return true;
}

bool
PSViewPath::
rbezier2To(const CPoint2D &p1, const CPoint2D &p2)
{
  if (! current_set_)
    bezier2To(p1, p2);

  bezier2To(p1 + current_, p2 + current_);

  return true;
}

bool
PSViewPath::
bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3)
{
  if (! current_set_)
    moveTo(CPoint2D(0, 0));

  parts_.push_back(new PSViewPathBezier3To(p1, p2, p3));

  closed_  = false;
  current_ = p3;

  return true;
}

bool
PSViewPath::
rbezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3)
{
  if (! current_set_)
    bezier3To(p1, p2, p3);

  bezier3To(p1 + current_, p2 + current_, p3 + current_);

  return true;
}

bool
PSViewPath::
arc(const CPoint2D &c, double xr, double yr, double angle1, double angle2)
{
  double a1 = CMathGen::RadToDeg(angle1);
  double a2 = CMathGen::RadToDeg(angle2);

  int    fa, fs;
  double x0, y0, x1, y1;

  CMathGeom2D::ConvertToSVGArc(c.x, c.y, xr, yr, a1, a2 - a1, 0.0,
                               &x0, &y0, &x1, &y1, &fa, &fs);

  if (! current_set_)
    moveTo(CPoint2D(x0, y0));

  parts_.push_back(new PSViewPathArcTo(c, xr, yr, angle1, angle2 - angle1));

  closed_  = false;
  current_ = CPoint2D(x1, y1);

  return true;
}

bool
PSViewPath::
arcN(const CPoint2D &c, double xr, double yr, double angle1, double angle2)
{
  double a1 = CMathGen::RadToDeg(angle1);
  double a2 = CMathGen::RadToDeg(angle2);

  int    fa, fs;
  double x0, y0, x1, y1;

  CMathGeom2D::ConvertToSVGArc(c.x, c.y, xr, yr, a1, a1 - a2, 0.0,
                               &x0, &y0, &x1, &y1, &fa, &fs);

  if (! current_set_)
    moveTo(CPoint2D(x0, y0));

  parts_.push_back(new PSViewPathArcTo(c, xr, yr, angle1, angle1 - angle2));

  closed_  = false;
  current_ = CPoint2D(x1, y1);

  return true;
}

bool
PSViewPath::
arcTo(const CPoint2D &p1, const CPoint2D &p2, double xr, double yr)
{
  if (! current_set_)
    moveTo(p1);

  CPoint2D p0(current_);

  double x[3] = { p0.x, p1.x, p2.x };
  double y[3] = { p0.y, p1.y, p2.y };

  CLineList2D path(x, y, 3);

  double xc, yc, xt1, yt1, xt2, yt2;

  bool flag = path.arcThrough(xr, yr, &xc, &yc, &xt1, &yt1, &xt2, &yt2);

  if (flag) {
    if (xt1 != p0.x || yt1 != p0.y)
      lineTo(CPoint2D(xt1, yt1));

    CTriangle2D triangle(p0, p1, p2);

    if (triangle.orientation() == 1)
      arc (CPoint2D(xc, yc), xr, yr, atan2(xt1 - xc, yt1 - yc), atan2(xt2 - xc, yt2 - yc));
    else
      arcN(CPoint2D(xc, yc), xr, yr, atan2(xt1 - xc, yt1 - yc), atan2(xt2 - xc, yt2 - yc));
  }
  else
    lineTo(p1);

  return true;
}

bool
PSViewPath::
addChar(int c, const CMatrix2D &m, double *x, double *y)
{
  PSViewPathCharRenderer renderer(this, m, CPoint2D(*x, *y));

  double x1 = 0.0, y1 = 0.0;

  CFreeTypeMgrInst->pathChar(&renderer, char(c), &x1, &y1);

  CPoint2D tp = renderer.adjustPoint(CPoint2D(x1, y1));

  *x = tp.x;
  *y = tp.y;

  return true;
}

void
PSViewPath::
close()
{
  if (! current_set_ || closed_) {
    closed_ = true;
    return;
  }

  parts_.push_back(new PSViewPathClose);

  current_ = start_;
  closed_  = true;
}

bool
PSViewPath::
getCurrentPoint(CPoint2D &p)
{
  if (! current_set_)
    return false;

  p = current_;

  return true;
}

void
PSViewPath::
flatten()
{
  PSViewPathFlattenVisitor visitor;

  process(visitor);

  *this = visitor.getPath();
}

void
PSViewPath::
reverse()
{
  assert(false);
}

void
PSViewPath::
setStrokeAdjust(bool)
{
}

void
PSViewPath::
getBounds(double *xmin, double *ymin, double *xmax, double *ymax)
{
  PSViewPathBBoxVisitor visitor;

  process(visitor);

  const CBBox2D &bbox = visitor.getBBox();

  *xmin = bbox.getXMin();
  *ymin = bbox.getYMin();
  *xmax = bbox.getXMax();
  *ymax = bbox.getYMax();
}

void
PSViewPath::
process(PSViewPathVisitor &visitor)
{
  visitor.setPath(this);

  visitor.init();

  PartList::const_iterator p1, p2;

  for (p1 = parts_.begin(), p2 = parts_.end(); p1 != p2; ++p1)
    (*p1)->visit(visitor);

  visitor.term();
}

void
PSViewPath::
print(std::ostream &os) const
{
  PartList::const_iterator p1, p2;

  for (p1 = parts_.begin(), p2 = parts_.end(); p1 != p2; ++p1)
    (*p1)->print(os);
}
##concat##CPSViewRealToken.cpp
#include <CPSViewI.h>

PSViewRealToken::
PSViewRealToken(CPSView *psview, PSVreal value) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_REAL,
             PSVIEW_TOKEN_NON_COMPOSITE,
             PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 value_(value)
{
}

PSViewRealToken::
PSViewRealToken(const PSViewRealToken &real_token) :
 PSViewToken(real_token), value_(real_token.value_)
{
}

PSViewRealToken::
~PSViewRealToken()
{
}

PSViewRealToken *
PSViewRealToken::
dup() const
{
  return new PSViewRealToken(*this);
}

int
PSViewRealToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewRealToken *real_token = dynamic_cast<PSViewRealToken *>(token);

    if      (value_ == real_token->value_)
      return 0;
    else if (value_ > real_token->value_)
      return 1;
    else
      return -1;
  }
  else if (token->isType(PSVIEW_TOKEN_TYPE_INTEGER)) {
    PSViewIntegerToken *integer_token = dynamic_cast<PSViewIntegerToken *>(token);

    PSViewRealToken real_token1(psview_, integer_token->getValue());

    return compare(&real_token1);
  }
  else
    return type_ - token->getType();
}

void
PSViewRealToken::
executeToken()
{
  psview_->getOperandStack()->push(this);
}

const PSViewName &
PSViewRealToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewRealToken::
print()
{
  static char buffer[128];

  sprintf(buffer, "%g", value_);

  char *p = strchr(buffer, '.');

  if (p != NULL)
    CStrUtil::printf("%s", buffer);
  else
    CStrUtil::printf("%s.0", buffer);
}

string
PSViewRealToken::
toString()
{
  return CStrUtil::toString(value_);
}
##concat##CPSViewResource.cpp
#include <CPSViewI.h>

PSViewResourceMgr::
PSViewResourceMgr(CPSView *psview) :
 psview_   (psview),
 resources_()
{
}

PSViewResourceMgr::
~PSViewResourceMgr()
{
}

void
PSViewResourceMgr::
init()
{
}

PSViewToken *
PSViewResourceMgr::
findInstance(PSViewToken *key, const PSViewName &category)
{
  if (category.compare(getPSView()->getNameMgr()->getName("Font")) == 0) {
    PSViewGStateToken *gstate_token =
      getPSView()->getGStateTokenMgr()->getCurrent();

    PSViewToken *instance = gstate_token->findFont(key);

    if (instance == NULL) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED_RESOURCE);

      return NULL;
    }

    define(key, instance, category);

    return instance;
  }
  else {
    getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_UNDEFINED);

    return NULL;
  }
}

vector<PSViewResource *>
PSViewResourceMgr::
getResources(const PSViewName &category)
{
  vector<PSViewResource *> resources;

  int num = resources_.size();

  for (int i = 1; i <= num; i++)
    if (resources_[i]->getCategory().compare(category) == 0)
      resources.push_back(resources_[i]);

  return resources;
}

bool
PSViewResourceMgr::
checkInstance(PSViewToken *instance, const PSViewName &category)
{
  if (category.compare(getPSView()->getNameMgr()->getName("Font")) == 0) {
    if (! instance->isDictionary()) {
      getPSView()->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return false;
    }
  }

  return true;
}

PSViewToken *
PSViewResourceMgr::
lookupInstance(PSViewToken *key, const PSViewName &category)
{
  int num = resources_.size();

  for (int i = 0; i < num; i++) {
    if (resources_[i]->getCategory(). compare(category) == 0 &&
        resources_[i]->getKey     ()->compare(key     ) == 0)
      return resources_[i]->getInstance();
  }

  return NULL;
}

void
PSViewResourceMgr::
define(PSViewToken *key, PSViewToken *instance, const PSViewName &category)
{
  PSViewResource *resource =
    new PSViewResource(this, key, instance, category);

  resources_.push_back(resource);
}

//-------

PSViewResource::
PSViewResource(PSViewResourceMgr *mgr, PSViewToken *key,
               PSViewToken *instance, const PSViewName &category) :
 mgr_(mgr), key_(key), instance_(instance), category_(category)
{
}
##concat##CPSViewSave.cpp
#include <CPSViewI.h>

PSViewSave::
PSViewSave(void *data) :
 data_(data)
{
}

int
PSViewSave::
compare(PSViewSave *)
{
  return 1;
}

void *
PSViewSave::
getValue()
{
  return data_;
}
##concat##CPSViewSaveToken.cpp
#include <CPSViewI.h>

PSViewSaveToken::
PSViewSaveToken(CPSView *psview, void *data) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_SAVE,
             PSVIEW_TOKEN_NON_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 save_      ()
{
  save_ = new PSViewSave(data);
}

PSViewSaveToken::
PSViewSaveToken(const PSViewSaveToken &save_token) :
 PSViewToken(save_token),
 save_      ()
{
  save_ = new PSViewSave(*save_token.save_);
}

PSViewSaveToken::
~PSViewSaveToken()
{
}

PSViewSaveToken *
PSViewSaveToken::
dup() const
{
  return new PSViewSaveToken(*this);
}

int
PSViewSaveToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewSaveToken *save_token = dynamic_cast<PSViewSaveToken *>(token);

    return save_->compare(save_token->save_);
  }
  else
    return type_ - token->getType();
}

void *
PSViewSaveToken::
getValue()
{
  return save_->getValue();
}

void
PSViewSaveToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Save Missing\n");
}

const PSViewName &
PSViewSaveToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewSaveToken::
print()
{
  CStrUtil::printf("-save-");
}

string
PSViewSaveToken::
toString()
{
  return "--nostringval--";
}
##concat##CPSViewStack.cpp
#include <CPSViewI.h>

PSViewOperandStack::
PSViewOperandStack(CPSView *psview) :
 psview_       (psview),
 operand_stack_()
{
}

void
PSViewOperandStack::
push(PSViewToken *token)
{
  if (token == NULL)
    CTHROW("NULL Token");

  operand_stack_.push_back(token);

  if (psview_->getDebug()) {
    CStrUtil::printf("Stacking ");
    token->print();
    CStrUtil::printf("\n");

    CStrUtil::printf("Stack    ");
    print();

    CStrUtil::printf("\n");
  }
}

PSViewToken *
PSViewOperandStack::
pop()
{
  if (psview_->getErrorMgr()->getError())
    return NULL;

  int num_stack = operand_stack_.size();

  if (num_stack == 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return NULL;
  }

  PSViewToken *token = operand_stack_[num_stack - 1];

  operand_stack_.pop_back();

  return token;
}

void
PSViewOperandStack::
exch()
{
  int num_stack = operand_stack_.size();

  if (num_stack < 2) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return;
  }

  PSViewToken *token1 = operand_stack_[num_stack - 1];
  PSViewToken *token2 = operand_stack_[num_stack - 2];

  operand_stack_.pop_back();
  operand_stack_.pop_back();

  operand_stack_.push_back(token1);
  operand_stack_.push_back(token2);
}

void
PSViewOperandStack::
roll(int n, int m)
{
  int num_stack = operand_stack_.size();

  if (num_stack < n) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return;
  }

  m %= n;

  if (m > 0) {
    for (int i = 0; i < m; i++) {
      PSViewToken *token = operand_stack_[num_stack - 1];

      for (int j = 0; j < n - 1; j++)
        operand_stack_[num_stack - j - 1] = operand_stack_[num_stack - j - 2];

      operand_stack_[num_stack - n] = token;
    }
  }
  else {
    for (int i = 0; i < -m; i++) {
      PSViewToken *token = operand_stack_[num_stack - n];

      for (int j = n - 2; j >= 0; j--)
        operand_stack_[num_stack - j - 2] = operand_stack_[num_stack - j - 1];

      operand_stack_[num_stack - 1] = token;
    }
  }
}

int
PSViewOperandStack::
size()
{
  int num_stack = operand_stack_.size();

  return num_stack;
}

int
PSViewOperandStack::
countToMark()
{
  int num_stack = operand_stack_.size();

  for (int i = num_stack - 1; i >= 0; i--) {
    PSViewToken *token = operand_stack_[i];

    if (token->isMark())
      return num_stack - i - 1;
  }

  return -1;
}

PSViewToken *
PSViewOperandStack::
peek(int n)
{
  if (n <= 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  int num_stack = operand_stack_.size();

  if (n > num_stack) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return NULL;
  }

  PSViewToken *token = operand_stack_[n - 1];

  return token;
}

void
PSViewOperandStack::
clear()
{
  operand_stack_.clear();
}

void
PSViewOperandStack::
print()
{
  int num_stack = operand_stack_.size();

  for (int i = 0; i < num_stack; i++) {
    if (i > 0)
      CStrUtil::printf(" ");

    PSViewToken *token = operand_stack_[i];

    token->print();
  }
}

//-----------------

PSViewExecutionStack::
PSViewExecutionStack(CPSView *psview) :
 psview_         (psview),
 execution_stack_()
{
}

void
PSViewExecutionStack::
push(PSViewToken *token)
{
  if (token == NULL)
    CTHROW("NULL Token");

  execution_stack_.push_back(token);
}

PSViewToken *
PSViewExecutionStack::
pop()
{
  int num_stack = execution_stack_.size();

  if (num_stack == 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return NULL;
  }

  PSViewToken *token = execution_stack_[num_stack - 1];

  execution_stack_.pop_back();

  return token;
}

void
PSViewExecutionStack::
popToExit()
{
  int num_stack = execution_stack_.size();

  while (num_stack > 0) {
    PSViewToken *token = execution_stack_[num_stack - 1];

    execution_stack_.pop_back();

    if (token->isOperator()) {
      PSViewOperatorToken *operator_token = (PSViewOperatorToken *) token;

      PSViewOperator *opr = operator_token->getValue();

      if (opr->getString() == "exit")
        break;
    }

    num_stack = execution_stack_.size();
  }
}

int
PSViewExecutionStack::
size()
{
  int num_stack = execution_stack_.size();

  return num_stack;
}

int
PSViewExecutionStack::
countToMark()
{
  int num_stack = execution_stack_.size();

  for (int i = num_stack - 1; i >= 0; i--) {
    PSViewToken *token = execution_stack_[i];

    if (token->isMark())
      return num_stack - i - 1;
  }

  return -1;
}

PSViewToken *
PSViewExecutionStack::
peek(int n)
{
  if (n <= 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);
    return NULL;
  }

  int num_stack = execution_stack_.size();

  if (n > num_stack) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return NULL;
  }

  PSViewToken *token = execution_stack_[n - 1];

  return token;
}

void
PSViewExecutionStack::
clear()
{
  execution_stack_.clear();
}

void
PSViewExecutionStack::
print()
{
  int num_stack = execution_stack_.size();

  for (int i = 0; i < num_stack; i++) {
    PSViewToken *token = execution_stack_[i];

    token->print();
  }
}

//-----------------

PSViewGraphicsStack::
PSViewGraphicsStack(CPSView *psview) :
 psview_        (psview),
 graphics_stack_()
{
}

void
PSViewGraphicsStack::
push(PSViewGStateToken *token)
{
  if (token == NULL)
    CTHROW("NULL Token");

  graphics_stack_.push_back(token);
}

PSViewGStateToken *
PSViewGraphicsStack::
pop()
{
  int num_stack = graphics_stack_.size();

  if (num_stack == 0) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_STACK_UNDERFLOW);
    return NULL;
  }

  PSViewGStateToken *token = graphics_stack_[num_stack - 1];

  graphics_stack_.pop_back();

  return token;
}

int
PSViewGraphicsStack::
size()
{
  int num_stack = graphics_stack_.size();

  return num_stack;
}
##concat##CPSViewString.cpp
#include <CPSViewI.h>

PSViewString::
PSViewString(PSVinteger max_length) :
 mem_()
{
  mem_ = new PSViewSharedChar(max_length);
}

PSViewString::
PSViewString(const string &str) :
 mem_()
{
  mem_ = new PSViewSharedChar(str.size());

  setString(str);
}

PSViewString::
PSViewString(const PSViewString &str, PSVinteger pos) :
 mem_()
{
  mem_ = new PSViewSharedChar(str.mem_, pos - 1);
}

PSViewString::
PSViewString(const PSViewString &str, PSVinteger pos, PSVinteger len) :
 mem_()
{
  mem_ = new PSViewSharedChar(str.mem_, pos - 1, len);
}

PSViewString::
~PSViewString()
{
}

string
PSViewString::
getString() const
{
  const char *data = mem_->getData();

  return string(data, mem_->getLen());
}

int
PSViewString::
getLength() const
{
  return mem_->getLen();
}

int
PSViewString::
getChar(int pos) const
{
  return mem_->getValue(pos - 1);
}

void
PSViewString::
setString(const string &str)
{
  int len = str.size();

  mem_->setData((char *) str.c_str(), len);

  mem_->setBounds(0, len);
}

void
PSViewString::
setChar(int pos, char c)
{
  mem_->setValue(pos - 1, c);
}

void
PSViewString::
setChars(const string &str, int pos)
{
  mem_->setData(pos - 1, (char *) str.c_str(), str.size());
}

void
PSViewString::
setBounds(int pos, int len)
{
  mem_->setBounds(pos - 1, len);
}

PSVinteger
PSViewString::
isSubString(PSViewString *str)
{
  if (str->mem_->getLen() > mem_->getLen())
    return -1;

  for (int i = 0; i <= mem_->getLen() - str->mem_->getLen(); i++) {
    if (getChar(mem_->getStart() + i + 1) == str->getChar(1)) {
      int j = 1;

      for ( ; j < str->mem_->getLen(); j++) {
        if (getChar(mem_->getStart() + i + j + 1) != str->getChar(str->mem_->getStart() + j + 1))
          break;
      }

      if (j == str->mem_->getLen())
        return (i + 1);
    }
  }

  return -1;
}

PSViewString *
PSViewString::
subString(PSVinteger start, PSVinteger num_chars)
{
  return new PSViewString(*this, start, num_chars);
}

PSViewString *
PSViewString::
split(int n)
{
  PSViewString *str = new PSViewString(*this, n + 1);

  setBounds(1, n);

  return str;
}

int
operator==(const PSViewString &str1, const PSViewString &str2)
{
  return str1.compare(str2);
}

int
PSViewString::
compare(const PSViewString &str) const
{
  PSVinteger i = mem_->getStart();
  PSVinteger j = str.mem_->getStart();
  PSVinteger k = 0;

  for ( ; k < mem_->getLen() && k < str.mem_->getLen(); i++, j++, k++) {
    if (getChar(i + 1) != str.getChar(j + 1))
      break;
  }

  char c1 = '\0';
  char c2 = '\0';

  if (k < mem_->getLen())
    c1 = getChar(i + 1);

  if (k < str.mem_->getLen())
    c2 = str.getChar(j + 1);

  return (int) (c1 - c2);
}

int
PSViewString::
compareN(const PSViewString &str, PSVinteger n) const
{
  PSVinteger i = mem_->getStart();
  PSVinteger j = str.mem_->getStart();
  PSVinteger k = 0;

  for ( ; k < mem_->getLen() && k < str.mem_->getLen() && k < n;
          i++, j++, k++) {
    if (getChar(i + 1) != str.getChar(j + 1))
      break;
  }

  char c1 = '\0';
  char c2 = '\0';

  if (k < n && k < mem_->getLen())
    c1 = getChar(i + 1);

  if (k < n && k < str.mem_->getLen())
    c2 = str.getChar(j + 1);

  return (int) (c1 - c2);
}
##concat##CPSViewStringFile.cpp
#include <CPSViewI.h>

PSViewStringFile::
PSViewStringFile(CPSView *psview, const string &str) :
 PSViewFile  (psview),
 buffer_     (),
 buffer_pos_ (0),
 buffer_size_()
{
  uint len = str.size();

  buffer_.resize(len + 1);

  memcpy(&buffer_[0], str.c_str(), len + 1);

  buffer_size_ = len;
}

PSViewStringFile::
~PSViewStringFile()
{
}

int
PSViewStringFile::
compare(PSViewStringFile *)
{
  return 1;
}

void
PSViewStringFile::
flush()
{
}

bool
PSViewStringFile::
isReadable() const
{
  return true;
}

bool
PSViewStringFile::
isWritable() const
{
  return false;
}

bool
PSViewStringFile::
isValid() const
{
  return (buffer_size_ > 0);
}

int
PSViewStringFile::
size()
{
  return buffer_size_;
}

int
PSViewStringFile::
bytesUsed()
{
  return buffer_pos_;
}

int
PSViewStringFile::
bytesAvailable()
{
  return (buffer_size_ - buffer_pos_);
}

bool
PSViewStringFile::
setPosition(uint pos)
{
  if (pos >= buffer_size_)
    return false;

  buffer_pos_ = pos;

  return true;
}

bool
PSViewStringFile::
getPosition(uint *pos)
{
  *pos = buffer_pos_;

  return true;
}

string
PSViewStringFile::
getFileName()
{
  return "--stringfile--";
}

int
PSViewStringFile::
readChar()
{
  if (buffer_pos_ >= buffer_size_)
    return EOF;

  int c = buffer_[buffer_pos_++];

  return c;
}

int
PSViewStringFile::
lookChar()
{
  if (buffer_pos_ >= buffer_size_)
    return EOF;

  int c = buffer_[buffer_pos_];

  return c;
}

void
PSViewStringFile::
unreadChars(const std::vector<int> &chars)
{
  uint len = chars.size();

  if (buffer_pos_ >= len)
    buffer_pos_ -= len;
  else
    assert(false);
}

bool
PSViewStringFile::
loadBuffer()
{
  return false;
}

bool
PSViewStringFile::
writeChar(int)
{
  return false;
}

void
PSViewStringFile::
reset()
{
  buffer_pos_  = 0;
  buffer_size_ = 0;
}

void
PSViewStringFile::
close()
{
  buffer_pos_  = 0;
  buffer_size_ = 0;
}
##concat##CPSViewStringFileToken.cpp
#include <CPSViewI.h>

PSViewStringFileToken::
PSViewStringFileToken(CPSView *psview, const string &str) :
 PSViewFileToken(psview),
 string_file_   ()
{
  string_file_ = new PSViewStringFile(psview, str);

  file_ = string_file_;
}

PSViewStringFileToken::
PSViewStringFileToken(const PSViewStringFileToken &string_file_token) :
 PSViewFileToken(string_file_token),
 string_file_   ()
{
  string_file_ = new PSViewStringFile(*string_file_token.string_file_);

  file_ = string_file_;
}

PSViewStringFileToken::
~PSViewStringFileToken()
{
}

PSViewStringFileToken *
PSViewStringFileToken::
dup() const
{
  return new PSViewStringFileToken(*this);
}

int
PSViewStringFileToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewStringFileToken *string_file_token = dynamic_cast<PSViewStringFileToken *>(token);

    return string_file_->compare(string_file_token->string_file_);
  }
  else
    return type_ - token->getType();
}

void
PSViewStringFileToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for String File Missing\n");
}

const PSViewName &
PSViewStringFileToken::
getName()
{
  return psview_->getNameMgr()->getName(string_file_->getFileName());
}

void
PSViewStringFileToken::
print()
{
  CStrUtil::printf("-file-");
}

string
PSViewStringFileToken::
toString()
{
  return "--nostringval--";
}

void
PSViewStringFileToken::
flush()
{
  string_file_->flush();
}

PSViewToken *
PSViewStringFileToken::
readToken()
{
  return string_file_->readToken();
}

bool
PSViewStringFileToken::
isReadable() const
{
  return string_file_->isReadable();
}

bool
PSViewStringFileToken::
isWritable() const
{
  return string_file_->isWritable();
}

bool
PSViewStringFileToken::
isValid() const
{
  return string_file_->isValid();
}

int
PSViewStringFileToken::
size()
{
  return string_file_->size();
}

int
PSViewStringFileToken::
bytesUsed()
{
  return string_file_->bytesUsed();
}

uint
PSViewStringFileToken::
bytesAvailable()
{
  return string_file_->bytesAvailable();
}

PSVboolean
PSViewStringFileToken::
setPosition(uint pos)
{
  return string_file_->setPosition(pos);
}

PSVboolean
PSViewStringFileToken::
getPosition(uint *pos)
{
  return string_file_->getPosition(pos);
}

string
PSViewStringFileToken::
getFileName()
{
  return string_file_->getFileName();
}

int
PSViewStringFileToken::
readChar()
{
  return string_file_->readChar();
}

int
PSViewStringFileToken::
lookChar()
{
  return string_file_->lookChar();
}

bool
PSViewStringFileToken::
loadBuffer()
{
  return string_file_->loadBuffer();
}

PSVboolean
PSViewStringFileToken::
writeChar(PSVchar c)
{
  return string_file_->writeChar(c);
}

void
PSViewStringFileToken::
reset()
{
  string_file_->reset();
}

void
PSViewStringFileToken::
close()
{
  string_file_->close();
}
##concat##CPSViewStringToken.cpp
#include <CPSViewI.h>

PSViewStringToken::
PSViewStringToken(CPSView *psview, PSVinteger max_length) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_STRING,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 string_    ()
{
  string_ = new PSViewString(max_length);
}

PSViewStringToken::
PSViewStringToken(CPSView *psview, const string &str) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_STRING,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 string_    ()
{
  string_ = new PSViewString(str);
}

PSViewStringToken::
PSViewStringToken(CPSView *psview, PSViewString *str) :
 PSViewToken(psview, PSVIEW_TOKEN_TYPE_STRING,
             PSVIEW_TOKEN_COMPOSITE, PSVIEW_TOKEN_LITERAL,
             PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE),
 string_    (str)
{
}

PSViewStringToken::
PSViewStringToken(const PSViewStringToken &string_token) :
 PSViewToken(string_token),
 string_    ()
{
  string_ = new PSViewString(*string_token.string_);
}

PSViewStringToken::
PSViewStringToken(const PSViewStringToken &string_token, int pos) :
 PSViewToken(string_token),
 string_    ()
{
  string_ = new PSViewString(*string_token.string_, pos);
}

PSViewStringToken::
PSViewStringToken(const PSViewStringToken &string_token, int pos, int len) :
 PSViewToken(string_token),
 string_    ()
{
  string_ = new PSViewString(*string_token.string_, pos, len);
}

PSViewStringToken::
~PSViewStringToken()
{
}

PSViewStringToken *
PSViewStringToken::
dup() const
{
  return new PSViewStringToken(*this);
}

int
PSViewStringToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewStringToken *string_token = dynamic_cast<PSViewStringToken *>(token);

    return string_->compare(*string_token->string_);
  }
  else if (token->isType(PSVIEW_TOKEN_TYPE_NAME)) {
    PSViewNameToken name_token1 = PSViewNameToken(psview_, string_->getString());

    return name_token1.compare(token);
  }
  else
    return type_ - token->getType();
}

void
PSViewStringToken::
executeToken()
{
  string str = string_->getString();

  PSViewStringFileToken *token1 = new PSViewStringFileToken(psview_, str);

  PSViewToken *token2 = token1->readToken();

  while (token2) {
    if (token2->isProcedure())
      psview_->getOperandStack()->push(token2);
    else
      token2->execute();

    if (psview_->getErrorMgr()->getError())
      break;

    token2 = token1->readToken();
  }

  token1->close();
}

const PSViewName &
PSViewStringToken::
getName()
{
  CTHROW("No name for token");

  return psview_->getNameMgr()->getName("");
}

void
PSViewStringToken::
print()
{
  CStrUtil::printf("(");

  int len = string_->getLength();

  for (int i = 1; i <= len; ++i) {
    int c = string_->getChar(i);

    if      (c == '(' || c == ')')
      CStrUtil::printf("\\%c", c);
    else if (isprint(c))
      CStrUtil::printf("%c", c);
    else
      CStrUtil::printf("\\%03o", c);
  }

  CStrUtil::printf(")");
}

string
PSViewStringToken::
toString()
{
  return string_->getString();
}

PSViewStringToken *
PSViewStringToken::
split(PSVinteger n)
{
  PSViewString *str = string_->split(n);

  PSViewStringToken *token = new PSViewStringToken(psview_, str);

  return token;
}

int
PSViewStringToken::
compare(PSViewToken *token) const
{
  if (token->isType(type_)) {
    PSViewStringToken *string_token = dynamic_cast<PSViewStringToken *>(token);

    return string_->compare(*string_token->string_);
  }
  else
    return type_ - token->getType();
}

int
PSViewStringToken::
compareN(const PSViewStringToken *token, PSVinteger n) const
{
  return string_->compareN(*token->string_, n);
}

PSVinteger
PSViewStringToken::
isSubString(PSViewStringToken *token)
{
  return string_->isSubString(token->string_);
}

PSViewStringToken *
PSViewStringToken::
subString(PSVinteger start, PSVinteger num_chars)
{
  PSViewStringToken *token = new PSViewStringToken(psview_, string_->subString(start, num_chars));

  return token;
}

void
PSViewStringToken::
setString(const string &str)
{
  string_->setString(str);
}

void
PSViewStringToken::
setChar(int pos, char c)
{
  string_->setChar(pos, c);
}

void
PSViewStringToken::
setChars(const string &str, int pos)
{
  string_->setChars(str, pos);
}

void
PSViewStringToken::
setBounds(PSVinteger pos, PSVinteger len)
{
  string_->setBounds(pos, len);
}

int
PSViewStringToken::
getLength() const
{
  return string_->getLength();
}

int
PSViewStringToken::
getChar(int i) const
{
  return string_->getChar(i);
}
##concat##CPSViewTextFile.cpp
#include <CPSViewI.h>
#include <COSFile.h>

const int BUFFER_SIZE = 512;

PSViewTextFile::
PSViewTextFile(CPSView *psview, const string &name, const string &mode) :
 PSViewFile  (psview),
 name_       (name),
 mode_       (mode),
 mode_type_  (PSVIEW_FILE_MODE_TYPE_NONE),
 fp_         (NULL),
 size_       (0),
 pos_        (0),
 buffer_     (),
 buffer_pos_ (0),
 buffer_num_ (0),
 buffer_size_(0)
{
  init();
}

PSViewTextFile::
PSViewTextFile(const PSViewTextFile &text_file) :
 PSViewFile  (text_file),
 name_       (text_file.name_),
 mode_       (text_file.mode_),
 mode_type_  (PSVIEW_FILE_MODE_TYPE_NONE),
 fp_         (NULL),
 size_       (0),
 pos_        (0),
 buffer_     (),
 buffer_pos_ (0),
 buffer_num_ (0),
 buffer_size_(0)
{
  init();
}

PSViewTextFile::
~PSViewTextFile()
{
  if (fp_ != stdin && fp_ != stdout && fp_ != stderr)
    fclose(fp_);
}

void
PSViewTextFile::
init()
{
  if      (mode_ == "r")
    mode_type_ = PSVIEW_FILE_MODE_TYPE_READ;
  else if (mode_ == "r+")
    mode_type_ = PSVIEW_FILE_MODE_TYPE_READ_WRITE;
  else if (mode_ == "w")
    mode_type_ = PSVIEW_FILE_MODE_TYPE_WRITE;
  else if (mode_ == "w+")
    mode_type_ = PSVIEW_FILE_MODE_TYPE_READ_WRITE;
  else if (mode_ == "a")
    mode_type_ = PSVIEW_FILE_MODE_TYPE_WRITE;
  else if (mode_ == "a+")
    mode_type_ = PSVIEW_FILE_MODE_TYPE_READ_WRITE;
  else
    CTHROW("Invalid File Mode" + mode_);

  if      (name_ == "%stdin")
    fp_ = stdin;
  else if (name_ == "%stdout")
    fp_ = stdout;
  else if (name_ == "%stderr")
    fp_ = stderr;
  else if (name_ == "%statementedit")
    fp_ = stdin;
  else if (name_ == "%lineedit")
    fp_ = stdin;
  else
    fp_ = fopen(name_.c_str(), mode_.c_str());

  if (fp_ == NULL)
    CTHROW("Can't open file " + name_);

  size_ = -1;

  if (fp_ != stdin && fp_ != stdout && fp_ != stderr) {
    struct stat file_stat;

    int error = fstat(fileno(fp_), &file_stat);

    if (error != 0 || ! COSFile::stat_is_reg(&file_stat)) {
      fclose(fp_);

      CTHROW("Not a regular File");
    }

    size_ = file_stat.st_size;
  }

  pos_ = 0;

  if (mode_type_ & PSVIEW_FILE_MODE_TYPE_READ)
    buffer_size_ = BUFFER_SIZE;
  else
    buffer_size_ = 0;

  buffer_.resize(buffer_size_ + 1);

  buffer_[0] = '\0';

  buffer_num_ = 0;
  buffer_pos_ = 0;
}

int
PSViewTextFile::
compare(PSViewTextFile *)
{
  return 1;
}

void
PSViewTextFile::
flush()
{
  if (! isWritable())
    return;

  if (fp_ != NULL)
    fflush(fp_);
}

bool
PSViewTextFile::
isReadable() const
{
  return (mode_type_ & PSVIEW_FILE_MODE_TYPE_READ);
}

bool
PSViewTextFile::
isWritable() const
{
  return (mode_type_ & PSVIEW_FILE_MODE_TYPE_WRITE);
}

bool
PSViewTextFile::
isValid() const
{
  return (fp_ != NULL);
}

int
PSViewTextFile::
size()
{
  return size_;
}

int
PSViewTextFile::
bytesUsed()
{
  if (fp_ == stdin || fp_ == stdout || fp_ == stderr)
    return -1;

  return(pos_ - buffer_num_ + buffer_pos_);
}

int
PSViewTextFile::
bytesAvailable()
{
  if (fp_ == stdin || fp_ == stdout || fp_ == stderr)
    return -1;

  return (size_ - bytesUsed());
}

bool
PSViewTextFile::
setPosition(uint pos)
{
  if ((int) pos >= size_)
    return false;

  if (fp_ == stdin  || fp_ == stdout || fp_ == stderr || fp_ == NULL)
    return false;

  buffer_pos_ = pos - pos_ + buffer_pos_;

  if (buffer_pos_ < buffer_num_) {
    pos_ = pos;

    return true;
  }

  fseek(fp_, pos, SEEK_SET);

  uint pos1 = ftell(fp_);

  if (pos1 != pos)
    return false;

  pos_ = pos;

  buffer_[0] = '\0';

  buffer_pos_ = 0;
  buffer_num_ = 0;

  return true;
}

bool
PSViewTextFile::
getPosition(uint *pos)
{
  if (fp_ == stdin || fp_ == stdout || fp_ == stderr || fp_ == NULL)
    return false;

  *pos = pos_;

  return true;
}

string
PSViewTextFile::
getFileName()
{
  return name_;
}

int
PSViewTextFile::
readChar()
{
  if (! (mode_type_ & PSVIEW_FILE_MODE_TYPE_READ))
    return EOF;

  if (fp_ == NULL)
    return EOF;

  if (buffer_pos_ >= buffer_num_) {
    if (! loadBuffer())
      return EOF;
  }

  pos_++;

  int c = buffer_[buffer_pos_++];

  return c;
}

int
PSViewTextFile::
lookChar()
{
  if (! (mode_type_ & PSVIEW_FILE_MODE_TYPE_READ))
    return EOF;

  if (fp_ == NULL)
    return EOF;

  if (buffer_pos_ >= buffer_num_) {
    if (! loadBuffer())
      return EOF;
  }

  int c = buffer_[buffer_pos_];

  return c;
}

void
PSViewTextFile::
unreadChars(const std::vector<int> &chars)
{
  uint len = chars.size();

  if (buffer_pos_ >= len)
    buffer_pos_ -= len;
  else
    assert(false);
}

bool
PSViewTextFile::
loadBuffer()
{
  if (! (mode_type_ & PSVIEW_FILE_MODE_TYPE_READ))
    return false;

  if (fp_ == NULL)
    return false;

  buffer_pos_ = 0;
  buffer_num_  = 0;

  int c;

  while (buffer_num_ < buffer_size_ && (c = fgetc(fp_)) != EOF)
    buffer_[buffer_num_++] = c;
  buffer_[buffer_num_] = '\0';

  if (buffer_num_ == 0)
    return false;

  return true;
}

bool
PSViewTextFile::
writeChar(int c)
{
  if (! (mode_type_ & PSVIEW_FILE_MODE_TYPE_WRITE))
    return false;

  if (fp_ == NULL)
    return false;

  fputc(c, fp_);

  return true;
}

void
PSViewTextFile::
reset()
{
  buffer_[0] = '\0';

  buffer_pos_ = 0;
  buffer_num_ = 0;
}

void
PSViewTextFile::
close()
{
  if (mode_type_ & PSVIEW_FILE_MODE_TYPE_READ) {
    buffer_pos_  = 0;
    buffer_num_  = 0;
    buffer_size_ = 0;
  }

  if (mode_type_ & PSVIEW_FILE_MODE_TYPE_WRITE && fp_ != NULL)
    fflush(fp_);

  if (fp_ != NULL   && fp_ != stdin &&
      fp_ != stdout && fp_ != stderr)
    fclose(fp_);

  fp_ = NULL;

  size_ = 0;
  pos_  = 0;
}
##concat##CPSViewTextFileToken.cpp
#include <CPSViewI.h>

PSViewTextFileToken::
PSViewTextFileToken(CPSView *psview, const string &filename, const string &mode) :
 PSViewFileToken(psview),
 text_file_     ()
{
  text_file_ = new PSViewTextFile(psview, filename, mode);

  file_ = text_file_;
}

PSViewTextFileToken::
PSViewTextFileToken(const PSViewTextFileToken &text_file_token) :
 PSViewFileToken(text_file_token),
 text_file_     ()
{
  text_file_ = new PSViewTextFile(*text_file_token.text_file_);

  file_ = text_file_;
}

PSViewTextFileToken::
~PSViewTextFileToken()
{
}

PSViewTextFileToken *
PSViewTextFileToken::
dup() const
{
  return new PSViewTextFileToken(*this);
}

int
PSViewTextFileToken::
compare(PSViewToken *token)
{
  if (token->isType(type_)) {
    PSViewTextFileToken *text_file_token = dynamic_cast<PSViewTextFileToken *>(token);

    return text_file_->compare(text_file_token->text_file_);
  }
  else
    return type_ - token->getType();
}

void
PSViewTextFileToken::
executeToken()
{
  CStrUtil::eprintf("PSView: Execute Code for Text File Missing\n");
}

const PSViewName &
PSViewTextFileToken::
getName()
{
  return psview_->getNameMgr()->getName(text_file_->getFileName());
}

void
PSViewTextFileToken::
print()
{
  CStrUtil::printf("-file-");
}

string
PSViewTextFileToken::
toString()
{
  return "--nostringval--";
}

void
PSViewTextFileToken::
flush()
{
  text_file_->flush();
}

PSViewToken *
PSViewTextFileToken::
readToken()
{
  if (! text_file_->isReadable())
    return 0;

  return text_file_->readToken();
}

bool
PSViewTextFileToken::
isValid() const
{
  return text_file_->isValid();
}

int
PSViewTextFileToken::
readChar()
{
  if (! text_file_->isReadable()) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_INVALID_ACCESS);

    return EOF;
  }

  int c = text_file_->readChar();

  if (c == EOF)
    close();

  return c;
}

PSVboolean
PSViewTextFileToken::
writeChar(PSVchar c)
{
  return text_file_->writeChar(c);
}

void
PSViewTextFileToken::
reset()
{
  text_file_->reset();
}

void
PSViewTextFileToken::
close()
{
  text_file_->close();
}

uint
PSViewTextFileToken::
bytesAvailable()
{
  return text_file_->bytesAvailable();
}

PSVboolean
PSViewTextFileToken::
getPosition(uint *pos)
{
  if (! text_file_->getPosition(pos)) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_IO_ERROR);

    return false;
  }

  return true;
}

PSVboolean
PSViewTextFileToken::
setPosition(uint pos)
{
  return text_file_->setPosition(pos);
}

string
PSViewTextFileToken::
getFileName()
{
  return text_file_->getFileName();
}
##concat##CPSViewToken.cpp
#include <CPSViewI.h>

const char * const ARRAY_TYPE_NAME        = "arraytype";
const char * const BOOLEAN_TYPE_NAME      = "booleantype";
const char * const DICT_TYPE_NAME         = "dicttype";
const char * const FILE_TYPE_NAME         = "filetype";
const char * const FONT_TYPE_NAME         = "fonttype";
const char * const GSTATE_TYPE_NAME       = "gstatetype";
const char * const INTEGER_TYPE_NAME      = "integertype";
const char * const MARK_TYPE_NAME         = "marktype";
const char * const NAME_TYPE_NAME         = "nametype";
const char * const NULL_TYPE_NAME         = "nulltype";
const char * const OPERATOR_TYPE_NAME     = "operatortype";
const char * const PACKED_ARRAY_TYPE_NAME = "packedarraytype";
const char * const REAL_TYPE_NAME         = "realtype";
const char * const SAVE_TYPE_NAME         = "savetype";
const char * const STRING_TYPE_NAME       = "stringtype";

PSViewTokenMgr::
PSViewTokenMgr(CPSView *psview) :
 psview_            (psview),
 packing_           (false),
 last_execute_token_(NULL)
{
}

void
PSViewTokenMgr::
setPacking(int flag)
{
  packing_ = flag;
}

void
PSViewTokenMgr::
setLastExecuteToken(PSViewToken *token)
{
  last_execute_token_ = token;
}

const PSViewName &
PSViewTokenMgr::
getLBraceName()
{
  return psview_->getNameMgr()->getName("{");
}

const PSViewName &
PSViewTokenMgr::
getRBraceName()
{
  return psview_->getNameMgr()->getName("}");
}

//-----------

PSViewToken::
PSViewToken(CPSView *psview, PSViewTokenType type, PSViewTokenCompositeType composite,
            PSViewTokenExecutableType executable, PSViewTokenAccessType access) :
 psview_    (psview),
 type_      (type),
 composite_ (composite),
 memory_    (NULL),
 executable_(executable),
 access_    (access)
{
}

PSViewToken::
PSViewToken(const PSViewToken &token) :
 psview_    (token.psview_),
 type_      (token.type_),
 composite_ (token.composite_),
 memory_    (NULL),
 executable_(token.executable_),
 access_    (token.access_)
{
}

PSViewToken::
~PSViewToken()
{
}

PSViewToken &
PSViewToken::
operator=(const PSViewToken &token)
{
  type_       = token.type_;
  composite_  = token.composite_;
  memory_     = NULL;
  executable_ = token.executable_;
  access_     = token.access_;

  return *this;
}

PSVboolean
PSViewToken::
isBoolean()
{
  return isType(PSVIEW_TOKEN_TYPE_BOOLEAN);
}

PSVboolean
PSViewToken::
isFontId()
{
  return isType(PSVIEW_TOKEN_TYPE_FONT_ID);
}

PSVboolean
PSViewToken::
isInteger()
{
  return isType(PSVIEW_TOKEN_TYPE_INTEGER);
}

PSVboolean
PSViewToken::
isName()
{
  return isType(PSVIEW_TOKEN_TYPE_NAME);
}

PSVboolean
PSViewToken::
isMark()
{
  return isType(PSVIEW_TOKEN_TYPE_MARK);
}

PSVboolean
PSViewToken::
isNull()
{
  return isType(PSVIEW_TOKEN_TYPE_NULL);
}

PSVboolean
PSViewToken::
isOperator()
{
  return isType(PSVIEW_TOKEN_TYPE_OPERATOR);
}

PSVboolean
PSViewToken::
isReal()
{
  return isType(PSVIEW_TOKEN_TYPE_REAL);
}

PSVboolean
PSViewToken::
isSave()
{
  return isType(PSVIEW_TOKEN_TYPE_SAVE);
}

PSVboolean
PSViewToken::
isComposite()
{
  return composite_ == PSVIEW_TOKEN_COMPOSITE;
}

PSVboolean
PSViewToken::
isArray()
{
  return isType(PSVIEW_TOKEN_TYPE_ARRAY);
}

PSVboolean
PSViewToken::
isDictionary()
{
  return isType(PSVIEW_TOKEN_TYPE_DICTIONARY);
}

PSVboolean
PSViewToken::
isFile()
{
  return isType(PSVIEW_TOKEN_TYPE_FILE);
}

PSVboolean
PSViewToken::
isGState()
{
  return isType(PSVIEW_TOKEN_TYPE_GSTATE);
}

PSVboolean
PSViewToken::
isPackedArray()
{
  return isType(PSVIEW_TOKEN_TYPE_PACKED_ARRAY);
}

PSVboolean
PSViewToken::
isString()
{
  return isType(PSVIEW_TOKEN_TYPE_STRING);
}

PSVboolean
PSViewToken::
isNumber()
{
  return isType(PSVIEW_TOKEN_TYPE_INTEGER) ||
         isType(PSVIEW_TOKEN_TYPE_REAL);
}

PSVboolean
PSViewToken::
isProcedure()
{
  return (isExecutable() &&
          (isType(PSVIEW_TOKEN_TYPE_ARRAY) ||
           isType(PSVIEW_TOKEN_TYPE_PACKED_ARRAY)));
}

PSVboolean
PSViewToken::
getBooleanValue()
{
  if      (type_ == PSVIEW_TOKEN_TYPE_BOOLEAN) {
    PSViewBooleanToken *boolean_token = dynamic_cast<PSViewBooleanToken *>(this);

    return boolean_token->getValue();
  }
  else {
    CTHROW("No boolean value for token");

    return false;
  }
}

PSVinteger
PSViewToken::
getIntegerValue()
{
  if      (type_ == PSVIEW_TOKEN_TYPE_INTEGER) {
    PSViewIntegerToken *integer_token = dynamic_cast<PSViewIntegerToken *>(this);

    return integer_token->getValue();
  }
  else if (type_ == PSVIEW_TOKEN_TYPE_REAL) {
    PSViewRealToken *real_token = dynamic_cast<PSViewRealToken *>(this);

    return (PSVinteger) real_token->getValue();
  }
  else {
    CTHROW("No integer value for token");

    return 0;
  }
}

PSVreal
PSViewToken::
getRealValue()
{
  if      (type_ == PSVIEW_TOKEN_TYPE_INTEGER) {
    PSViewIntegerToken *integer_token = dynamic_cast<PSViewIntegerToken *>(this);

    return (PSVreal) integer_token->getValue();
  }
  else if (type_ == PSVIEW_TOKEN_TYPE_REAL) {
    PSViewRealToken *real_token = dynamic_cast<PSViewRealToken *>(this);

    return real_token->getValue();
  }
  else {
    CTHROW("No real value for token");

    return 0.0;
  }
}

PSViewToken *
PSViewToken::
toName()
{
  PSViewToken *token1 = new PSViewNameToken(psview_, getTypeName());

  return token1;
}

string
PSViewToken::
getTypeName()
{
  if      (type_ == PSVIEW_TOKEN_TYPE_ARRAY)
    return ARRAY_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_BOOLEAN)
    return BOOLEAN_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_DICTIONARY)
    return DICT_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_FILE)
    return FILE_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_FONT_ID)
    return FONT_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_GSTATE)
    return GSTATE_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_INTEGER)
    return INTEGER_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_MARK)
    return MARK_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_NAME)
    return NAME_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_NULL)
    return NULL_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_OPERATOR)
    return OPERATOR_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_PACKED_ARRAY)
    return PACKED_ARRAY_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_REAL)
    return REAL_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_SAVE)
    return SAVE_TYPE_NAME;
  else if (type_ == PSVIEW_TOKEN_TYPE_STRING)
    return STRING_TYPE_NAME;
  else {
    CTHROW("No Name for Token");

    return "";
  }
}

int
PSViewToken::
compare(PSViewToken *token)
{
  if (type_ == token->type_) {
    if      (type_ == PSVIEW_TOKEN_TYPE_BOOLEAN)
      return (dynamic_cast<PSViewBooleanToken *>(this))->
                compare(dynamic_cast<PSViewBooleanToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_FONT_ID)
      return (dynamic_cast<PSViewFontIdToken *>(this))->
                compare(dynamic_cast<PSViewFontIdToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_INTEGER)
      return (dynamic_cast<PSViewIntegerToken *>(this))->
                compare(dynamic_cast<PSViewIntegerToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_MARK)
      return (dynamic_cast<PSViewMarkToken *>(this))->
                compare(dynamic_cast<PSViewMarkToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_NAME)
      return (dynamic_cast<PSViewNameToken *>(this))->
                compare(dynamic_cast<PSViewNameToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_NULL)
      return (dynamic_cast<PSViewNullToken *>(this))->
                compare(dynamic_cast<PSViewNullToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_OPERATOR)
      return (dynamic_cast<PSViewOperatorToken *>(this))->
                compare(dynamic_cast<PSViewOperatorToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_REAL)
      return (dynamic_cast<PSViewRealToken *>(this))->
                compare(dynamic_cast<PSViewRealToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_SAVE)
      return (dynamic_cast<PSViewSaveToken *>(this))->
                compare(dynamic_cast<PSViewSaveToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_ARRAY)
      return (dynamic_cast<PSViewArrayToken *>(this))->
                compare(dynamic_cast<PSViewArrayToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_DICTIONARY)
      return (dynamic_cast<PSViewDictionaryToken *>(this))->
                compare(dynamic_cast<PSViewDictionaryToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_FILE)
      return (dynamic_cast<PSViewFileToken *>(this))->
                compare(dynamic_cast<PSViewFileToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_GSTATE)
      return (dynamic_cast<PSViewGStateToken *>(this))->
                compare(dynamic_cast<PSViewGStateToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_PACKED_ARRAY)
      return (dynamic_cast<PSViewPackedArrayToken *>(this))->
                compare(dynamic_cast<PSViewPackedArrayToken *>(token));
    else if (type_ == PSVIEW_TOKEN_TYPE_STRING)
      return (dynamic_cast<PSViewStringToken *>(this))->
                compare(dynamic_cast<PSViewStringToken *>(token));
    else
      CTHROW("Invalid Type for Compare");
  }

  if (       type_ == PSVIEW_TOKEN_TYPE_INTEGER && token->type_ == PSVIEW_TOKEN_TYPE_REAL)
    return (dynamic_cast<PSViewIntegerToken *>(this))->
              compare(dynamic_cast<PSViewRealToken *>(token));

  if (       type_ == PSVIEW_TOKEN_TYPE_REAL && token->type_ == PSVIEW_TOKEN_TYPE_INTEGER)
    return (dynamic_cast<PSViewRealToken *>(this))->
              compare(dynamic_cast<PSViewIntegerToken *>(token));

  if (       type_ == PSVIEW_TOKEN_TYPE_NAME && token->type_ == PSVIEW_TOKEN_TYPE_STRING)
    return (dynamic_cast<PSViewNameToken *>(this))->
              compare(dynamic_cast<PSViewStringToken *>(token));

  if (       type_ == PSVIEW_TOKEN_TYPE_STRING  && token->type_ == PSVIEW_TOKEN_TYPE_NAME)
    return (dynamic_cast<PSViewStringToken *>(this))->
              compare(dynamic_cast<PSViewNameToken *>(token));

  CTHROW("Invalid Type for Compare");

  return 0;
}

PSViewTokenType
PSViewToken::
getType() const
{
  return type_;
}

PSVboolean
PSViewToken::
isType(PSViewTokenType type) const
{
  return (type_ == type);
}

PSVboolean
PSViewToken::
isExecutable()
{
  return (executable_ == PSVIEW_TOKEN_EXECUTABLE);
}

PSVboolean
PSViewToken::
getWritable()
{
  return access_ == PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE;
}

PSVboolean
PSViewToken::
getReadable()
{
  return (access_ == PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE ||
          access_ == PSVIEW_TOKEN_ACCESS_TYPE_READ_ONLY);
}

PSVboolean
PSViewToken::
getGlobal()
{
  return (isComposite() && psview_->getMemoryMgr()->getGlobal());
}

PSVboolean
PSViewToken::
getLocal()
{
  return (isComposite() && psview_->getMemoryMgr()->getLocal());
}

PSVboolean
PSViewToken::
isLiteral()
{
  return (executable_ == PSVIEW_TOKEN_LITERAL);
}

void
PSViewToken::
setExecutable()
{
  executable_ = PSVIEW_TOKEN_EXECUTABLE;
}

void
PSViewToken::
setLiteral()
{
  executable_ = PSVIEW_TOKEN_LITERAL;
}

void
PSViewToken::
setReadWrite()
{
  access_ = PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE;
}

void
PSViewToken::
setReadOnly()
{
  access_ = PSVIEW_TOKEN_ACCESS_TYPE_READ_ONLY;
}

void
PSViewToken::
setExecuteOnly()
{
  access_ = PSVIEW_TOKEN_ACCESS_TYPE_EXECUTE_ONLY;
}

void
PSViewToken::
setNoAccess()
{
  access_ = PSVIEW_TOKEN_ACCESS_TYPE_NONE;
}

int
PSViewToken::
getMemoryDepth()
{
  if (isComposite())
    return psview_->getMemoryMgr()->getDepth();
  else
    return -1;
}

void
PSViewToken::
execute()
{
  if (psview_->getErrorMgr()->getError())
    return;

  if (isLiteral()) {
    psview_->getOperandStack()->push(this);

    return;
  }

  if (psview_->getDebug()) {
    CStrUtil::printf("Executing ");
    print();
    CStrUtil::printf("\n");

    CStrUtil::printf("Stack     ");
    psview_->getOperandStack()->print();

    CStrUtil::printf("\n");
  }

  psview_->getTokenMgr()->setLastExecuteToken(this);

  executeToken();
}

PSVboolean
PSViewToken::
isMatrix()
{
  if (! isArray() || ! isLiteral())
    return false;

  PSViewArrayToken *array_token = dynamic_cast<PSViewArrayToken *>(this);

  PSVinteger num_tokens = array_token->getNumValues();

  if (num_tokens != 6)
    return false;

  for (int i = 1; i <= 6; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber())
      return false;
  }

  return true;
}

CMatrix2D *
PSViewToken::
getMatrix()
{
  if (! isArray() || ! isLiteral()) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return NULL;
  }

  PSViewArrayToken *array_token = dynamic_cast<PSViewArrayToken *>(this);

  PSVinteger num_tokens = array_token->getNumValues();

  if (num_tokens != 6) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_RANGE_CHECK);

    return NULL;
  }

  CMatrix2D *matrix = new CMatrix2D;

  double data[6];

  for (int i = 1; i <= 6; i++) {
    PSViewToken *sub_token = array_token->getValue(i);

    if (! sub_token->isNumber()) {
      delete matrix;

      psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

      return NULL;
    }

    data[i - 1] = sub_token->getRealValue();
  }

  matrix->setValues(data[0], data[2], data[1],
                    data[3], data[4], data[5]);

  return matrix;
}

void
PSViewToken::
setMatrix(CMatrix2D *matrix)
{
  if (! isArray() || ! isLiteral()) {
    psview_->getErrorMgr()->raise(PSVIEW_ERROR_TYPE_TYPE_CHECK);

    return;
  }

  PSViewArrayToken *array_token = dynamic_cast<PSViewArrayToken *>(this);

  double data[6];

  matrix->getValues(&data[0], &data[2], &data[1],
                    &data[3], &data[4], &data[5]);

  for (int i = 1; i <= 6; i++) {
    PSViewToken *sub_token = new PSViewRealToken(psview_, data[i - 1]);

    array_token->setValue(i, sub_token);
  }
}
##concat##CQPSView.cpp
#include <CQPSView.h>
#include <CPSView.h>
#include <CQPSViewRenderer.h>

CQPSView::
CQPSView(QWidget *parent) :
 QWidget(parent)
{
  renderer_ = new CQPSViewRenderer();

  psview_ = new CPSView;

  if (getenv("PSVIEW_DEBUG") != NULL)
    psview_->setDebug(true);
}

CQPSView::
~CQPSView()
{
}

void
CQPSView::
loadFile(const QString &fileName)
{
  psview_->setRenderer(renderer_);

  renderer_->beginDraw();

  //renderer_->setDataRange(0, 0, 594, 792);

  psview_->openCurrentFile(fileName.toStdString());

  psview_->executeCurrentFile();

  psview_->closeCurrentFile();

  renderer_->endDraw();

  update();
}

void
CQPSView::
paintEvent(QPaintEvent *)
{
  QPainter painter(this);

  QImage qimage = renderer_->getQImage();

  painter.drawImage(0, 0, qimage);
}
##concat##CQPSViewRenderer.cpp
#include <CQPSViewRenderer.h>
#include <CQUtil.h>

CQPSViewRenderer::
CQPSViewRenderer() :
 painter_   (NULL),
 path_      (NULL),
 fillType_  (FILL_TYPE_WINDING),
 flatness_  (0),
 antiAlias_ (false)
{
  painter_ = new QPainter;

  viewMatrix_.setIdentity();

  setSize(CPSView::PAGE_WIDTH, CPSView::PAGE_HEIGHT);
}

CQPSViewRenderer *
CQPSViewRenderer::
dup()
{
  return new CQPSViewRenderer;
}

void
CQPSViewRenderer::
beginDraw()
{
  painter_->begin(&qimage_);

  if (antiAlias_)
    painter_->setRenderHints(QPainter::Antialiasing);

  painter_->fillRect(qimage_.rect(), QBrush(QColor(255,255,255)));

  painter_->setWorldMatrix(CQUtil::toQMatrix(range_.getMatrix()*viewMatrix_));

  transform_  = painter_->worldTransform();
  itransform_ = transform_.inverted();
}

void
CQPSViewRenderer::
endDraw()
{
  painter_->end();
}

void
CQPSViewRenderer::
setSize(int width, int height)
{
  if (width != qimage_.width() || height != qimage_.height())
    qimage_ = QImage(QSize(width, height), QImage::Format_ARGB32);

  range_.setPixelRange(0, 0, width - 1, height - 1);

  range_.setWindowRange(0, 0, width - 1, height - 1);
}

void
CQPSViewRenderer::
clear(const CRGBA &bg)
{
  painter_->fillRect(qimage_.rect(), QBrush(CQUtil::rgbaToColor(bg)));
}

void
CQPSViewRenderer::
setPen(const CPen &pen)
{
  pen_.setColor(CQUtil::rgbaToColor(pen.getColor()));

  double w = pen.getWidth();

  if (w <= 0.0) w = 0.01;

  pen_.setWidthF(w);

  const CLineDash &dash = pen.getLineDash();

  int num = dash.getNumLengths();

  if (num > 0) {
    pen_.setStyle(Qt::CustomDashLine);

    pen_.setDashOffset(dash.getOffset());

    QVector<qreal> dashes;

    for (int i = 0; i < num; ++i)
      dashes << dash.getLength(i)/pen_.widthF();

    if (num & 1)
      dashes << dash.getLength(0)/pen_.widthF();

    pen_.setDashPattern(dashes);
  }
  else
    pen_.setStyle(Qt::SolidLine);

  switch (pen.getLineCap()) {
    case LINE_CAP_TYPE_BUTT:
      pen_.setCapStyle(Qt::FlatCap);
      break;
    case LINE_CAP_TYPE_ROUND:
      pen_.setCapStyle(Qt::RoundCap);
      break;
    case LINE_CAP_TYPE_SQUARE:
      pen_.setCapStyle(Qt::SquareCap);
      break;
    default:
      break;
  }

  switch (pen.getLineJoin()) {
    case LINE_JOIN_TYPE_MITRE:
      pen_.setJoinStyle(Qt::MiterJoin);
      break;
    case LINE_JOIN_TYPE_ROUND:
      pen_.setJoinStyle(Qt::RoundJoin);
      break;
    case LINE_JOIN_TYPE_BEVEL:
      pen_.setJoinStyle(Qt::BevelJoin);
      break;
    default:
      break;
  }

  pen_.setMiterLimit(pen.getMitreLimit());

  flatness_ = pen.getFlatness();

  painter_->setPen(pen_);
}

void
CQPSViewRenderer::
setBrush(const CBrush &brush)
{
  brush_.setColor(CQUtil::rgbaToColor(brush.getColor()));
  brush_.setStyle(Qt::SolidPattern);

  fillType_ = brush.getFillRule();

  painter_->setBrush(brush_);
}

void
CQPSViewRenderer::
setViewMatrix(const CMatrix2D &m)
{
  viewMatrix_ = m;

  painter_->setWorldMatrix(CQUtil::toQMatrix(range_.getMatrix()*viewMatrix_));

  transform_  = painter_->worldTransform();
  itransform_ = transform_.inverted();
}

void
CQPSViewRenderer::
pathInit()
{
  delete path_;

  path_ = new QPainterPath;
}

void
CQPSViewRenderer::
pathMoveTo(const CPoint2D &p)
{
  path_->moveTo(p.x, p.y);
}

void
CQPSViewRenderer::
pathLineTo(const CPoint2D &p)
{
  path_->lineTo(p.x, p.y);
}

void
CQPSViewRenderer::
pathArc(const CPoint2D &c, double xr, double yr, double angle1, double angle2)
{
  double a1 = CMathGen::RadToDeg(angle1);
  double a2 = CMathGen::RadToDeg(angle2);

  QRectF rect(QPointF(c.x - xr, c.y - yr), QPointF(c.x + xr, c.y + yr));

  a1 = -a1;
  a2 = -a2;

  path_->arcTo(rect, a1, a2 - a1);
}

void
CQPSViewRenderer::
pathBezier2To(const CPoint2D &p1, const CPoint2D &p2)
{
  path_->quadTo(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2));
}

void
CQPSViewRenderer::
pathBezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3)
{
  path_->cubicTo(CQUtil::toQPoint(p1), CQUtil::toQPoint(p2), CQUtil::toQPoint(p3));
}

void
CQPSViewRenderer::
pathClose()
{
  path_->closeSubpath();
}

void
CQPSViewRenderer::
pathStroke()
{
  painter_->strokePath(*path_, pen_);
}

void
CQPSViewRenderer::
pathFill()
{
  if (fillType_ == FILL_TYPE_EVEN_ODD)
    path_->setFillRule(Qt::OddEvenFill);
  else
    path_->setFillRule(Qt::WindingFill);

  painter_->fillPath(*path_, brush_);
}

void
CQPSViewRenderer::
pathClip()
{
  if (fillType_ == FILL_TYPE_EVEN_ODD)
    path_->setFillRule(Qt::OddEvenFill);
  else
    path_->setFillRule(Qt::WindingFill);

  painter_->setClipPath(*path_);
}

#if 0
void
CQPSViewRenderer::
pathClipPath(PathBuilder &builder)
{
  QPainterPath path = painter_->clipPath();

  int num = path.elementCount();

  if (num > 0) {
    for (int i = 0; i < num; ++i) {
      const QPainterPath::Element &e = path.elementAt(i);

      QPointF p = e;

      if      (e.isMoveTo()) {
        builder.moveTo(CQUtil::fromQPoint(p));
      }
      else if (e.isLineTo()) {
        builder.lineTo(CQUtil::fromQPoint(p));
      }
      else if (e.isCurveTo()) {
        const QPainterPath::Element &e1 = path.elementAt(i + 1);
        const QPainterPath::Element &e2 = path.elementAt(i + 2);

        QPointF p1 = e1;
        QPointF p2 = e2;

        builder.curveTo(CQUtil::fromQPoint(p), CQUtil::fromQPoint(p1), CQUtil::fromQPoint(p2));

        i += 2;
      }
    }
  }
  else {
    double xmin = 0.0, ymin = 0.0, xmax = CPSView::PAGE_WIDTH - 1, ymax = CPSView::PAGE_HEIGHT - 1;

    builder.moveTo(CPoint2D(xmin, ymin));
    builder.lineTo(CPoint2D(xmax, ymin));
    builder.lineTo(CPoint2D(xmax, ymax));
    builder.lineTo(CPoint2D(xmin, ymax));
  }
}
#endif
##concat##CQPSViewTest.cpp
#include <CQPSView.h>
#include <CPSView.h>

#include <QApplication>
#include <QVBoxLayout>

class CQPSViewTest : public QWidget {
 private:
  CQPSView *psview_;

 public:
  CQPSViewTest();
 ~CQPSViewTest();

  void loadFile(const QString &fileName);
};

int
main(int argc, char **argv)
{
  QApplication app(argc, argv);

  CQPSViewTest test;

  test.show();

  if (argc > 1)
    test.loadFile(argv[1]);

  return app.exec();
}

CQPSViewTest::
CQPSViewTest()
{
  resize(CPSView::PAGE_WIDTH, CPSView::PAGE_HEIGHT);

  QVBoxLayout *layout = new QVBoxLayout(this);
  layout->setMargin(0); layout->setSpacing(0);

  psview_ = new CQPSView;

  layout->addWidget(psview_);
}

CQPSViewTest::
~CQPSViewTest()
{
}

void
CQPSViewTest::
loadFile(const QString &fileName)
{
  psview_->loadFile(fileName);
}
##concat##moc_CQPSView.cpp
/****************************************************************************
** Meta object code from reading C++ file 'CQPSView.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.2.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include <CQPSView.h>
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'CQPSView.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.2.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
struct qt_meta_stringdata_CQPSView_t {
    QByteArrayData data[1];
    char stringdata[10];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    offsetof(qt_meta_stringdata_CQPSView_t, stringdata) + ofs \
        - idx * sizeof(QByteArrayData) \
    )
static const qt_meta_stringdata_CQPSView_t qt_meta_stringdata_CQPSView = {
    {
QT_MOC_LITERAL(0, 0, 8)
    },
    "CQPSView\0"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_CQPSView[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

void CQPSView::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    Q_UNUSED(_o);
    Q_UNUSED(_id);
    Q_UNUSED(_c);
    Q_UNUSED(_a);
}

const QMetaObject CQPSView::staticMetaObject = {
    { &QWidget::staticMetaObject, qt_meta_stringdata_CQPSView.data,
      qt_meta_data_CQPSView,  qt_static_metacall, 0, 0}
};


const QMetaObject *CQPSView::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *CQPSView::qt_metacast(const char *_clname)
{
    if (!_clname) return 0;
    if (!strcmp(_clname, qt_meta_stringdata_CQPSView.stringdata))
        return static_cast<void*>(const_cast< CQPSView*>(this));
    return QWidget::qt_metacast(_clname);
}

int CQPSView::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    return _id;
}
QT_END_MOC_NAMESPACE
##concat##CBrush.h
#ifndef CBRUSH_H
#define CBRUSH_H

#include <CRGBA.h>
#include <CBrushStyle.h>
#include <CFillType.h>
#include <CImage.h>
#include <CAutoPtr.h>
#include <CGenGradient.h>

enum CBrushPattern {
  CBRUSH_PATTERN_NONE,
  CBRUSH_PATTERN_HORIZONTAL,
  CBRUSH_PATTERN_VERTICAL,
  CBRUSH_PATTERN_CROSS,
  CBRUSH_PATTERN_DIAGONAL_UP,
  CBRUSH_PATTERN_DIAGONAL_DOWN,
  CBRUSH_PATTERN_DIAGONAL_CROSS,
  CBRUSH_PATTERN_DOTTED1,
  CBRUSH_PATTERN_DOTTED2,
  CBRUSH_PATTERN_DOTTED3,
  CBRUSH_PATTERN_DOTTED4,
  CBRUSH_PATTERN_DOTTED5,
  CBRUSH_PATTERN_DOTTED6,
  CBRUSH_PATTERN_DOTTED7
};

class CBrush {
 public:
  typedef CRefPtr<CGenGradient> GradientPtr;

 private:
  CBrushStyle   style_;
  CRGBA         color_;
  CFillType     fill_rule_;
  CBrushPattern pattern_;
  CImagePtr     texture_;
  GradientPtr   gradient_;

 public:
  CBrush() :
   style_    (CBRUSH_STYLE_SOLID),
   color_    (0,0,0),
   fill_rule_(FILL_TYPE_EVEN_ODD),
   pattern_  (CBRUSH_PATTERN_HORIZONTAL),
   texture_  (),
   gradient_ () {
    init();
  }

  CBrush &operator=(const CBrush &brush) {
    return copy(brush);
  }

  void init() {
    style_     = CBRUSH_STYLE_SOLID;
    color_     = CRGBA(0,0,0,1);
    fill_rule_ = FILL_TYPE_EVEN_ODD;
    pattern_   = CBRUSH_PATTERN_HORIZONTAL;
  }

  CBrush &copy(const CBrush &brush) {
    if (&brush == this)
      return *this;

    style_     = brush.style_;
    color_     = brush.color_;
    fill_rule_ = brush.fill_rule_;
    pattern_   = brush.pattern_;
    texture_   = brush.texture_;
    gradient_  = brush.gradient_;

    return *this;
  }

  CBrushStyle   getStyle   () const { return style_    ; }
  const CRGBA&  getColor   () const { return color_    ; }
  CFillType     getFillRule() const { return fill_rule_; }
  CBrushPattern getPattern () const { return pattern_  ; }
  CImagePtr     getTexture () const { return texture_  ; }
  GradientPtr   getGradient() const { return gradient_ ; }

  void setStyle   (CBrushStyle style    ) { style_     = style; }
  void setColor   (const CRGBA &color   ) { color_     = color; }
  void setFillRule(CFillType rule       ) { fill_rule_ = rule; }
  void setPattern (CBrushPattern pattern) { pattern_   = pattern; }
  void setTexture (CImagePtr texture    ) { texture_   = texture; }
  void setGradient(GradientPtr gradient ) { gradient_  = gradient; }
};

#endif
##concat##CBrushStyle.h
#ifndef CBRUSH_STYLE_H
#define CBRUSH_STYLE_H

enum CBrushStyle {
  CBRUSH_STYLE_NONE=0,
  CBRUSH_STYLE_SOLID=1,
  CBRUSH_STYLE_PATTERN=2,
  CBRUSH_STYLE_GRADIENT=3,
  CBRUSH_STYLE_TEXTURE=4
};

#endif
##concat##CDisplayTransform2D.h
#ifndef CDISPLAY_TRANSFORM_2D
#define CDISPLAY_TRANSFORM_2D

#include <CMatrix2D.h>
#include <CDisplayRange2D.h>

class CDisplayTransform2D {
 public:
  CDisplayTransform2D(const CDisplayRange2D *range) :
   range_(range), scale_(1.0), angle_(0.0), tx_(0.0), ty_(0.0) {
    update();
  }

  double getScale() const { return scale_; }

  const CMatrix2D &getMatrix() const { return matrix_; }

  const CMatrix2D &getIMatrix() const { return imatrix_; }

  void zoom(double factor) {
    scale_ *= factor;

    update();
  }

  void reset() {
    resetScale();
    resetAngle();
    resetPan();
  }

  void resetScale() {
    scale_ = 1.0;

    update();
  }

  void resetAngle() {
    angle_ = 0.0;

    update();
  }

  void resetPan() {
    tx_ = 0.0;
    ty_ = 0.0;

    update();
  }

  void zoomTo(const CBBox2D &bbox) {
    double w = bbox.getWidth ();
    double h = bbox.getHeight();

    CPoint2D c = bbox.getCenter();

    double w1 = range_->getWindowWidth ();
    double h1 = range_->getWindowHeight();

    double xscale = w1/w;
    double yscale = h1/h;

    scale_ = std::min(xscale, yscale);

    CPoint2D c1 = range_->getWindowCenter();

    tx_ = c1.x - c.x;
    ty_ = c1.y - c.y;

    update();
  }

  void zoomIn() {
    scale_ *= 1.5;

    update();
  }

  void zoomOut() {
    scale_ /= 1.5;

    update();
  }

  void zoomIn(const CPoint2D &c) {
    scale_ *= 1.5;

    CPoint2D c1 = range_->getWindowCenter();

    tx_ = c1.x - c.x;
    ty_ = c1.y - c.y;

    update();
  }

  void zoomOut(const CPoint2D &c) {
    scale_ /= 1.5;

    CPoint2D c1 = range_->getWindowCenter();

    tx_ = c1.x - c.x;
    ty_ = c1.y - c.y;

    update();
  }

  void panBy(double dx, double dy) {
    tx_ += dx/scale_;
    ty_ += dy/scale_;

    update();
  }

  void panTo(const CPoint2D &c) {
    CPoint2D c1 = range_->getWindowCenter();

    tx_ = c1.x - c.x;
    ty_ = c1.y - c.y;

    update();
  }

  void panLeft() {
    double w = range_->getWindowWidth()/scale_;

    panBy(-w/8, 0);
  }

  void panRight() {
    double w = range_->getWindowWidth()/scale_;

    panBy(w/8, 0);
  }

  void panDown() {
    double h = range_->getWindowHeight()/scale_;

    panBy(0, -h/8);
  }

  void panUp() {
    double h = range_->getWindowHeight()/scale_;

    panBy(0, h/8);
  }

  void spin(double da) {
    angle_ += da;

    update();
  }

 private:
  void update() {
    CPoint2D c = range_->getWindowCenter();

    CMatrix2D m1, m2, m3, m4;

    m1.setTranslation(tx_*scale_, ty_*scale_);
    m2.setTranslation( c.x,  c.y);
    m3.setScale      (scale_);
//  m3.setRotation   (angle_);
    m4.setTranslation(-c.x, -c.y);

    matrix_  = m1*m2*m3*m4;
    imatrix_ = matrix_.inverse();
  }

 private:
  const CDisplayRange2D *range_;
  double                 scale_;
  double                 angle_;
  double                 tx_, ty_;
  CMatrix2D              matrix_;
  CMatrix2D              imatrix_;
};

#endif
##concat##CFreeType.h
#ifndef CFREE_TYPE_H
#define CFREE_TYPE_H

#ifndef FT_FREETYPE_H
typedef struct FT_LibraryRec_ *FT_Library;
typedef struct FT_FaceRec_    *FT_Face;
typedef struct FT_Bitmap_      FT_Bitmap;
typedef struct FT_Vector_      FT_Vector;
#endif

#include <CPoint2D.h>
#include <CFont.h>
#include <CConfig.h>
#include <CImageLib.h>
#include <string>

#define CFreeTypeMgrInst CFreeTypeMgr::getInstance()

class CFreeType;

class CFreeTypeImageRenderer {
 public:
  CFreeTypeImageRenderer() { }

  virtual ~CFreeTypeImageRenderer() { }

  virtual void drawPoint(const CIPoint2D &p, double gray) = 0;
};

class CFreeTypePathRenderer {
 public:
  CFreeTypePathRenderer() :
   current_(0,0), current_set_(false) {
  }

  virtual ~CFreeTypePathRenderer() { }

  virtual void init() = 0;

  virtual void moveTo(const CPoint2D &p) = 0;
  virtual void lineTo(const CPoint2D &p) = 0;
  virtual void bezier2To(const CPoint2D &p1, const CPoint2D &p2) = 0;
  virtual void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) = 0;

  virtual void close() = 0;

  virtual void stroke() = 0;
  virtual void fill() = 0;

  void setCurrentPoint(const CPoint2D &p) {
    current_     = p;
    current_set_ = true;
  }

  bool getCurrentPoint(CPoint2D &p) const {
    p = current_;

    return current_set_;
  }

  void resetCurrentPoint() {
    current_set_ = false;
  }

 private:
  CPoint2D current_;
  bool     current_set_;
};

class CFreeTypeMgr {
 private:
  CFreeType *free_type_;

 public:
  static CFreeTypeMgr *getInstance();

 private:
  CFreeTypeMgr();
 ~CFreeTypeMgr();

 public:
  CFontPtr getFont() const;

  bool setFont(const char *fontName, CFontStyle style, double size);
  bool setFont(CFontPtr font);

  bool drawString(CFreeTypeImageRenderer *renderer, const char *s, double *x, double *y);
  bool drawChar(CFreeTypeImageRenderer *renderer, char c, double *x, double *y);

  bool imageString(CImagePtr image, const char *s, const CRGBA &color);
  bool imageChar(CImagePtr image, char c, const CRGBA &color);

  bool strokeString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y);
  bool fillString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y);
  bool pathString(CFreeTypePathRenderer *path, const char *s, double *x, double *y);

  bool strokeChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y);
  bool fillChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y);

  bool pathChar(CFreeTypePathRenderer *path, char c, double *x, double *y);

 private:
  CFreeTypeMgr(const CFreeTypeMgr &rhs);
  CFreeTypeMgr &operator=(const CFreeTypeMgr &rhs);
};

class CFreeType {
 public:
  CFreeType();
 ~CFreeType();

  CFontPtr getFont() const { return font_; }

  bool setFont(const char *fontName, CFontStyle style, double size);
  bool setFont(CFontPtr font);

  bool drawString(CFreeTypeImageRenderer *renderer, const char *s, double *x, double *y);
  bool drawChar(CFreeTypeImageRenderer *renderer, char c, double *x, double *y);

  bool imageString(CImagePtr image, const char *s, const CRGBA &color);
  bool imageChar(CImagePtr image, char c, const CRGBA &color);

  bool strokeString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y);
  bool fillString(CFreeTypePathRenderer *renderer, const char *s, double *x, double *y);
  bool pathString(CFreeTypePathRenderer *path, const char *s, double *x, double *y);

  bool strokeChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y);
  bool fillChar(CFreeTypePathRenderer *renderer, char c, double *x, double *y);

  bool pathChar(CFreeTypePathRenderer *path, char c, double *x, double *y);

 private:
  bool init();

  std::string encodeFontName(const char *fontName, CFontStyle style);

  bool getChar(char c);

  void drawBitmap(CFreeTypeImageRenderer *renderer, FT_Bitmap *bitmap, double x, double y);

  bool imageChar1(CImagePtr image, char c, int *x1, int *y1, int *x2, int *y2, const CRGBA &color);

  void imageBitmap(CImagePtr image, FT_Bitmap *bitmap, const CRGBA &color);

  static int traceMoveto(FT_Vector *v, CFreeType *th);
  static int traceLineto(FT_Vector *v, CFreeType *th);
  static int traceBezier2(FT_Vector *v1, FT_Vector *v2, CFreeType *th);
  static int traceBezier3(FT_Vector *v1, FT_Vector *v2, FT_Vector *v3, CFreeType *th);

 private:
  CFreeType(const CFreeType &rhs);
  CFreeType &operator=(const CFreeType &rhs);

 private:
  CConfig    config_;
  FT_Library library_;
  FT_Face    face_;
  CFontPtr   font_;

  mutable CPoint2D              pos_;
  mutable CFreeTypePathRenderer *renderer_;
};

#endif
##concat##CILine2D.h
#ifndef CILINE_2D_H
#define CILINE_2D_H

#include <CIPoint2D.h>
#include <CIVector2D.h>
#include <CMathGen.h>

template<class T>
class CILine2DT {
 private:
  typedef CIPoint2DT<T>  Point;
  typedef CIVector2DT<T> Vector;
  typedef CILine2DT<T>   Line;

 private:
  Point  p1_, p2_;
  Vector v_;

 public:
  CILine2DT() :
   p1_(), p2_(), v_() {
  }

  CILine2DT(const Line &line) :
    p1_(line.p1_), p2_(line.p2_), v_(line.v_) {
  }

  CILine2DT(T x1, T y1, T x2, T y2) :
   p1_(x1, y1), p2_(x2, y2), v_(x2 - x1, y2 - y1) {
  }

  CILine2DT(const Point &p0, const Point &p1) :
   p1_(p0), p2_(p1), v_(p0, p1) {
  }

  const Point  &start () const { return p1_; }
  const Point  &end   () const { return p2_; }
  const Vector &vector() const { return v_ ; }

  void setStart(const Point &start) { p1_ = start; }
  void setEnd  (const Point &end  ) { p2_ = end  ; }

  void print(std::ostream &os) const {
    os << p1_ << " " << p2_;
  }

  friend std::ostream &operator<<(std::ostream &os, const Line &line) {
    line.print(os);

    return os;
  }
};

typedef CILine2DT<int> CILine2D;

#endif
##concat##CLineList2D.h
#ifndef CLINE_LIST_2D_H
#define CLINE_LIST_2D_H

#include <CShape2D.h>
#include <CPoint2D.h>
#include <CLine2D.h>
#include <CTriangle2D.h>
#include <CMathGeom2D.h>
#include <CBBox2D.h>

template<typename T>
class CLineList2DT {
 private:
  typedef CPoint2DT<T> Point;

  typedef std::vector<Point> PointList;

 private:
  PointList points_;

 public:
  CLineList2DT() {
  }

  CLineList2DT(const PointList &points) :
   points_(points) {
  }

  CLineList2DT(const Point *points, uint num_points) :
   points_(&points[0], &points[num_points]) {
  }

  CLineList2DT(const T *x, const T *y, uint num_xy) :
   points_() {
    for (uint i = 0; i < num_xy; ++i)
      points_.push_back(Point(x[i], y[i]));
  }

 ~CLineList2DT() { }

  const PointList &getPoints() const { return points_; }

  uint getNumPoints() const {
    return points_.size();
  }

  const Point &getPoint(uint i) const {
    return points_[i];
  }

  Point getPoint(uint i) {
    return points_[i];
  }

  void getPoint(uint i, T *x, T *y) const {
    *x = points_[i].x;
    *y = points_[i].y;
  }

  void setPoint(uint i, T x, T y) {
    points_[i] = CPoint2D(x, y);
  }

  void setPoint(uint i, const Point &point) {
    points_[i] = point;
  }

  void addPoint(const Point &point) {
    points_.push_back(point);
  }

  CBBox2D getBBox() const {
    CBBox2D bbox;

    typename PointList::const_iterator ps = points_.begin();
    typename PointList::const_iterator pe = points_.end  ();

    for ( ; ps != pe; ++ps)
      bbox.add(*ps);

    return bbox;
  }

  void setBBox(const CBBox2D &bbox) {
    CBBox2D obbox = getBBox();

    T sx = bbox.getWidth () / obbox.getWidth ();
    T sy = bbox.getHeight() / obbox.getHeight();

    typename PointList::iterator ps = points_.begin();
    typename PointList::iterator pe = points_.end  ();

    for ( ; ps != pe; ++ps) {
      Point &p = *ps;

      p.x = sx*(p.x - obbox.getXMin()) + bbox.getXMin();
      p.y = sy*(p.y - obbox.getYMin()) + bbox.getYMin();
    }
  }

  void moveBy(const Point &p) {
    typename PointList::iterator ps = points_.begin();
    typename PointList::iterator pe = points_.end  ();

    for ( ; ps != pe; ++ps)
      *ps += p;
  }

  void resizeBy(const Point &ll, const Point &ur) {
    CBBox2D bbox = getBBox();

    T w = bbox.getWidth ();
    T h = bbox.getHeight();

    T dw = ur.x - ll.x;
    T dh = ur.y - ll.y;

    T sx = (w > 0 ? (w + dw) / w : 1);
    T sy = (h > 0 ? (h + dh) / h : 1);

    typename PointList::iterator ps = points_.begin();
    typename PointList::iterator pe = points_.end  ();

    for ( ; ps != pe; ++ps) {
      Point &p = *ps;

      p.x = sx*(p.x - bbox.getXMin()) + bbox.getXMin() + ll.x;
      p.y = sy*(p.y - bbox.getYMin()) + bbox.getYMin() + ll.y;
    }
  }

  void rotateBy(double da, const Point &o) {
    typename PointList::iterator ps = points_.begin();
    typename PointList::iterator pe = points_.end  ();

    for ( ; ps != pe; ++ps)
      *ps = rotatePoint(*ps, da, o);
  }

  double includedAngle() const {
    uint np = points_.size();

    assert(np >= 3);

    return CMathGeom2D::IncludedAngle(points_[0].x, points_[0].y,
                                      points_[1].x, points_[1].y,
                                      points_[2].x, points_[2].y);
  }

  bool arcThrough(T xr, T yr, T *xc, T *yc, T *xt1, T *yt1, T *xt2, T *yt2) {
    uint np = points_.size();

    assert(np >= 3);

    return CMathGeom2D::ArcThrough(points_[0].x, points_[0].y,
                                   points_[1].x, points_[1].y,
                                   points_[2].x, points_[2].y, xr, yr,
                                   xc, yc, xt1, yt1, xt2, yt2);
  }
};

typedef CLineList2DT<double> CLineList2D;

#endif
##concat##CPen.h
#ifndef CPEN_H
#define CPEN_H

#include <CRGBA.h>
#include <CLineDash.h>
#include <CILineDash.h>
#include <CLineCapType.h>
#include <CLineJoinType.h>

class CPen {
 private:
  CRGBA         color_;
  double        width_;
  CLineDash     dash_;
  CLineCapType  cap_;
  CLineJoinType join_;
  double        mitre_limit_;
  double        flatness_;

 public:
  CPen() :
   color_      (0,0,0,1),
   width_      (1.0),
   dash_       (),
   cap_        (LINE_CAP_TYPE_BUTT),
   join_       (LINE_JOIN_TYPE_MITRE),
   mitre_limit_(0.0),
   flatness_   (0.0) {
    init();
  }

  CPen(const CPen &pen) :
   color_      (0,0,0,1),
   width_      (1.0),
   dash_       (),
   cap_        (LINE_CAP_TYPE_BUTT),
   join_       (LINE_JOIN_TYPE_MITRE),
   mitre_limit_(0.0),
   flatness_   (0.0) {
    init();

    copy(pen);
  }

  CPen &operator=(const CPen &pen) {
    return copy(pen);
  }

  void init() {
    color_        = CRGBA(0,0,0,1);
    width_        = 1.0;
    cap_          = LINE_CAP_TYPE_BUTT;
    join_         = LINE_JOIN_TYPE_MITRE;
    mitre_limit_  = 0.0;
    flatness_     = 0.0;

    dash_.init();
  }

  CPen &copy(const CPen &pen) {
    if (&pen == this)
      return *this;

    color_        = pen.color_;
    width_        = pen.width_;
    dash_         = pen.dash_;
    cap_          = pen.cap_;
    join_         = pen.join_;
    mitre_limit_  = pen.mitre_limit_;
    flatness_     = pen.flatness_;

    return *this;
  }

  const CRGBA     &getColor     () const { return color_      ; }
  double           getWidth     () const { return width_      ; }
  const CLineDash &getLineDash  () const { return dash_       ; }
  CLineCapType     getLineCap   () const { return cap_        ; }
  CLineJoinType    getLineJoin  () const { return join_       ; }
  double           getMitreLimit() const { return mitre_limit_; }
  double           getFlatness  () const { return flatness_   ; }

  void setColor     (const CRGBA     &color   ) { color_       = color; }
  void setWidth     (double           width   ) { width_       = width; }
  void setLineDash  (const CLineDash &dash    ) { dash_        = dash; }
  void setLineCap   (CLineCapType     cap     ) { cap_         = cap; }
  void setLineJoin  (CLineJoinType    join    ) { join_        = join; }
  void setMitreLimit(double           mitre   ) { mitre_limit_ = mitre; }
  void setFlatness  (double           flatness) { flatness_    = flatness; }
};

class CIPen {
 public:
  CRGBA         color_;
  uint          width_;
  CILineDash    dash_;
  CLineCapType  cap_;
  CLineJoinType join_;
  double        mitre_limit_;
  double        flatness_;

 public:
  CIPen() :
   color_      (0,0,0,1),
   width_      (1),
   dash_       (),
   cap_        (LINE_CAP_TYPE_BUTT),
   join_       (LINE_JOIN_TYPE_MITRE),
   mitre_limit_(0.0),
   flatness_   (0.0) {
    init();
  }

  CIPen(const CIPen &pen) :
   color_      (0,0,0,1),
   width_      (1),
   dash_       (),
   cap_        (LINE_CAP_TYPE_BUTT),
   join_       (LINE_JOIN_TYPE_MITRE),
   mitre_limit_(0.0),
   flatness_   (0.0) {
    init();

    copy(pen);
  }

  CIPen &operator=(const CIPen &pen) {
    return copy(pen);
  }

  void init() {
    color_        = CRGBA(0,0,0,1);
    width_        = 1;
    cap_          = LINE_CAP_TYPE_BUTT;
    join_         = LINE_JOIN_TYPE_MITRE;
    mitre_limit_  = 0.0;
    flatness_     = 0.0;

    dash_.init();
  }

  CIPen &copy(const CIPen &pen) {
    if (&pen == this)
      return *this;

    color_        = pen.color_;
    width_        = pen.width_;
    dash_         = pen.dash_;
    cap_          = pen.cap_;
    join_         = pen.join_;
    mitre_limit_  = pen.mitre_limit_;
    flatness_     = pen.flatness_;

    return *this;
  }
};

#endif
##concat##CPixelClip.h
#ifndef CPIXEL_CLIP_H
#define CPIXEL_CLIP_H

#include <CSingleton.h>
#include <CILine2D.h>
#include <CFillType.h>

#define CPixelClipMgrInst CPixelClipMgr::getInstancePtr()

class CPixelClip1;

class CPixelClipMgr : public CSingleton<CPixelClipMgr> {
 private:
  typedef std::vector<CILine2D> ClipLineList;

  ClipLineList lines_;
  ClipLineList lines1_;

 protected:
  friend class CSingleton<CPixelClipMgr>;

  CPixelClipMgr();

 public:
  uint getNumLines () const { return lines_ .size(); }
  uint getNumLines1() const { return lines1_.size(); }

  const CILine2D &getLine (uint i) const { return lines_ [i]; }
  const CILine2D &getLine1(uint i) const { return lines1_[i]; }

  void resetLines();

  void addClipLine(const CIPoint2D &point1, const CIPoint2D &point2);

  void copyLines1();
};

class CPixelClip {
 public:
  typedef std::vector<CIPoint2D>    IPointList;
  typedef std::vector<IPointList *> IPointListList;
  typedef std::vector<CPixelClip1>  Clip1List;

 private:
  CPixelClipMgr *mgr_;
  Clip1List      clips_;

 public:
  CPixelClip();

  CPixelClip(const CPixelClip &clip);

 ~CPixelClip();

  const CPixelClip &operator=(const CPixelClip &clip);

 private:
  void assign(const CPixelClip &clip);

 public:
  void resize(uint new_num_clips);

  void init();
  void term();

  void processLine(int x1, int y1, int x2, int y2,
                   int **xx1, int **yy1, int **xx2, int **yy2, uint *num);

 private:
  void processLine1(Clip1List &clips, int x1, int y1, int x2, int y2,
                    int **xx1, int **yy1, int **xx2, int **yy2, uint *num);

  void processLine2(CPixelClip1 &clip1, const CILine2D &line);

 public:
  bool isInside(CPixelClip1 &clip1, int px, int py) const;

  bool isEmpty() const;

  uint getSize() const;

  void addPolygons(CFillType type, const IPointListList &poly_point_list);

  const IPointListList &getPolygons(uint i) const;

  uint getNumPolygons(uint i) const;
  uint getNumPolygonsPoints(uint i) const;
};

#endif
##concat##CPSViewArray.h
#ifndef PSVIEW_ARRAY_H
#define PSVIEW_ARRAY_H

class PSViewArray {
  typedef CSharedMem<PSViewToken *> PSViewSharedToken;

 private:
  CAutoPtr<PSViewSharedToken> tokens_;

 public:
  PSViewArray(PSVinteger max_length);
  PSViewArray(const PSViewArray &array);
  PSViewArray(const PSViewArray &array, PSVinteger pos);
  PSViewArray(const PSViewArray &array, PSVinteger pos, PSVinteger len);
 ~PSViewArray();

  PSViewArray *dup() const;

  int compare(PSViewArray *array);

  PSVinteger   getNumValues();
  PSViewToken *getValue(uint i);
  void         setValue(uint i, PSViewToken *token);

  void setSubValues(uint pos, PSViewToken **sub_tokens, uint num_sub_tokens);

  PSViewArray *split(uint n);

  void setBounds(int pos, uint len);

 private:
  PSViewArray();

  PSViewArray &operator=(const PSViewArray &array);
};

#endif
##concat##CPSViewArrayToken.h
#ifndef PSVIEW_ARRAY_TOKEN_H
#define PSVIEW_ARRAY_TOKEN_H

class PSViewArrayToken : public PSViewToken {
 private:
  CAutoPtr<PSViewArray> array_;

 public:
  PSViewArrayToken(CPSView *psview, uint max_length);
  PSViewArrayToken(CPSView *psview, CMatrix2D *matrix);
  PSViewArrayToken(const PSViewArrayToken &array_token);
  PSViewArrayToken(const PSViewArrayToken &array_token, uint n);
  PSViewArrayToken(CPSView *psview, PSViewArray *array);

  //----

  // virtual functions

 ~PSViewArrayToken();

  PSViewArrayToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  PSVinteger   getNumValues();
  PSViewToken *getValue(uint i);
  void         setValue(uint i, PSViewToken *token);

  void setSubValues(PSVinteger pos, PSViewToken **sub_tokens, PSVinteger num_sub_tokens);

  PSViewArrayToken *split(PSVinteger n);

  void setBounds(PSVinteger pos, PSVinteger len);

 private:
  PSViewArrayToken &operator=(const PSViewArrayToken &array_token);
};

#endif
##concat##CPSViewBooleanToken.h
class PSViewBooleanToken : public PSViewToken {
 private:
  PSVboolean value_;

 public:
  PSViewBooleanToken(CPSView *psview, PSVboolean value);
  PSViewBooleanToken(const PSViewBooleanToken &boolean_token);

  //----

  // virtual functions

 ~PSViewBooleanToken();

  PSViewBooleanToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();

  //----

  PSVboolean getValue() const { return value_; }
};
##concat##CPSViewDictionary.h
#ifndef PSVIEW_DICTIONARY_H
#define PSVIEW_DICTIONARY_H

class PSViewDictionaryToken;

class PSViewDictionaryMgr {
 private:
  typedef std::vector<PSViewDictionaryToken *> DictionaryStack;

  static const char *standard_encoding_[256];
  static const char *error_names_[];

  CPSView                         *psview_;
  CAutoPtr<PSViewDictionaryToken>  error_dictionary_;
  CAutoPtr<PSViewDictionaryToken>  sub_error_dictionary_;
  CAutoPtr<PSViewDictionaryToken>  internal_dictionary_;
  DictionaryStack                  dictionary_stack_;

 public:
  PSViewDictionaryMgr(CPSView *psview);
 ~PSViewDictionaryMgr();

  CPSView *getPSView() const { return psview_; }

  void init();

  int  getNumDictionaries();
  void addToCurrent(PSViewToken *key, PSViewToken *value);

  PSViewToken *lookup(const std::string &name);
  PSViewToken *lookup(const PSViewName &name);
  PSViewToken *lookup(PSViewToken *key);

  PSViewDictionaryToken *lookupDictionary(const std::string &name);
  PSViewDictionaryToken *lookupDictionary(const PSViewName &name);
  PSViewDictionaryToken *lookupDictionary(PSViewToken *key);

  PSViewDictionaryToken *getSystemDictionary();
  PSViewDictionaryToken *getGlobalDictionary();
  PSViewDictionaryToken *getUserDictionary();
  PSViewDictionaryToken *getInternalDictionary();
  PSViewDictionaryToken *getCurrentDictionary();
  PSViewDictionaryToken *getDictionary(int num);

  void beginDictionary(PSViewDictionaryToken *dictionary);
  void endDictionary();

  void emptyDictionaryStack();

 private:
  PSViewDictionaryMgr(const PSViewDictionaryMgr &rhs);
  PSViewDictionaryMgr &operator=(const PSViewDictionaryMgr &rhs);

 private:
  void                   createError();
  PSViewDictionaryToken *createSystem();
  PSViewDictionaryToken *createGlobal();
  PSViewDictionaryToken *createUser();
};

class PSViewKeyValue {
 private:
  PSViewToken *key_;
  PSViewToken *value_;

 public:
  explicit
  PSViewKeyValue(PSViewToken *key = NULL, PSViewToken *value = NULL);

  int compare(PSViewKeyValue *key_value);

  PSViewToken *getKey();
  PSViewToken *getValue();

  void setKey  (PSViewToken *key);
  void setValue(PSViewToken *value);

  void setKeyValue(PSViewToken *key, PSViewToken *value);
  void setKeyValue(const PSViewKeyValue &key_value);
};

class PSViewDictionary {
 private:
  PSViewDictionaryMgr         *mgr_;
  std::vector<PSViewKeyValue>  keyvals_;
  PSVinteger                   start_;
  PSVinteger                   end_;
  PSVinteger                   used_;

 public:
  PSViewDictionary(PSViewDictionaryMgr *mgr, PSVinteger max_length);
  PSViewDictionary(const PSViewDictionary &dictionary);
 ~PSViewDictionary();

  PSViewDictionary *dup() const;

  CPSView *getPSView() const { return mgr_->getPSView(); }

  int compare(PSViewDictionary *dictionary);

  int getNumValues();
  int getMaxValues();

  void addEntry(PSViewToken *key, PSViewToken *value);

  PSViewKeyValue *getKeyValue(int i) const;

  PSViewToken *getKey(int i);
  PSViewToken *getValue(int i);
  PSViewToken *getValue(PSViewToken *key);
  PSViewToken *getValue(const PSViewName &name);
  PSViewToken *getValue(const std::string &str);

  void setValue(PSVinteger pos, PSViewToken *key, PSViewToken *value);

  void resize();

  void addValue(const std::string &name, PSViewToken *value);
  void addValue(const PSViewName &key, PSViewToken *value);
  void addValue(PSViewToken *key, PSViewToken *value);

  void deleteValue(PSViewToken *key);

  void clear();

 private:
  PSViewDictionary &operator=(const PSViewDictionary &dictionary);
};

#endif
##concat##CPSViewDictionaryToken.h
#ifndef PSVIEW_DICTIONARY_TOKEN_H
#define PSVIEW_DICTIONARY_TOKEN_H

class PSViewDictionaryToken : public PSViewToken {
 private:
  PSViewDictionaryMgr        *mgr_;
  CAutoPtr<PSViewDictionary>  dictionary_;

 public:
  PSViewDictionaryToken(PSViewDictionaryMgr *mgr, PSVinteger max_length);
  PSViewDictionaryToken(const PSViewDictionaryToken &dictionary_token);

  //----

  // virtual functions

 ~PSViewDictionaryToken();

  PSViewDictionaryToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  int getNumValues();
  int getMaxValues();

  void setValue(PSVinteger pos, PSViewToken *key, PSViewToken *value);
  void setValue(PSVinteger pos, const PSViewName &key, PSViewToken *value);
  void setValue(PSVinteger pos, const std::string &key, PSViewToken *value);

  void addValue(PSViewToken *key, PSViewToken *value);
  void addValue(const PSViewName &key, PSViewToken *value);
  void addValue(const std::string &key, PSViewToken *value);

  PSViewKeyValue *getKeyValue(int i);

  PSViewToken *getKey(int i);
  PSViewToken *getValue(int i);
  PSViewToken *getValue(PSViewToken *key);
  PSViewToken *getValue(const PSViewName &key);
  PSViewToken *getValue(const std::string &key);

  void deleteValue(PSViewToken *key);

  void resize();

  void clear();

 private:
  PSViewDictionaryToken &operator=(const PSViewDictionaryToken &dictionary_token);
};

#endif
##concat##CPSViewError.h
#ifndef PSVIEW_ERROR_H
#define PSVIEW_ERROR_H

enum PSViewErrorType {
  PSVIEW_ERROR_TYPE_CONFIGURATION_ERROR,
  PSVIEW_ERROR_TYPE_DICT_FULL,
  PSVIEW_ERROR_TYPE_DICT_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_DICT_STACK_UNDERFLOW,
  PSVIEW_ERROR_TYPE_EXEC_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_HANDLE_ERROR,
  PSVIEW_ERROR_TYPE_INTERRUPT,
  PSVIEW_ERROR_TYPE_INVALID_ACCESS,
  PSVIEW_ERROR_TYPE_INVALID_EXIT,
  PSVIEW_ERROR_TYPE_INVALID_FILE_ACCESS,
  PSVIEW_ERROR_TYPE_INVALID_FONT,
  PSVIEW_ERROR_TYPE_INVALID_RESTORE,
  PSVIEW_ERROR_TYPE_IO_ERROR,
  PSVIEW_ERROR_TYPE_LIMIT_CHECK,
  PSVIEW_ERROR_TYPE_NO_CURRENT_POINT,
  PSVIEW_ERROR_TYPE_RANGE_CHECK,
  PSVIEW_ERROR_TYPE_STACK_OVERFLOW,
  PSVIEW_ERROR_TYPE_STACK_UNDERFLOW,
  PSVIEW_ERROR_TYPE_SYNTAX_ERROR,
  PSVIEW_ERROR_TYPE_TIME_OUT,
  PSVIEW_ERROR_TYPE_TYPE_CHECK,
  PSVIEW_ERROR_TYPE_UNDEFINED,
  PSVIEW_ERROR_TYPE_UNDEFINED_FILENAME,
  PSVIEW_ERROR_TYPE_UNDEFINED_RESOURCE,
  PSVIEW_ERROR_TYPE_UNDEFINED_RESULT,
  PSVIEW_ERROR_TYPE_UNMATCHED_MARK,
  PSVIEW_ERROR_TYPE_UNREGISTERED,
  PSVIEW_ERROR_TYPE_VM_ERROR
};

class PSViewErrorMgr {
 private:
  static std::string error_names_[];

  CPSView         *psview_;
  PSViewToken     *error_token_;
  PSViewNameToken *error_name_;
  bool             error_flag_;

 public:
  PSViewErrorMgr(CPSView *psview);
 ~PSViewErrorMgr();

  CPSView *getPSView() const { return psview_; }

  void raise(PSViewErrorType type);

  void setError(bool flag);
  bool getError();

  void defaultHandleError();

  void defaultErrorHandler();

 private:
  PSViewErrorMgr(const PSViewErrorMgr &rhs);
  PSViewErrorMgr &operator=(const PSViewErrorMgr &rhs);
};

#endif
##concat##CPSViewFile.h
enum PSViewFileModeType {
  PSVIEW_FILE_MODE_TYPE_NONE       = 0,
  PSVIEW_FILE_MODE_TYPE_READ       = (1<<1),
  PSVIEW_FILE_MODE_TYPE_WRITE      = (1<<2),
  PSVIEW_FILE_MODE_TYPE_READ_WRITE = PSVIEW_FILE_MODE_TYPE_READ |
                                     PSVIEW_FILE_MODE_TYPE_WRITE
};

class PSViewFile {
 private:
  static std::string ascii85_chars_;
  static std::string delim_chars_;

  CPSView *psview_;

 public:
  PSViewFile(CPSView *psview);
  PSViewFile(const PSViewFile &rhs);

  CPSView *getPSView() const { return psview_; }

  virtual ~PSViewFile();

  virtual void flush() = 0;

  virtual bool isReadable() const = 0;
  virtual bool isWritable() const = 0;

  virtual bool isValid() const = 0;

  virtual int size() = 0;

  virtual int bytesUsed() = 0;

  virtual int bytesAvailable() = 0;

  virtual bool setPosition(uint pos) = 0;

  virtual bool getPosition(uint *pos) = 0;

  virtual std::string getFileName() = 0;

  virtual int lookChar() = 0;
  virtual int readChar() = 0;

  virtual void unreadChars(const std::vector<int> &chars) = 0;

  virtual bool loadBuffer() = 0;

  virtual bool writeChar(int c) = 0;

  virtual void reset() = 0;

  virtual void close() = 0;

  PSViewToken *readToken();
  PSViewToken *readNumber();
  PSViewToken *readString();
  PSViewToken *readName();
  PSViewToken *readProcedure();

  void skipComment();
  void skipSpace();

  PSVboolean isBaseDigit(PSVinteger base);
  PSVboolean isDigit();
  PSVboolean isSeparator();
  PSVboolean isDelimiter();

  std::string charsToASCII85(uint chars);

  PSVboolean isASCII85Char(int c);

 private:
  PSViewFile &operator=(const PSViewFile &rhs);
};
##concat##CPSViewFileToken.h
class PSViewFileToken : public PSViewToken {
 protected:
  PSViewFile *file_;

 protected:
  PSViewFileToken(CPSView *psview);

  PSViewFileToken(const PSViewFileToken &file_token);

  PSViewFileToken &operator=(const PSViewFileToken &file_token);

 public:
  //----

  // virtual functions

  virtual ~PSViewFileToken();

  virtual PSViewFileToken *dup() const = 0;

  virtual int compare(PSViewToken *token);

  virtual void executeToken() = 0;

  virtual const PSViewName &getName() = 0;

  virtual void print() = 0;

  virtual std::string toString() = 0;

  //----

  PSVboolean initPostScript();

  virtual void          flush() = 0;
  virtual PSViewToken  *readToken() = 0;
  virtual bool          isValid() const = 0;
  virtual uint          bytesAvailable() = 0;
  virtual PSVboolean    setPosition(uint pos) = 0;
  virtual PSVboolean    getPosition(uint *pos) = 0;
  virtual std::string   getFileName() = 0;
  virtual int           readChar() = 0;
  virtual PSVboolean    writeChar(PSVchar c) = 0;
  virtual void          reset() = 0;
  virtual void          close() = 0;

  PSViewToken *readString();

  PSViewFile *getFile() { return file_; }
};
##concat##CPSViewFilterFile.h
#ifndef PSVIEW_FILTER_FILE_H
#define PSVIEW_FILTER_FILE_H

typedef int (*PSViewFilterFileProc)(...);

class PSViewFilterFile : public PSViewFile {
 private:
  PSViewFile           *file_;
  std::string           name_;
  PSViewFilterFileProc  proc_;
  char                 *data_;
  PSViewFileModeType    mode_;
  std::vector<char>     buffer_;
  uint                  buffer_pos_;

 public:
  PSViewFilterFile(PSViewFile *file, const PSViewName &name);
  PSViewFilterFile(PSViewFile *file, const std::string &name);
  PSViewFilterFile(const PSViewFilterFile &filter_file);
 ~PSViewFilterFile();

  int compare(PSViewFilterFile *filter_file);

  void flush();

  bool isReadable() const;
  bool isWritable() const;

  bool isValid() const;

  int size();

  int bytesUsed();

  int bytesAvailable();

  bool setPosition(uint pos);

  bool getPosition(uint *pos);

  std::string getFileName();

  int lookChar();
  int readChar();

  void unreadChars(const std::vector<int> &chars);

  bool loadBuffer();

  bool writeChar(int c);

  void reset();

  void close();

 private:
  void init();

  static void asciiHexEncode(PSViewFilterFile *file, int c, char *data);
  static int  asciiHexDecode(PSViewFilterFile *file, char *data, bool consume);
  static void ascii85Encode(PSViewFilterFile *file, int c, char *data);
  static int  eexecDecode(PSViewFilterFile *file, char *data, bool consume);

 private:
  PSViewFilterFile &operator=(const PSViewFilterFile &rhs);
};

#endif
##concat##CPSViewFilterFileToken.h
#ifndef PSVIEW_FILTER_FILE_TOKEN_H
#define PSVIEW_FILTER_FILE_TOKEN_H

class PSViewFilterFileToken : public PSViewFileToken {
 private:
  CAutoPtr<PSViewFilterFile> filter_file_;

 public:
  PSViewFilterFileToken(PSViewFileToken *token, const PSViewName &name);
  PSViewFilterFileToken(PSViewFileToken *token, const std::string &name);
  PSViewFilterFileToken(const PSViewFilterFileToken &filter_file_token);

  //----

  // virtual functions

  ~PSViewFilterFileToken();

  PSViewFilterFileToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  void          flush();
  PSViewToken  *readToken();
  bool          isReadable() const;
  bool          isWritable() const;
  bool          isValid() const;
  int           size();
  int           bytesUsed();
  uint          bytesAvailable();
  PSVboolean    setPosition(uint pos);
  PSVboolean    getPosition(uint *pos);
  std::string   getFileName();
  int           readChar();
  int           lookChar();
  bool          loadBuffer();
  PSVboolean    writeChar(PSVchar c);
  void          reset();
  void          close();

  PSViewFilterFile *getFilterFile() { return filter_file_; }
};

#endif
##concat##CPSViewFontIdToken.h
class PSViewFontIdToken : public PSViewToken {
 private:
  const PSVfont_id value_;

 public:
  PSViewFontIdToken(CPSView *psview, PSVfont_id value);
  PSViewFontIdToken(const PSViewFontIdToken &font_id_token);

  //----

  // virtual functions

  ~PSViewFontIdToken();

  PSViewFontIdToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();
};
##concat##CPSViewGStateFont.h
enum PSViewFontBuildType {
  PSVIEW_FONT_BUILD_TYPE_NONE,
  PSVIEW_FONT_BUILD_TYPE_GLYPH,
  PSVIEW_FONT_BUILD_TYPE_CHAR
};

class PSViewGStateFont0Data {
 public:
  int                             encoding_size;
  vector<int>                     encoding;
  int                             map_type;
  char                            escape_char;
  int                             num_fonts;
  vector<PSViewDictionaryToken *> font_array;
  bool                            current_font;

 public:
  PSViewGStateFont0Data() :
   encoding_size(0),
   encoding     (),
   map_type     (0),
   escape_char  ('\0'),
   num_fonts    (0),
   font_array   (),
   current_font (false) {
  }

  PSViewGStateFont0Data(const PSViewGStateFont0Data &font_data) :
   encoding_size(font_data.encoding_size),
   encoding     (font_data.encoding),
   map_type     (font_data.map_type),
   escape_char  (font_data.escape_char),
   num_fonts    (font_data.num_fonts),
   font_array   (),
   current_font (font_data.current_font) {
    font_array.resize(num_fonts);

    for (int i = 0; i < num_fonts; ++i)
      font_array[i] = font_data.font_array[i]->dup();
  }

 private:
  const PSViewGStateFont0Data &operator=(const PSViewGStateFont0Data &font_data);
};

class PSViewGStateFont3Data {
 public:
  CMatrix2D            matrix;
  PSViewToken         *encoding;
  PSViewToken         *build;
  PSViewFontBuildType  build_type;
  double               cache_device_wx;
  double               cache_device_wy;
  double               cache_device_llx;
  double               cache_device_lly;
  double               cache_device_urx;
  double               cache_device_ury;

 public:
  PSViewGStateFont3Data() :
   matrix          (),
   encoding        (NULL),
   build           (NULL),
   build_type      (PSVIEW_FONT_BUILD_TYPE_NONE),
   cache_device_wx (0.0),
   cache_device_wy (0.0),
   cache_device_llx(0.0),
   cache_device_lly(0.0),
   cache_device_urx(0.0),
   cache_device_ury(0.0) {
  }

  PSViewGStateFont3Data(const PSViewGStateFont3Data &font_data) :
   matrix          (font_data.matrix),
   encoding        (NULL),
   build           (NULL),
   build_type      (font_data.build_type),
   cache_device_wx (font_data.cache_device_wx),
   cache_device_wy (font_data.cache_device_wy),
   cache_device_llx(font_data.cache_device_llx),
   cache_device_lly(font_data.cache_device_lly),
   cache_device_urx(font_data.cache_device_urx),
   cache_device_ury(font_data.cache_device_ury) {
    if (font_data.encoding != NULL)
      encoding = font_data.encoding->dup();
    else
      encoding = NULL;

    if (font_data.build != NULL)
      build = font_data.build->dup();
    else
      build = NULL;
  }

  void execute() {
    if (build != NULL)
      build->execute();
  }

 private:
  const PSViewGStateFont3Data &operator=(const PSViewGStateFont3Data &font_data);
};

class PSViewGStateFontData {
 public:
  PSViewGStateFont0Data *font0;
  PSViewGStateFont3Data *font3;

 public:
  PSViewGStateFontData() :
   font0(NULL),
   font3(NULL) {
    font0 = new PSViewGStateFont0Data;
    font3 = new PSViewGStateFont3Data;
  }

  PSViewGStateFontData(const PSViewGStateFontData &font_data) :
   font0(NULL),
   font3(NULL) {
    if (font_data.font0 != NULL)
      font0 = new PSViewGStateFont0Data(*font_data.font0);
    else
      font0 = NULL;

    if (font_data.font3 != NULL)
      font3 = new PSViewGStateFont3Data(*font_data.font3);
    else
      font3 = NULL;
  }

  const PSViewGStateFontData &operator=(const PSViewGStateFontData &font_data) {
    if (this == &font_data)
      return *this;

    if (font_data.font0 != NULL)
      font0 = new PSViewGStateFont0Data(*font_data.font0);
    else
      font0 = NULL;

    if (font_data.font3 != NULL)
      font3 = new PSViewGStateFont3Data(*font_data.font3);
    else
      font3 = NULL;

    return *this;
  }
};

enum PSViewFontType {
  PSVIEW_FONT_TYPE_DEFAULT = -1,
  PSVIEW_FONT_TYPE_0       = 0,
  PSVIEW_FONT_TYPE_1       = 1,
  PSVIEW_FONT_TYPE_3       = 3
};

class PSViewGStateFont {
 private:
  PSViewDictionaryToken *dictionary_;
  PSViewFontType         type_;
  PSViewGStateFontData   data_;

 public:
  PSViewGStateFont() :
   dictionary_(NULL),
   type_      (PSVIEW_FONT_TYPE_DEFAULT),
   data_      () {
  }

  PSViewGStateFont(const PSViewGStateFont &font) :
   dictionary_(NULL),
   type_      (font.type_),
   data_      (font.data_)  {
    if (font.dictionary_ != NULL)
      dictionary_ = new PSViewDictionaryToken(*font.dictionary_);
    else
      dictionary_ = NULL;
  }

 ~PSViewGStateFont() { }

  PSViewDictionaryToken *getDictionary() const { return dictionary_; }

  PSViewFontType getType() const { return type_; }

  PSViewGStateFont0Data *getFont0Data() const { return data_.font0; }
  PSViewGStateFont3Data *getFont3Data() const { return data_.font3; }

  void setDefaultFont(PSViewDictionaryToken *dictionary, CMatrix2D *matrix) {
    dictionary_ = dictionary;
    type_       = PSVIEW_FONT_TYPE_DEFAULT;

    //------

    PSViewGStateFont3Data *font_data = data_.font3;

    font_data->encoding   = NULL;
    font_data->build      = NULL;
    font_data->build_type = PSVIEW_FONT_BUILD_TYPE_NONE;

    memcpy(&font_data->matrix, matrix, sizeof(CMatrix2D));
  }

  void setType1Font(PSViewDictionaryToken *dictionary, int encoding_size, vector<int> &encoding,
                    int map_type, char escape_char, int num_fonts,
                    vector<PSViewDictionaryToken *> &font_array) {
    dictionary_ = dictionary;
    type_       = PSVIEW_FONT_TYPE_0;

    PSViewGStateFont0Data *font_data = data_.font0;

    font_data->encoding_size = encoding_size;
    font_data->encoding      = encoding;
    font_data->map_type      = map_type;
    font_data->escape_char   = escape_char;
    font_data->num_fonts     = num_fonts;
    font_data->font_array    = font_array;
  }

  void setType3Font(PSViewDictionaryToken *dictionary, CMatrix2D *matrix, PSViewToken *encoding,
                    PSViewToken *build, PSViewFontBuildType build_type) {
    dictionary_ = dictionary;
    type_       = PSVIEW_FONT_TYPE_3;

    //------

    PSViewGStateFont3Data *font_data = data_.font3;

    memcpy(&font_data->matrix, matrix, sizeof(CMatrix2D));

    font_data->encoding   = encoding;
    font_data->build      = build;
    font_data->build_type = build_type;
  }

 private:
  const PSViewGStateFont &operator=(const PSViewGStateFont &font);
};
##concat##CPSViewGState.h
#ifndef PSVIEW_GSTATE_I_H
#define PSVIEW_GSTATE_I_H

#include <CPen.h>
#include <CBrush.h>

struct PSViewGStateFont;
struct PSViewGStatePattern;

class PSViewGStateMgr {
 private:
  CPSView               *psview_;
  const PSViewName      *CMYKColorSpaceName_;
  const PSViewName      *RGBColorSpaceName_;
  const PSViewName      *GrayColorSpaceName_;
  const PSViewName      *PatternColorSpaceName_;
  std::string            font_dir_;
  CMatrix2D              default_ctm_matrix_;
  int                    current_font_id_;
  PSViewDictionaryToken *default_font_;

 public:
  PSViewGStateMgr(CPSView *psview);
 ~PSViewGStateMgr();

  void init();

  CPSView *getPSView() const { return psview_; }

  const PSViewName &getCMYKColorSpace() const {
    return *CMYKColorSpaceName_;
  }

  const PSViewName &getRGBColorSpace() const {
    return *RGBColorSpaceName_;
  }

  const PSViewName &getGrayColorSpace() const {
    return *GrayColorSpaceName_;
  }

  const PSViewName &getPatternColorSpace() const {
    return *PatternColorSpaceName_;
  }

  const std::string &getFontDir() const { return font_dir_; }

  int getNextFontId() { return ++current_font_id_; }

  CMatrix2D *getDefaultMatrix();

  PSViewDictionaryToken *getDefaultFont() const { return default_font_; }

 private:
  void createDefaultFont();

 private:
  PSViewGStateMgr(const PSViewGStateMgr &rhs);
  PSViewGStateMgr &operator=(const PSViewGStateMgr &rhs);
};

class PSViewGState {
 private:
  PSViewGStateMgr               *mgr_;
  CMatrix2D                      ctm_matrix_;
  const PSViewName              *color_space_;
  bool                           pattern_color_;
  CPen                           pen_;
  CBrush                         brush_;
  CCMYK                          cmyk_;
  bool                           cmyk_valid_;
  CHSB                           hsb_;
  bool                           hsb_valid_;
  bool                           stroke_adjust_;
  CAutoPtr<PSViewToken>          black_generation_;
  CAutoPtr<PSViewToken>          undercolor_removal_;
  CAutoPtr<PSViewGStateFont>     font_;
  CPSViewRenderer               *graphics_;
  CAutoPtr<PSViewGStatePattern>  pattern_;
  CAutoPtr<PSViewPath>           path_;
  CAutoPtr<PSViewPath>           clippath_;

 public:
  PSViewGState(PSViewGStateMgr *mgr);
  PSViewGState(const PSViewGState &gstate);
 ~PSViewGState();

  const PSViewGState &operator=(const PSViewGState &gstate);

  PSViewGStateMgr *getGStateMgr() const { return mgr_; }

  CPSView *getPSView() const { return mgr_->getPSView(); }

  PSViewGStateFont *getFont() const { return font_; }

  PSViewGStatePattern *getPattern() const { return pattern_; }

  int compare(PSViewGState *gstate);

  void initGraphics();
  void setGraphics();

  void initMatrix();

  void newPath();

  void initClip();

  void moveTo(double x, double y);
  void rmoveTo(double x, double y);
  void lineTo(double x, double y);
  void rlineTo(double x, double y);

  void arc(double, double, double, double, double);
  void arcN(double, double, double, double, double);
  void arcTo(double, double, double, double, double,
             double *, double *, double *, double *);

  void curveTo(double, double, double, double, double, double);
  void rcurveTo(double, double, double, double, double, double);

  bool getCurrentPoint(double *, double *);

  void show(const std::string &str);
  void ashow(double, double, const std::string &str);
  void widthShow(double, double, int, const std::string &str);
  void awidthShow(double, double, int, double, double, const std::string &str);
  void glyphShow(const PSViewName &name);
  void kshow(PSViewToken *, const std::string &str);

  void stringWidth(const std::string &str, double *, double *);

  void charPath(const std::string &str, int flag);

  void image(char *image_data, int width, int height, int bits_per_sample,
             CMatrix2D *matrix, double *decode_array, int decode_size);

  void imageMask(char *image_data, int width, int height, int polarity, CMatrix2D *matrix);

  void closePath();

  void rectStroke(double, double, double, double, CMatrix2D *);
  void rectFill(double, double, double, double);
  void rectClip(double *, double *, double *, double *, int);

  void stroke();
  void strokePath();

  void fill();
  void patternFill();
  void eofill();

  void clip();
  void eoclip();

  void clipPath();
  void flattenPath();
  void reversePath();

  void pathBBox(double *, double *, double *, double *);
  void pathForAll(PSViewToken *, PSViewToken *, PSViewToken *, PSViewToken *);

  void adjustPoint(double *x, double *y);

  void showPage();
  void erasePage();

  void setCacheDevice(double, double, double, double, double, double);

  void setCharWidth(double, double);
  void getCharWidth(double *, double *);

  void defineFont(PSViewToken *key, PSViewDictionaryToken *dictionary);
  void undefineFont(PSViewToken *key);

  PSViewDictionaryToken *findFont(PSViewToken *key);

  void setFont(PSViewDictionaryToken *font);

  PSViewDictionaryToken *getCurrentFont();
  PSViewDictionaryToken *getRootFont();

  void selectScaleFont(PSViewToken *, PSVreal);
  void selectMakeFont(PSViewToken *, CMatrix2D *);

  PSViewDictionaryToken *scaleFont(PSViewDictionaryToken *font_dictionary,
                                   PSVreal scale);
  PSViewDictionaryToken *makeFont(PSViewDictionaryToken *font_dictionary,
                                  CMatrix2D *matrix);
  PSViewDictionaryToken *readFont(PSViewToken *key);

  PSViewDictionaryToken *makePattern(PSViewDictionaryToken *pattern_dictionary,
                                     CMatrix2D *matrix);

  void setPattern(PSViewDictionaryToken *pattern_dictionary);

  void execForm(PSViewDictionaryToken *form_dictionary);

  void setColorSpace(const PSViewName &name);

  const PSViewName &getColorSpace();

  void setPatternColor(bool flag);
  bool getPatternColor();

  void setCMYKColor(const CCMYK &cmyk);
  void getCMYKColor(CCMYK &cmyk);

  void setHSBColor(const CHSB &hsb);
  void getHSBColor(CHSB &hsb);

  void setRGBColor(const CRGBA &rgba);
  void getRGBColor(CRGBA &rgba);

  void   setGray(double);
  double getGray();

  void   setFlat(double);
  double getFlat();

  void   setLineWidth(double);
  double getLineWidth();

  void         setLineCap(CLineCapType line_cap);
  CLineCapType getLineCap();

  void          setLineJoin(CLineJoinType line_join);
  CLineJoinType getLineJoin();

  void   setMitreLimit(double);
  double getMitreLimit();

  void setStrokeAdjust(bool flag);
  bool getStrokeAdjust();

  void setDashPattern(double *, int, double);
  void getDashPattern(const double **, int *, double *);

  void         setBlackGeneration(PSViewToken *token);
  PSViewToken *getBlackGeneration();

  void         setUnderColorRemoval(PSViewToken *token);
  PSViewToken *getUnderColorRemoval();

  void       setCTMMatrix(CMatrix2D *matrix);
  CMatrix2D *getCTMMatrix();
  CMatrix2D *getInverseCTMMatrix();

  void preMultiplyCTMMatrix(CMatrix2D *matrix);
  void postMultiplyCTMMatrix(CMatrix2D *matrix);

  void multiplyDistByCTMMatrix(double x1, double y1, double *x2, double *y2);

  void multiplyByCTMMatrix(double x1, double y1, double *x2, double *y2);
  void multiplyByInverseCTMMatrix(double x1, double y1,
                                  double *x2, double *y2);

 private:
  void getCharWidth1(double *wx, double *wy);

  void showDefaultChar(int, double *, double *);

  void defaultCharPath(int, double *, double *);

  int getType0Char(const std::string &str, int *pos, PSViewDictionaryToken **font);

  void showType3Char(int, double *, double *);

  void addType3CharPath(int, double *, double *);

  void defineType0Font(PSViewToken *key, PSViewDictionaryToken *dictionary);
  void defineType3Font(PSViewToken *key, PSViewDictionaryToken *dictionary);

  void setFont1(PSViewDictionaryToken *font_dictionary);

  CCMYK rgbToCMYK(const CRGBA &rgba);

  void setRGBColor1(const CRGBA &rgba);

  double rgbToGray(double r, double g, double b) {
    return (0.3*r + 0.59*g + 0.11*b);
  }

  double cmykToGray(double c, double m, double y, double k) {
    return (1.0 - std::min(1.0, 0.3*c + 0.59*m + 0.11*y + k));
  }

  void debugPrintImage(char *image_data, int width, int height, int bits_per_sample,
                       CMatrix2D *matrix, double *decode_array, int decode_size);

  void debugPrintImageMask(char *image_data, int width, int height,
                           int polarity, CMatrix2D *matrix);
};

#endif
##concat##CPSViewGStatePattern.h
class PSViewGStatePattern {
 private:
  PSViewToken  *dictionary_;
  int           pattern_type_;
  int           paint_type_;
  int           tiling_type_;
  double        bbox_[4];
  double        x_step_;
  double        y_step_;
  PSViewToken  *paint_proc_;
  PSViewGState *gstate_;

 public:
  PSViewGStatePattern() :
   dictionary_  (NULL),
   pattern_type_(0),
   paint_type_  (0),
   tiling_type_ (0),
   x_step_      (0.0),
   y_step_      (0.0),
   paint_proc_  (NULL),
   gstate_      (NULL) {
    bbox_[0] = 0.0;
    bbox_[1] = 0.0;
    bbox_[2] = 0.0;
    bbox_[3] = 0.0;
  }

  PSViewGStatePattern(PSViewToken *dictionary, int pattern_type, int paint_type, int tiling_type,
                      double bbox[4], double x_step, double y_step,
                      PSViewToken *paint_proc, PSViewGState *gstate) :
   dictionary_  (dictionary),
   pattern_type_(pattern_type),
   paint_type_  (paint_type),
   tiling_type_ (tiling_type),
   x_step_      (x_step),
   y_step_      (y_step),
   paint_proc_  (paint_proc),
   gstate_      (gstate) {
    memcpy(bbox_, bbox, sizeof(bbox_));
  }

  PSViewGStatePattern(const PSViewGStatePattern &pattern) :
   dictionary_  (pattern.dictionary_),
   pattern_type_(pattern.pattern_type_),
   paint_type_  (pattern.paint_type_),
   tiling_type_ (pattern.tiling_type_),
   x_step_      (pattern.x_step_),
   y_step_      (pattern.y_step_),
   paint_proc_  (pattern.paint_proc_),
   gstate_      (pattern.gstate_) {
    memcpy(bbox_, pattern.bbox_, sizeof(bbox_));;
  }

 ~PSViewGStatePattern() { }

  PSViewToken *getDictionary() const { return dictionary_; }

  const double *getBBox() const { return bbox_; }

  double getXStep() const { return x_step_; }
  double getYStep() const { return y_step_; }

  PSViewToken *getPaintProc() const { return paint_proc_; }

  PSViewGState *getGState() const { return gstate_; }

  void execute() {
    paint_proc_->execute();
  }

 private:
  const PSViewGStatePattern &operator=(const PSViewGStatePattern &pattern);
};
##concat##CPSViewGStateToken.h
class PSViewGStateTokenMgr {
 private:
  CPSView           *psview_;
  PSViewGStateToken *current_gstate_;

 public:
  PSViewGStateTokenMgr(CPSView *psview);
 ~PSViewGStateTokenMgr();

  CPSView *getPSView() const { return psview_; }

  void init();

  PSViewGStateToken *getCurrent();

  void setCurrent(PSViewGStateToken *gstate_token);

  PSViewGStateToken *save();
  PSViewGStateToken *restore();

  void restoreAll();

 private:
  PSViewGStateTokenMgr(const PSViewGStateTokenMgr &rhs);
  PSViewGStateTokenMgr &operator=(const PSViewGStateTokenMgr &rhs);
};

class PSViewGStateToken : public PSViewToken {
 private:
  CAutoPtr<PSViewGState> gstate_;

 public:
  PSViewGStateToken(CPSView *psview);
  PSViewGStateToken(const PSViewGStateToken &gstate_token);

  const PSViewGStateToken &operator=(const PSViewGStateToken &gstate_token);

  //----

  PSViewGState *getGState() const { return gstate_; }

  PSViewGStatePattern *getPattern() const { return gstate_->getPattern(); }

  //----

  // virtual functions

  ~PSViewGStateToken();

  PSViewGStateToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();

  //----

  void initGraphics();

  void newPath();

  void initMatrix();
  void initClip();

  void moveTo(double x, double y);
  void rmoveTo(double x, double y);
  void lineTo(double x, double y);
  void rlineTo(double x, double y);
  void arc(double x, double y, double r, double angle1, double angle2);
  void arcN(double x, double y, double r, double angle1, double angle2);
  void arcTo(double x1, double y1, double x2, double y2, double r,
             double *xt1, double *yt1, double *xt2, double *yt2);
  void curveTo(double x1, double y1, double x2, double y2, double x3, double y3);
  void rcurveTo(double x1, double y1, double x2, double y2, double x3, double y3);
  bool getCurrentPoint(double *x, double *y);
  void show(const std::string &str);
  void ashow(double ax, double ay, const std::string &str);
  void widthShow(double cx, double cy, int c, const std::string &str);
  void awidthShow(double cx, double cy, int c, double ax, double ay, const std::string &str);
  void glyphShow(const PSViewName &name);
  void kshow(PSViewToken *proc, const std::string &str);
  void stringWidth(const std::string &str, double *wx, double *wy);
  void charPath(const std::string &str, bool flag);
  void image(char *image_data, int width, int height, int bits_per_sample, CMatrix2D *matrix,
             double *decode_array, int decode_size);
  void imageMask(char *image_data, int width, int height, int polarity, CMatrix2D *matrix);
  void closePath();
  void rectStroke(double x, double y, double width, double height, CMatrix2D *matrix);
  void rectFill(double x, double y, double width, double height);
  void rectClip(double *x, double *y, double *width, double *height, int num_rects);
  void stroke();
  void strokePath();
  void fill();
  void eofill();
  void clip();
  void eoclip();
  void clipPath();
  void flattenPath();
  void reversePath();
  void pathBBox(double *llx, double *lly, double *urx, double *ury);
  void pathForAll(PSViewToken *move_to_token, PSViewToken *line_to_token,
                  PSViewToken *curve_to_token, PSViewToken *close_path_token);
  void showPage();
  void erasePage();
  void defineFont(PSViewToken *key, PSViewDictionaryToken *dictionary);
  void undefineFont(PSViewToken *key);
  void setCacheDevice(double wx, double wy, double llx, double lly, double urx, double ury);
  void setCharWidth(double wx, double wy);
  void getCharWidth(double *wx, double *wy);

  PSViewDictionaryToken *findFont(PSViewToken *key);
  PSViewDictionaryToken *readFont(PSViewToken *key);
  void                   setFont(PSViewDictionaryToken *font);

  PSViewToken *getCurrentFont();
  PSViewToken *getRootFont();

  void selectScaleFont(PSViewToken *key, PSVreal scale);
  void selectMakeFont(PSViewToken *key, CMatrix2D *matrix);

  PSViewDictionaryToken *scaleFont(PSViewDictionaryToken *font, PSVreal scale);
  PSViewDictionaryToken *makeFont(PSViewDictionaryToken *font, CMatrix2D *matrix);
  PSViewDictionaryToken *makePattern(PSViewDictionaryToken *pattern, CMatrix2D *matrix);

  void setPattern(PSViewDictionaryToken *pattern_dictionary);
  void execForm(PSViewDictionaryToken *form_dictionary);
  void setColorSpace(const PSViewName &color_space);
  void setPatternColor(bool pattern);

  const PSViewName &getColorSpace();

  PSViewNameToken *getColorSpaceToken();

  bool getPatternColor();
  void setCMYKColor(const CCMYK &cmyk);
  void getCMYKColor(CCMYK &cmyk);
  void setHSBColor(const CHSB &hsb);
  void getHSBColor(CHSB &hsb);
  void setRGBColor(const CRGBA &rgba);
  void getRGBColor(CRGBA &rgba);
  void setGray(double gray);
  void getGray(double *gray);

  void   setFlat(double flat);
  double getFlat();

  void   setLineWidth(double line_width);
  double getLineWidth();

  void         setLineCap(CLineCapType line_cap);
  CLineCapType getLineCap();

  void          setLineJoin(CLineJoinType line_join);
  CLineJoinType getLineJoin();

  void   setMitreLimit(double mitre_limit);
  double getMitreLimit();

  void setStrokeAdjust(bool flag);
  bool getStrokeAdjust();

  void setDashPattern(double *dash_array, int num_dashes, double dash_offset);
  void getDashPattern(const double **dash_array, int *num_dashes, double *dash_offset);

  void         setBlackGeneration(PSViewToken *token);
  PSViewToken *getBlackGeneration();

  void         setUnderColorRemoval(PSViewToken *token);
  PSViewToken *getUnderColorRemoval();

  CMatrix2D *getDefaultMatrix();
  void       setCTMMatrix(CMatrix2D *matrix);
  CMatrix2D *getCTMMatrix();
  CMatrix2D *getInverseCTMMatrix();

  void preMultiplyCTMMatrix(CMatrix2D *matrix);
  void postMultiplyCTMMatrix(CMatrix2D *matrix);

  void multiplyByCTMMatrix(double x1, double y1, double *x2, double *y2);
  void multiplyByInverseCTMMatrix(double x1, double y1, double *x2, double *y2);
};
##concat##CPSView.h
#ifndef CPSVIEW_H
#define CPSVIEW_H

#include <CAutoPtr.h>
#include <CPen.h>
#include <CBrush.h>
#include <CPoint2D.h>
#include <CMatrix2D.h>

class CPSViewRenderer {
 public:
  CPSViewRenderer() { }

  virtual ~CPSViewRenderer() { }

  virtual CPSViewRenderer *dup() = 0;

  virtual void clear(const CRGBA &bg) = 0;

  // Pen, Brush
  virtual void setPen(const CPen &pen) = 0;
  virtual void setBrush(const CBrush &brush) = 0;

  virtual void pathInit() = 0;
  virtual void pathMoveTo(const CPoint2D &p) = 0;
  virtual void pathLineTo(const CPoint2D &p) = 0;
  virtual void pathArc(const CPoint2D &, double, double, double, double) = 0;
  virtual void pathBezier2To(const CPoint2D &, const CPoint2D &) = 0;
  virtual void pathBezier3To(const CPoint2D &, const CPoint2D &, const CPoint2D &) = 0;
  virtual void pathClose() = 0;
  virtual void pathStroke() = 0;
  virtual void pathFill() = 0;
  virtual void pathClip() = 0;
};

class PSViewMemoryMgr;
class PSViewResourceMgr;
class PSViewNameMgr;
class PSViewOperatorMgr;
class PSViewDictionaryMgr;
class PSViewOperandStack;
class PSViewExecutionStack;
class PSViewGraphicsStack;
class PSViewGStateMgr;
class PSViewGStateTokenMgr;
class PSViewTokenMgr;
class PSViewErrorMgr;
class PSViewMarkToken;
class PSViewFileToken;

class CPSView {
 public:
  // 8.5 by 11 inches at 72 pixels per inch
  enum { PAGE_WIDTH  = 612 };
  enum { PAGE_HEIGHT = 792 };

 private:
  typedef std::vector<PSViewFileToken *> FileTokenStack;

  time_t                         start_time_;
  bool                           debug_;
  bool                           exit_flag_;

  CAutoPtr<PSViewMemoryMgr>      memory_mgr_;
  CAutoPtr<PSViewNameMgr>        name_mgr_;
  CAutoPtr<PSViewResourceMgr>    resource_mgr_;
  CAutoPtr<PSViewDictionaryMgr>  dictionary_mgr_;
  CAutoPtr<PSViewOperatorMgr>    operator_mgr_;
  CAutoPtr<PSViewOperandStack>   operand_stack_;
  CAutoPtr<PSViewExecutionStack> execution_stack_;
  CAutoPtr<PSViewGraphicsStack>  graphics_stack_;
  CPSViewRenderer*               graphics_;
  CAutoPtr<PSViewGStateMgr>      gstate_mgr_;
  CAutoPtr<PSViewGStateTokenMgr> gstate_token_mgr_;
  CAutoPtr<PSViewTokenMgr>       token_mgr_;
  CAutoPtr<PSViewErrorMgr>       error_mgr_;
  CAutoPtr<PSViewMarkToken>      mark_token_;

  PSViewFileToken*               current_file_;
  FileTokenStack                 current_file_stack_;

 public:
  CPSView();
 ~CPSView();

  time_t getStartTime() { return start_time_; }

  bool getDebug() const { return debug_; }
  void setDebug(bool flag);

  bool getExitFlag() const { return exit_flag_; }
  void setExitFlag(bool flag);

  PSViewMemoryMgr   *getMemoryMgr  () const { return memory_mgr_; }
  PSViewNameMgr     *getNameMgr    () const { return name_mgr_; }
  PSViewResourceMgr *getResourceMgr() const { return resource_mgr_; }

  PSViewDictionaryMgr *getDictionaryMgr() const { return dictionary_mgr_; }

  PSViewOperatorMgr *getOperatorMgr() const { return operator_mgr_; }

  PSViewOperandStack   *getOperandStack  () const { return operand_stack_  ; }
  PSViewExecutionStack *getExecutionStack() const { return execution_stack_; }
  PSViewGraphicsStack  *getGraphicsStack () const { return graphics_stack_ ; }

  CPSViewRenderer *getGraphics() const { return graphics_; }

  PSViewGStateMgr      *getGStateMgr     () const { return gstate_mgr_; }
  PSViewGStateTokenMgr *getGStateTokenMgr() const { return gstate_token_mgr_; }

  PSViewTokenMgr *getTokenMgr() const { return token_mgr_; }

  PSViewErrorMgr *getErrorMgr() const { return error_mgr_; }

  PSViewMarkToken *getMarkToken() const { return mark_token_; }

  void init();
  void term();

  void setRenderer(CPSViewRenderer *renderer);

  void openCurrentFile(const std::string &filename);
  void closeCurrentFile();
  void executeCurrentFile();

  void executive();

  bool getLine(std::string &line);

  void             setCurrentFile(PSViewFileToken *token);
  PSViewFileToken *getCurrentFile();

 private:
  CPSView(const CPSView &rhs);
  CPSView &operator=(const CPSView &rhs);
};

#endif
##concat##CPSViewI.h
#ifndef PSVIEW_I_H
#define PSVIEW_I_H

#include <list>

#include <CAutoPtr.h>
#include <CGlob.h>
#include <CStrUtil.h>
//#include <CMathMacros.h>
#include <CMathGen.h>
#include <CRange2D.h>
#include <CIRange2D.h>
#include <CMatrix2D.h>
#include <CMathGeom2D.h>
#include <C3Bezier2D.h>
#include <CPoint2D.h>
#include <CIPoint2D.h>
#include <CILine2D.h>
#include <CArgs.h>
#include <CThrow.h>
#include <CRGBA.h>
#include <CCMYK.h>
#include <CHSB.h>
#include <CLineDash.h>
#include <CLineCapType.h>
#include <CLineJoinType.h>
#include <CFillType.h>
//#include <CEnv.h>
#include <COSFile.h>
#include <CSharedMem.h>
#include <COSUser.h>
#include <COSFile.h>
#include <COSRand.h>

#include <CPixelClip.h>

#include <CPSViewTypes.h>

#include <CPSView.h>

#include <CPSViewName.h>

#include <CPSViewArray.h>
#include <CPSViewDictionary.h>
#include <CPSViewError.h>
#include <CPSViewFile.h>
#include <CPSViewFilterFile.h>
#include <CPSViewGState.h>
#include <CPSViewMemory.h>
#include <CPSViewOperator.h>
#include <CPSViewPackedArray.h>
#include <CPSViewResource.h>
#include <CPSViewSave.h>
#include <CPSViewStack.h>
#include <CPSViewStringFile.h>
#include <CPSViewString.h>
#include <CPSViewTextFile.h>
#include <CPSViewPath.h>

#include <CPSViewToken.h>
#include <CPSViewArrayToken.h>
#include <CPSViewBooleanToken.h>
#include <CPSViewDictionaryToken.h>
#include <CPSViewFontIdToken.h>
#include <CPSViewGStateToken.h>
#include <CPSViewIntegerToken.h>
#include <CPSViewMarkToken.h>
#include <CPSViewNameToken.h>
#include <CPSViewNullToken.h>
#include <CPSViewOperatorToken.h>
#include <CPSViewPackedArrayToken.h>
#include <CPSViewRealToken.h>
#include <CPSViewSaveToken.h>
#include <CPSViewStringToken.h>

#include <CPSViewFileToken.h>
#include <CPSViewFilterFileToken.h>
#include <CPSViewStringFileToken.h>
#include <CPSViewTextFileToken.h>

using std::string;
using std::vector;
using std::list;
using std::cerr;
using std::endl;

#endif
##concat##CPSViewIntegerToken.h
class PSViewRealToken;

class PSViewIntegerToken : public PSViewToken {
 private:
  PSVinteger value_;

 public:
  PSViewIntegerToken(CPSView *psview, PSVinteger value);
  PSViewIntegerToken(const PSViewIntegerToken &integer_token);

  //----

  // virtual functions

  ~PSViewIntegerToken();

  PSViewIntegerToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();

  //----

  PSVinteger getValue() const { return value_; }
};
##concat##CPSViewMarkToken.h
class PSViewMarkToken : public PSViewToken {
 public:
  PSViewMarkToken(CPSView *psview);

  // virtual functions

 ~PSViewMarkToken();

  PSViewMarkToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();
};
##concat##CPSViewMemory.h
#ifndef PSVIEW_MEMORY_I_H
#define PSVIEW_MEMORY_I_H

enum PSViewMemoryType {
  PSVIEW_MEMORY_TYPE_NONE,
  PSVIEW_MEMORY_TYPE_GLOBAL,
  PSVIEW_MEMORY_TYPE_LOCAL
};

struct PSViewSaveData;
struct PSViewSaveMemory;

struct PSViewMemory {
  ulong            id;
  ulong            size;
  PSViewMemoryType type;
  ulong            ref;
  ulong            depth;
  ulong            dummy;
};

class PSViewMemoryMgr {
 private:
  CPSView          *psview_;
  PSViewMemoryType  memory_type_;
  int               memory_depth_;
  uint              memory_used_;
  PSViewSaveData   *save_data_;

  std::list<PSViewMemory *> global_memory_list_;
  std::list<PSViewMemory *> local_memory_list_;

 public:
  PSViewMemoryMgr(CPSView *psview);
 ~PSViewMemoryMgr();

  CPSView *getPSView() const { return psview_; }

  void init();

  void getStatus(int *depth, int *used, int *max);

  PSViewToken *save();
  void         restore(PSViewToken *token);

  char *alloc(uint size);

  char *allocGlobal(uint size);
  char *allocLocal(uint size);

  void change(char **address);

  void free(char *memory);

  void free(PSViewMemory *memory);
  void free(PSViewSaveMemory *save_memory);

  void setGlobal(bool flag);

  int getDepth(char *address);

  bool getGlobal(char *address);
  bool getLocal(char *address);

  bool getGlobal();
  bool getLocal();
  int  getDepth();

 private:
  PSViewMemoryMgr(const PSViewMemoryMgr &rhs);
  PSViewMemoryMgr &operator=(const PSViewMemoryMgr &rhs);
};

#endif
##concat##CPSViewName.h
#ifndef PSViewName_H
#define PSViewName_H

#include <map>

class PSViewNameMgr {
 private:
  typedef std::map<std::string,PSViewName *> NameMap;

  CPSView *psview_;
  NameMap  names_;

 public:
  PSViewNameMgr(CPSView *psview);

  const PSViewName &getName(const std::string &str);

 private:
  PSViewNameMgr(const PSViewNameMgr &rhs);
  PSViewNameMgr &operator=(const PSViewNameMgr &rhs);
};

class PSViewName {
 private:
  std::string str_;

 public:
  PSViewName(const std::string &str);
 ~PSViewName();

  int compare(const PSViewName &name) const;

  const std::string &getString() const { return str_; }
  int                getLength() const { return str_.size(); }
};

#endif
##concat##CPSViewNameToken.h
#ifndef PSVIEW_NAME_TOKEN_H
#define PSVIEW_NAME_TOKEN_H

class PSViewNameToken : public PSViewToken {
 private:
  const PSViewName &value_;

 public:
  PSViewNameToken(CPSView *psview, const PSViewName &value);
  PSViewNameToken(CPSView *psview, const std::string &str);
  PSViewNameToken(PSViewStringToken *token);
  PSViewNameToken(const PSViewNameToken &name_token);

  //----

  // virtual functions

  ~PSViewNameToken();

  PSViewNameToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();

  //----

  const PSViewName &getValue() const { return value_; }

  const std::string &getString();
  int                getLength();
};

#endif
##concat##CPSViewNullToken.h
class PSViewNullToken : public PSViewToken {
 public:
  PSViewNullToken(CPSView *psview);

  PSViewNullToken(const PSViewNullToken &null_token);

  //----

  // virtual functions

  ~PSViewNullToken();

  PSViewNullToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();
};
##concat##CPSViewOperator.h
#ifndef PSVIEW_OPERATOR_I_H
#define PSVIEW_OPERATOR_I_H

class PSViewOperatorMgr;

class PSViewOperator {
 private:
  PSViewOperatorMgr  *mgr_;
  const PSViewName   &name_;
  PSViewOperatorProc  proc_;

 public:
  PSViewOperator(PSViewOperatorMgr *mgr, const std::string &name, PSViewOperatorProc proc);

  int compare(PSViewOperator *opr);

  void invoke();

  const PSViewName   &getName  () const { return name_; }
  PSViewOperatorProc  getProc  () const { return proc_; }
  const std::string  &getString() const { return name_.getString(); }
};

class PSViewOperatorMgr {
 private:
  CPSView                       *psview_;
  PSVinteger                     random_seed_;
  std::vector<PSViewOperator *>  system_operators_;
  std::vector<PSViewOperator *>  private_operators_;
  uint                           num_private_operators_;

 public:
  PSViewOperatorMgr(CPSView *psview);
 ~PSViewOperatorMgr();

  CPSView *getPSView() const { return psview_; }

  PSVinteger getRandomSeed() const { return random_seed_; }

  void setRandomSeed(PSVinteger seed) { random_seed_ = seed; }

  void init();

  PSViewOperator *lookup(const std::string &name);

  void addSystemOperators(PSViewDictionaryToken *dictionary);

  static void startArrayOp(PSViewOperatorMgr *mgr);

  static void endArrayOp(PSViewOperatorMgr *mgr);
  void        endArrayOp();

  static void startDictionaryOp(PSViewOperatorMgr *mgr);

  static void endDictionaryOp(PSViewOperatorMgr *mgr);
  void        endDictionaryOp();

  static void print1Op(PSViewOperatorMgr *mgr);
  static void print2Op(PSViewOperatorMgr *mgr);
  static void absOp(PSViewOperatorMgr *mgr);
  static void addOp(PSViewOperatorMgr *mgr);
  static void aloadOp(PSViewOperatorMgr *mgr);
  static void anchorSearchOp(PSViewOperatorMgr *mgr);
  static void andOp(PSViewOperatorMgr *mgr);
  static void arcOp(PSViewOperatorMgr *mgr);
  static void arcNOp(PSViewOperatorMgr *mgr);
  static void arcTOp(PSViewOperatorMgr *mgr);
  static void arcToOp(PSViewOperatorMgr *mgr);
  static void arrayOp(PSViewOperatorMgr *mgr);
  static void ashowOp(PSViewOperatorMgr *mgr);
  static void astoreOp(PSViewOperatorMgr *mgr);
  static void atanOp(PSViewOperatorMgr *mgr);
  static void awidthShowOp(PSViewOperatorMgr *mgr);
  static void beginOp(PSViewOperatorMgr *mgr);
  static void bindOp(PSViewOperatorMgr *mgr);
  static void bitShiftOp(PSViewOperatorMgr *mgr);
  static void bytesAvailableOp(PSViewOperatorMgr *mgr);
  static void ceilingOp(PSViewOperatorMgr *mgr);
  static void charPathOp(PSViewOperatorMgr *mgr);
  static void clearOp(PSViewOperatorMgr *mgr);
  static void clearDictStackOp(PSViewOperatorMgr *mgr);
  static void clearToMarkOp(PSViewOperatorMgr *mgr);
  static void clipOp(PSViewOperatorMgr *mgr);
  static void clipPathOp(PSViewOperatorMgr *mgr);
  static void closeFileOp(PSViewOperatorMgr *mgr);
  static void closePathOp(PSViewOperatorMgr *mgr);
  static void concatOp(PSViewOperatorMgr *mgr);
  static void concatMatrixOp(PSViewOperatorMgr *mgr);
  static void copyOp(PSViewOperatorMgr *mgr);
  static void cosOp(PSViewOperatorMgr *mgr);
  static void countOp(PSViewOperatorMgr *mgr);
  static void countDictStackOp(PSViewOperatorMgr *mgr);
  static void countExecStackOp(PSViewOperatorMgr *mgr);
  static void countToMarkOp(PSViewOperatorMgr *mgr);
  static void currentBlackGenerationOp(PSViewOperatorMgr *mgr);
  static void currentCMYKColorOp(PSViewOperatorMgr *mgr);
  static void currentColorOp(PSViewOperatorMgr *mgr);
  static void currentColorSpaceOp(PSViewOperatorMgr *mgr);
  static void currentDashOp(PSViewOperatorMgr *mgr);
  static void currentDictOp(PSViewOperatorMgr *mgr);
  static void currentFileOp(PSViewOperatorMgr *mgr);
  static void currentFlatOp(PSViewOperatorMgr *mgr);
  static void currentFontOp(PSViewOperatorMgr *mgr);
  static void currentGlobalOp(PSViewOperatorMgr *mgr);
  static void currentGrayOp(PSViewOperatorMgr *mgr);
  static void currentGStateOp(PSViewOperatorMgr *mgr);
  static void currentHSBColorOp(PSViewOperatorMgr *mgr);
  static void currentLineCapOp(PSViewOperatorMgr *mgr);
  static void currentLineJoinOp(PSViewOperatorMgr *mgr);
  static void currentLineWidthOp(PSViewOperatorMgr *mgr);
  static void currentMatrixOp(PSViewOperatorMgr *mgr);
  static void currentMitreLimitOp(PSViewOperatorMgr *mgr);
  static void currentPackingOp(PSViewOperatorMgr *mgr);
  static void currentPointOp(PSViewOperatorMgr *mgr);
  static void currentRGBColorOp(PSViewOperatorMgr *mgr);
  static void currentStrokeAdjustOp(PSViewOperatorMgr *mgr);
  static void currentUnderColorRemovalOp(PSViewOperatorMgr *mgr);
  static void curveToOp(PSViewOperatorMgr *mgr);
  static void cviOp(PSViewOperatorMgr *mgr);
  static void cvlitOp(PSViewOperatorMgr *mgr);
  static void cvnOp(PSViewOperatorMgr *mgr);
  static void cvrOp(PSViewOperatorMgr *mgr);
  static void cvrsOp(PSViewOperatorMgr *mgr);
  static void cvsOp(PSViewOperatorMgr *mgr);
  static void cvxOp(PSViewOperatorMgr *mgr);
  static void defOp(PSViewOperatorMgr *mgr);
  static void defaultMatrixOp(PSViewOperatorMgr *mgr);
  static void defineFontOp(PSViewOperatorMgr *mgr);
  static void defineResourceOp(PSViewOperatorMgr *mgr);
  static void defineUserObjectOp(PSViewOperatorMgr *mgr);
  static void deleteFileOp(PSViewOperatorMgr *mgr);
  static void dictOp(PSViewOperatorMgr *mgr);
  static void dictStackOp(PSViewOperatorMgr *mgr);
  static void divOp(PSViewOperatorMgr *mgr);
  static void dtransformOp(PSViewOperatorMgr *mgr);
  static void dupOp(PSViewOperatorMgr *mgr);
  static void echoOp(PSViewOperatorMgr *mgr);
  static void eexecOp(PSViewOperatorMgr *mgr);
  static void endOp(PSViewOperatorMgr *mgr);
  static void eoclipOp(PSViewOperatorMgr *mgr);
  static void eofillOp(PSViewOperatorMgr *mgr);
  static void eqOp(PSViewOperatorMgr *mgr);
  static void erasePageOp(PSViewOperatorMgr *mgr);
  static void exchOp(PSViewOperatorMgr *mgr);
  static void execOp(PSViewOperatorMgr *mgr);
  static void execFormOp(PSViewOperatorMgr *mgr);
  static void execStackOp(PSViewOperatorMgr *mgr);
  static void execUserObjectOp(PSViewOperatorMgr *mgr);
  static void executeOnlyOp(PSViewOperatorMgr *mgr);
  static void executiveOp(PSViewOperatorMgr *mgr);
  static void exitOp(PSViewOperatorMgr *mgr);
  static void expOp(PSViewOperatorMgr *mgr);
  static void falseOp(PSViewOperatorMgr *mgr);
  static void fileOp(PSViewOperatorMgr *mgr);
  static void filenameForAllOp(PSViewOperatorMgr *mgr);
  static void filePositionOp(PSViewOperatorMgr *mgr);
  static void fillOp(PSViewOperatorMgr *mgr);
  static void filterOp(PSViewOperatorMgr *mgr);
  static void findFontOp(PSViewOperatorMgr *mgr);
  static void findResourceOp(PSViewOperatorMgr *mgr);
  static void flattenPathOp(PSViewOperatorMgr *mgr);
  static void floorOp(PSViewOperatorMgr *mgr);
  static void flushOp(PSViewOperatorMgr *mgr);
  static void flushFileOp(PSViewOperatorMgr *mgr);
  static void forOp(PSViewOperatorMgr *mgr);
  static void forAllOp(PSViewOperatorMgr *mgr);
  static void gcheckOp(PSViewOperatorMgr *mgr);
  static void geOp(PSViewOperatorMgr *mgr);
  static void getOp(PSViewOperatorMgr *mgr);
  static void getIntervalOp(PSViewOperatorMgr *mgr);
  static void globalDictOp(PSViewOperatorMgr *mgr);
  static void glyphShowOp(PSViewOperatorMgr *mgr);
  static void grestoreOp(PSViewOperatorMgr *mgr);
  static void grestoreAllOp(PSViewOperatorMgr *mgr);
  static void gsaveOp(PSViewOperatorMgr *mgr);
  static void gstateOp(PSViewOperatorMgr *mgr);
  static void gtOp(PSViewOperatorMgr *mgr);
  static void handleErrorOp(PSViewOperatorMgr *mgr);
  static void identMatrixOp(PSViewOperatorMgr *mgr);
  static void idivOp(PSViewOperatorMgr *mgr);
  static void idtransformOp(PSViewOperatorMgr *mgr);
  static void ifOp(PSViewOperatorMgr *mgr);
  static void ifelseOp(PSViewOperatorMgr *mgr);
  static void imageOp(PSViewOperatorMgr *mgr);
  static void imageMaskOp(PSViewOperatorMgr *mgr);
  static void indexOp(PSViewOperatorMgr *mgr);
  static void initClipOp(PSViewOperatorMgr *mgr);
  static void initGraphicsOp(PSViewOperatorMgr *mgr);
  static void initMatrixOp(PSViewOperatorMgr *mgr);
  static void internalDictOp(PSViewOperatorMgr *mgr);
  static void invertMatrixOp(PSViewOperatorMgr *mgr);
  static void itransformOp(PSViewOperatorMgr *mgr);
  static void knownOp(PSViewOperatorMgr *mgr);
  static void kshowOp(PSViewOperatorMgr *mgr);
  static void languageLevelOp(PSViewOperatorMgr *mgr);
  static void leOp(PSViewOperatorMgr *mgr);
  static void lengthOp(PSViewOperatorMgr *mgr);
  static void lineToOp(PSViewOperatorMgr *mgr);
  static void lnOp(PSViewOperatorMgr *mgr);
  static void loadOp(PSViewOperatorMgr *mgr);
  static void logOp(PSViewOperatorMgr *mgr);
  static void loopOp(PSViewOperatorMgr *mgr);
  static void ltOp(PSViewOperatorMgr *mgr);
  static void makeFontOp(PSViewOperatorMgr *mgr);
  static void makePatternOp(PSViewOperatorMgr *mgr);
  static void markOp(PSViewOperatorMgr *mgr);
  static void matrixOp(PSViewOperatorMgr *mgr);
  static void maxLengthOp(PSViewOperatorMgr *mgr);
  static void modOp(PSViewOperatorMgr *mgr);
  static void moveToOp(PSViewOperatorMgr *mgr);
  static void mulOp(PSViewOperatorMgr *mgr);
  static void neOp(PSViewOperatorMgr *mgr);
  static void negOp(PSViewOperatorMgr *mgr);
  static void newPathOp(PSViewOperatorMgr *mgr);
  static void notOp(PSViewOperatorMgr *mgr);
  static void noAccessOp(PSViewOperatorMgr *mgr);
  static void nullOp(PSViewOperatorMgr *mgr);
  static void orOp(PSViewOperatorMgr *mgr);
  static void packedArrayOp(PSViewOperatorMgr *mgr);
  static void pathBBoxOp(PSViewOperatorMgr *mgr);
  static void pathForAllOp(PSViewOperatorMgr *mgr);
  static void popOp(PSViewOperatorMgr *mgr);
  static void printOp(PSViewOperatorMgr *mgr);
  static void productOp(PSViewOperatorMgr *mgr);
  static void promptOp(PSViewOperatorMgr *mgr);
  static void pstackOp(PSViewOperatorMgr *mgr);
  static void putOp(PSViewOperatorMgr *mgr);
  static void putIntervalOp(PSViewOperatorMgr *mgr);
  static void quitOp(PSViewOperatorMgr *mgr);
  static void randOp(PSViewOperatorMgr *mgr);
  static void rcheckOp(PSViewOperatorMgr *mgr);
  static void rcurveToOp(PSViewOperatorMgr *mgr);
  static void readOp(PSViewOperatorMgr *mgr);
  static void readHexStringOp(PSViewOperatorMgr *mgr);
  static void readLineOp(PSViewOperatorMgr *mgr);
  static void readOnlyOp(PSViewOperatorMgr *mgr);
  static void readStringOp(PSViewOperatorMgr *mgr);
  static void realTimeOp(PSViewOperatorMgr *mgr);
  static void rectClipOp(PSViewOperatorMgr *mgr);
  static void rectFillOp(PSViewOperatorMgr *mgr);
  static void rectStrokeOp(PSViewOperatorMgr *mgr);
  static void renameFileOp(PSViewOperatorMgr *mgr);
  static void repeatOp(PSViewOperatorMgr *mgr);
  static void resetFileOp(PSViewOperatorMgr *mgr);
  static void resourceForAllOp(PSViewOperatorMgr *mgr);
  static void restoreOp(PSViewOperatorMgr *mgr);
  static void reversePathOp(PSViewOperatorMgr *mgr);
  static void revisionOp(PSViewOperatorMgr *mgr);
  static void rlineToOp(PSViewOperatorMgr *mgr);
  static void rmoveToOp(PSViewOperatorMgr *mgr);
  static void rollOp(PSViewOperatorMgr *mgr);
  static void rootFontOp(PSViewOperatorMgr *mgr);
  static void rotateOp(PSViewOperatorMgr *mgr);
  static void roundOp(PSViewOperatorMgr *mgr);
  static void rrandOp(PSViewOperatorMgr *mgr);
  static void runOp(PSViewOperatorMgr *mgr);
  static void saveOp(PSViewOperatorMgr *mgr);
  static void scaleOp(PSViewOperatorMgr *mgr);
  static void scaleFontOp(PSViewOperatorMgr *mgr);
  static void searchOp(PSViewOperatorMgr *mgr);
  static void selectFontOp(PSViewOperatorMgr *mgr);
  static void serialNumberOp(PSViewOperatorMgr *mgr);
  static void setBlackGenerationOp(PSViewOperatorMgr *mgr);
  static void setCacheDeviceOp(PSViewOperatorMgr *mgr);
  static void setCharWidthOp(PSViewOperatorMgr *mgr);
  static void setCMYKColorOp(PSViewOperatorMgr *mgr);
  static void setColorOp(PSViewOperatorMgr *mgr);
  static void setColorSpaceOp(PSViewOperatorMgr *mgr);
  static void setDashOp(PSViewOperatorMgr *mgr);
  static void setFilePositionOp(PSViewOperatorMgr *mgr);
  static void setFlatOp(PSViewOperatorMgr *mgr);
  static void setFontOp(PSViewOperatorMgr *mgr);
  static void setGlobalOp(PSViewOperatorMgr *mgr);
  static void setGrayOp(PSViewOperatorMgr *mgr);
  static void setGStateOp(PSViewOperatorMgr *mgr);
  static void setHSBColorOp(PSViewOperatorMgr *mgr);
  static void setLineCapOp(PSViewOperatorMgr *mgr);
  static void setLineJoinOp(PSViewOperatorMgr *mgr);
  static void setLineWidthOp(PSViewOperatorMgr *mgr);
  static void setMatrixOp(PSViewOperatorMgr *mgr);
  static void setMitreLimitOp(PSViewOperatorMgr *mgr);
  static void setPackingOp(PSViewOperatorMgr *mgr);
  static void setPatternOp(PSViewOperatorMgr *mgr);
  static void setRGBColorOp(PSViewOperatorMgr *mgr);
  static void setStrokeAdjustOp(PSViewOperatorMgr *mgr);
  static void setUnderColorRemovalOp(PSViewOperatorMgr *mgr);
  static void showOp(PSViewOperatorMgr *mgr);
  static void showPageOp(PSViewOperatorMgr *mgr);
  static void sinOp(PSViewOperatorMgr *mgr);
  static void sqrtOp(PSViewOperatorMgr *mgr);
  static void srandOp(PSViewOperatorMgr *mgr);
  static void stackOp(PSViewOperatorMgr *mgr);
  static void statusOp(PSViewOperatorMgr *mgr);
  static void stopOp(PSViewOperatorMgr *mgr);
  static void stoppedOp(PSViewOperatorMgr *mgr);
  static void storeOp(PSViewOperatorMgr *mgr);
  static void stringOp(PSViewOperatorMgr *mgr);
  static void stringWidthOp(PSViewOperatorMgr *mgr);
  static void strokeOp(PSViewOperatorMgr *mgr);
  static void strokePathOp(PSViewOperatorMgr *mgr);
  static void subOp(PSViewOperatorMgr *mgr);
  static void systemDictOp(PSViewOperatorMgr *mgr);
  static void tokenOp(PSViewOperatorMgr *mgr);
  static void transformOp(PSViewOperatorMgr *mgr);
  static void translateOp(PSViewOperatorMgr *mgr);
  static void trueOp(PSViewOperatorMgr *mgr);
  static void truncateOp(PSViewOperatorMgr *mgr);
  static void typeOp(PSViewOperatorMgr *mgr);
  static void undefOp(PSViewOperatorMgr *mgr);
  static void undefineFontOp(PSViewOperatorMgr *mgr);
  static void undefineUserObjectOp(PSViewOperatorMgr *mgr);
  static void userDictOp(PSViewOperatorMgr *mgr);
  static void userTimeOp(PSViewOperatorMgr *mgr);
  static void versionOp(PSViewOperatorMgr *mgr);
  static void vmStatusOp(PSViewOperatorMgr *mgr);
  static void wcheckOp(PSViewOperatorMgr *mgr);
  static void whereOp(PSViewOperatorMgr *mgr);
  static void widthShowOp(PSViewOperatorMgr *mgr);
  static void writeOp(PSViewOperatorMgr *mgr);
  static void writeHexStringOp(PSViewOperatorMgr *mgr);
  static void writeStringOp(PSViewOperatorMgr *mgr);
  static void xcheckOp(PSViewOperatorMgr *mgr);
  static void xorOp(PSViewOperatorMgr *mgr);
  static void xshowOp(PSViewOperatorMgr *mgr);
  static void xyshowOp(PSViewOperatorMgr *mgr);
  static void yshowOp(PSViewOperatorMgr *mgr);
  static void unimplementedOp(PSViewOperatorMgr *mgr);
  static void charPathFillOp(PSViewOperatorMgr *mgr);
  static void charPathStrokeTrueOp(PSViewOperatorMgr *mgr);
  static void charPathStrokeFalseOp(PSViewOperatorMgr *mgr);

 private:
  void bind1(PSViewToken *token);

  PSViewToken *readStringFileToken(const std::string &str, PSVinteger *pos);

 private:
  PSViewOperatorMgr(const PSViewOperatorMgr &rhs);
  PSViewOperatorMgr &operator=(const PSViewOperatorMgr &rhs);
};

#endif
##concat##CPSViewOperatorToken.h
class PSViewOperatorToken : public PSViewToken {
 private:
  PSViewOperator *operator_;

 public:
  PSViewOperatorToken(CPSView *psview, const std::string &name);
  PSViewOperatorToken(CPSView *psview, PSViewOperator *opr);
  PSViewOperatorToken(const PSViewOperatorToken &operator_token);

  //----

  // virtual functions

  ~PSViewOperatorToken();

  PSViewOperatorToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();

  //----

  PSViewOperator *getValue() const { return operator_; }

 private:
  PSViewOperatorToken &operator=(const PSViewOperatorToken &operator_token);
};
##concat##CPSViewPackedArray.h
class PSViewPackedArray {
  typedef CSharedMem<PSViewToken *> PSViewSharedToken;

 private:
  CAutoPtr<PSViewSharedToken> tokens_;

 public:
  PSViewPackedArray(PSVinteger max_length);
  PSViewPackedArray(const PSViewPackedArray &array);
  PSViewPackedArray(const PSViewPackedArray &array, PSVinteger n);
 ~PSViewPackedArray();

  int compare(PSViewPackedArray *array);

  PSVinteger   getNumValues();
  PSViewToken *getValue(int i);
  void         setValue(int i, PSViewToken *token);
};
##concat##CPSViewPackedArrayToken.h
class PSViewPackedArrayToken : public PSViewToken {
 private:
  CAutoPtr<PSViewPackedArray> packed_array_;

 public:
  PSViewPackedArrayToken(CPSView *psview, PSVinteger max_length);
  PSViewPackedArrayToken(const PSViewPackedArrayToken &packed_array_token);

  //----

  // virtual functions

  ~PSViewPackedArrayToken();

  PSViewPackedArrayToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  PSVinteger   getNumValues();
  PSViewToken *getValue(int i);
  void         setValue(int i, PSViewToken *token);
};
##concat##CPSViewPath.h
enum PSViewPathPartId {
  PSVIEW_PATH_NONE,
  PSVIEW_PATH_MOVE_TO,
  PSVIEW_PATH_LINE_TO,
  PSVIEW_PATH_BEZIER2_TO,
  PSVIEW_PATH_BEZIER3_TO,
  PSVIEW_PATH_ARC_TO,
  PSVIEW_PATH_CLOSE
};

class PSViewPath;

class PSViewPathVisitor {
 public:
  PSViewPathVisitor() : path_(NULL) { }

  virtual ~PSViewPathVisitor() { }

  void setPath(PSViewPath *path) { path_ = path; }

  virtual void init() { }
  virtual void term() { }

  virtual void moveTo(const CPoint2D &p) = 0;

  virtual void lineTo(const CPoint2D &p) = 0;

  virtual void bezier2To(const CPoint2D &p1, const CPoint2D &p2) = 0;

  virtual void bezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) = 0;

  virtual void arcTo(const CPoint2D &c, double xr, double yr, double theta, double delta) = 0;

  virtual void close() = 0;

 protected:
  PSViewPath *path_;

 private:
  PSViewPathVisitor(const PSViewPathVisitor &rhs);
  PSViewPathVisitor &operator=(const PSViewPathVisitor &rhs);
};

class PSViewPathPart {
 public:
  PSViewPathPart(PSViewPathPartId id) :
   id_(id) {
  }

  virtual ~PSViewPathPart() { }

  virtual PSViewPathPart *dup() const = 0;

  PSViewPathPartId getId() const { return id_; }

  virtual void print(std::ostream &os) const = 0;

  virtual void visit(PSViewPathVisitor &visitor) = 0;

 private:
  PSViewPathPartId id_;
};

class PSViewPathMoveTo : public PSViewPathPart {
 public:
  PSViewPathMoveTo(const CPoint2D &p) :
   PSViewPathPart(PSVIEW_PATH_MOVE_TO), p_(p) {
  }

  PSViewPathMoveTo *dup() const {
    return new PSViewPathMoveTo(*this);
  }

  void print(std::ostream &os) const {
    os << "MoveTo: " << p_ << std::endl;
  }

  void visit(PSViewPathVisitor &visitor) {
    visitor.moveTo(p_);
  }

 private:
  CPoint2D p_;
};

class PSViewPathLineTo : public PSViewPathPart {
 public:
  PSViewPathLineTo(const CPoint2D &p) :
   PSViewPathPart(PSVIEW_PATH_LINE_TO), p_(p) {
  }

  PSViewPathLineTo *dup() const {
    return new PSViewPathLineTo(*this);
  }

  void print(std::ostream &os) const {
    os << "LineTo: " << p_ << std::endl;
  }

  void visit(PSViewPathVisitor &visitor) {
    visitor.lineTo(p_);
  }

 private:
  CPoint2D p_;
};

class PSViewPathBezier2To : public PSViewPathPart {
 public:
  PSViewPathBezier2To(const CPoint2D &p1, const CPoint2D &p2) :
   PSViewPathPart(PSVIEW_PATH_BEZIER2_TO), p1_(p1), p2_(p2) {
  }

  PSViewPathBezier2To *dup() const {
    return new PSViewPathBezier2To(*this);
  }

  void print(std::ostream &os) const {
    os << "Bezier2To: " << p1_ << ", " << p2_ << std::endl;
  }

  void visit(PSViewPathVisitor &visitor) {
    visitor.bezier2To(p1_, p2_);
  }

 private:
  CPoint2D p1_;
  CPoint2D p2_;
};

class PSViewPathBezier3To : public PSViewPathPart {
 public:
  PSViewPathBezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3) :
   PSViewPathPart(PSVIEW_PATH_BEZIER3_TO), p1_(p1), p2_(p2), p3_(p3) {
  }

  PSViewPathBezier3To *dup() const {
    return new PSViewPathBezier3To(*this);
  }

  void print(std::ostream &os) const {
    os << "Bezier3To: " << p1_ << ", " << p2_ << ", " << p3_ << std::endl;
  }

  void visit(PSViewPathVisitor &visitor) {
    visitor.bezier3To(p1_, p2_, p3_);
  }

 private:
  CPoint2D p1_;
  CPoint2D p2_;
  CPoint2D p3_;
};

class PSViewPathArcTo : public PSViewPathPart {
 public:
  PSViewPathArcTo(const CPoint2D &c, double xr, double yr, double theta, double delta) :
   PSViewPathPart(PSVIEW_PATH_ARC_TO), c_(c), xr_(xr), yr_(yr), theta_(theta), delta_(delta) {
  }

  PSViewPathArcTo *dup() const {
    return new PSViewPathArcTo(*this);
  }

  void print(std::ostream &os) const {
    os << "ArcTo: " << c_ << ", " << xr_ << ", " << yr_ << ", " <<
          theta_ << ", " << delta_ << std::endl;
  }

  void visit(PSViewPathVisitor &visitor) {
    visitor.arcTo(c_, xr_, yr_, theta_, delta_);
  }

 private:
  CPoint2D c_;
  double   xr_, yr_;
  double   theta_, delta_;
};

class PSViewPathClose : public PSViewPathPart {
 public:
  PSViewPathClose() :
   PSViewPathPart(PSVIEW_PATH_CLOSE) {
  }

  PSViewPathClose *dup() const {
    return new PSViewPathClose(*this);
  }

  void print(std::ostream &os) const {
    os << "Close: " << std::endl;
  }

  void visit(PSViewPathVisitor &visitor) {
    visitor.close();
  }
};

class PSViewPath {
 public:
  PSViewPath();

  PSViewPath(const PSViewPath &path);

 ~PSViewPath();

  PSViewPath &operator=(const PSViewPath &path);

  PSViewPath *dup() const;

  void init();

  bool moveTo    (const CPoint2D &p);
  bool rmoveTo   (const CPoint2D &p);
  bool lineTo    (const CPoint2D &p);
  bool rlineTo   (const CPoint2D &p);
  bool bezier2To (const CPoint2D &p1, const CPoint2D &p2);
  bool rbezier2To(const CPoint2D &p1, const CPoint2D &p2);
  bool bezier3To (const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3);
  bool rbezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3);
  bool arc       (const CPoint2D &c, double xr, double yr, double a1, double a2);
  bool arcN      (const CPoint2D &c, double xr, double yr, double a1, double a2);
  bool arcTo     (const CPoint2D &p1, const CPoint2D &p2, double r1, double r2);

  bool addChar(int c, const CMatrix2D &m, double *x, double *y);

  void close();

  bool getCurrentPoint(CPoint2D &p);

  void flatten();
  void reverse();

  void setStrokeAdjust(bool);

  void getBounds(double *xmin, double *ymin, double *xmax, double *ymax);

  void process(PSViewPathVisitor &visitor);

  void print(std::ostream &os=std::cout) const;

 private:
  void reset();

 private:
  typedef std::vector<PSViewPathPart *> PartList;

  PartList parts_;
  bool     closed_;
  CPoint2D start_;
  CPoint2D current_;
  bool     current_set_;
};
##concat##CPSViewRealToken.h
class PSViewIntegerToken;

class PSViewRealToken : public PSViewToken {
 private:
  PSVreal value_;

 public:
  PSViewRealToken(CPSView *psview, PSVreal value);
  PSViewRealToken(const PSViewRealToken &real_token);

  //----

  // virtual functions

  ~PSViewRealToken();

  PSViewRealToken *dup() const;

  int compare(PSViewToken *token);

  void executeToken();

  const PSViewName &getName();

  void print();

  std::string toString();

  //----

  PSVreal getValue() const { return value_; }
};
##concat##CPSViewResource.h
#ifndef PSVIEW_RESOURCE_H
#define PSVIEW_RESOURCE_H

class PSViewResource;

class PSViewResourceMgr {
 private:
  typedef std::vector<PSViewResource *> ResourceList;

  CPSView      *psview_;
  ResourceList  resources_;

 public:
  PSViewResourceMgr(CPSView *psview);
 ~PSViewResourceMgr();

  CPSView *getPSView() const { return psview_; }

  void init();

  PSViewToken *findInstance(PSViewToken *key, const PSViewName &category);

  ResourceList getResources(const PSViewName &category);

  bool checkInstance(PSViewToken *instance, const PSViewName &category);

  PSViewToken *lookupInstance(PSViewToken *key, const PSViewName &category);

  void define(PSViewToken *key, PSViewToken *instance, const PSViewName &category);

 private:
  PSViewResourceMgr(const PSViewResourceMgr &rhs);
  PSViewResourceMgr &operator=(const PSViewResourceMgr &rhs);
};

class PSViewResource {
 private:
  PSViewResourceMgr *mgr_;
  PSViewToken       *key_;
  PSViewToken       *instance_;
  const PSViewName  &category_;

 public:
  PSViewResource(PSViewResourceMgr *mgr, PSViewToken *key,
                 PSViewToken *instance, const PSViewName &category);

  PSViewToken      *getKey     () const { return key_     ; }
  PSViewToken      *getInstance() const { return instance_; }
  const PSViewName &getCategory() const { return category_; }
};


#endif
##concat##CPSViewSave.h
class PSViewSave {
 private:
  void *data_;

 public:
  PSViewSave(void *data);

  int compare(PSViewSave *save);

  void *getValue();
};
##concat##CPSViewSaveToken.h
class PSViewSaveToken : public PSViewToken {
 private:
  CAutoPtr<PSViewSave> save_;

 public:
  PSViewSaveToken(CPSView *psview, void *data);
  PSViewSaveToken(const PSViewSaveToken &save_token);

  //----

  // virtual functions

  ~PSViewSaveToken();

  PSViewSaveToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  void *getValue();
};
##concat##CPSViewSharedMem.h
#ifndef PSVIEW_SHARED_MEM_H
#define PSVIEW_SHARED_MEM_H

template<class T>
class PSViewSharedMemData;

template<class T>
class PSViewSharedMem {
 private:
  int                     start_;
  int                     len_;
  PSViewSharedMemData<T> *mem_;

 public:
  PSViewSharedMem(int len);
  PSViewSharedMem(PSViewSharedMem *mem, int start, int len);
  PSViewSharedMem(PSViewSharedMem *mem, int start);
 ~PSViewSharedMem();

  const T *getData ();
  const T &getValue(int pos);

  void setData (int pos, const T *data, int len);
  void setData (const T *data, int len);
  void setValue(int pos, const T &value);

  void setBounds(int pos, int len);

  int getStart() const { return start_; }
  int getLen() const { return len_; }
};

#endif
##concat##CPSViewStack.h
#ifndef PSVIEW_STACK_H
#define PSVIEW_STACK_H

class PSViewOperandStack {
 private:
  typedef std::vector<PSViewToken *> TokenStack;

  CPSView    *psview_;
  TokenStack  operand_stack_;

 public:
  PSViewOperandStack(CPSView *psview);

  CPSView *getPSView() const {  return psview_; }

  void push(PSViewToken *token);

  PSViewToken *pop();

  void exch();
  void roll(int n, int m);

  int size();

  int countToMark();

  PSViewToken *peek(int n);

  void clear();

  void print();

 private:
  PSViewOperandStack(const PSViewOperandStack &rhs);
  PSViewOperandStack &operator=(const PSViewOperandStack &rhs);
};

class PSViewExecutionStack {
 private:
  typedef std::vector<PSViewToken *> TokenStack;

  CPSView    *psview_;
  TokenStack  execution_stack_;

 public:
  PSViewExecutionStack(CPSView *psview);

  CPSView *getPSView() const {  return psview_; }

  void push(PSViewToken *token);

  PSViewToken *pop();

  void popToExit();

  int size();

  int countToMark();

  PSViewToken *peek(int n);

  void clear();

  void print();

 private:
  PSViewExecutionStack(const PSViewExecutionStack &rhs);
  PSViewExecutionStack &operator=(const PSViewExecutionStack &rhs);
};

class PSViewGraphicsStack {
 private:
  typedef std::vector<PSViewGStateToken *> TokenStack;

  CPSView    *psview_;
  TokenStack  graphics_stack_;

 public:
  PSViewGraphicsStack(CPSView *psview);

  CPSView *getPSView() const {  return psview_; }

  void push(PSViewGStateToken *token);

  PSViewGStateToken *pop();

  int size();

 private:
  PSViewGraphicsStack(const PSViewGraphicsStack &rhs);
  PSViewGraphicsStack &operator=(const PSViewGraphicsStack &rhs);
};

#endif
##concat##CPSViewStringFile.h
class PSViewStringFile : public PSViewFile {
 private:
  std::vector<char> buffer_;
  uint              buffer_pos_;
  uint              buffer_size_;

 public:
  PSViewStringFile(CPSView *psview, const std::string &str);
 ~PSViewStringFile();

  int compare(PSViewStringFile *string_file);

  void flush();

  bool isReadable() const;
  bool isWritable() const;
  bool isValid() const;

  int size();

  int bytesUsed();
  int bytesAvailable();

  bool setPosition(uint pos);
  bool getPosition(uint *pos);

  std::string getFileName();

  int readChar();
  int lookChar();

  void unreadChars(const std::vector<int> &chars);

  bool loadBuffer();

  bool writeChar(int c);

  void reset();

  void close();
};
##concat##CPSViewStringFileToken.h
class PSViewStringFileToken : public PSViewFileToken {
 private:
  CAutoPtr<PSViewStringFile> string_file_;

 public:
  PSViewStringFileToken(CPSView *psview, const std::string &str);
  PSViewStringFileToken(const PSViewStringFileToken &string_file_token);

  //----

  // virtual functions

  ~PSViewStringFileToken();

  PSViewStringFileToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  void         flush();
  PSViewToken *readToken();
  bool         isReadable() const;
  bool         isWritable() const;
  bool         isValid() const;
  int          size();
  int          bytesUsed();
  uint         bytesAvailable();
  PSVboolean   setPosition(uint pos);
  PSVboolean   getPosition(uint *pos);
  std::string  getFileName();
  int          readChar();
  int          lookChar();
  bool         loadBuffer();
  PSVboolean   writeChar(PSVchar c);
  void         reset();
  void         close();

  PSViewStringFile *getStringFile() { return string_file_; }
};
##concat##CPSViewString.h
#ifndef PSVIEW_STRING_H
#define PSVIEW_STRING_H

class PSViewString {
  typedef CSharedMem<char> PSViewSharedChar;

 private:
  CAutoPtr<PSViewSharedChar> mem_;

 public:
  PSViewString(PSVinteger max_length);
  PSViewString(const std::string &str);
  PSViewString(const PSViewString &str, PSVinteger start);
  PSViewString(const PSViewString &str, PSVinteger start, PSVinteger len);
 ~PSViewString();

  std::string getString() const;

  int getLength() const;

  int getChar(int i) const;

  void setString(const std::string &str);
  void setChar(int pos, char c);
  void setChars(const std::string &str, int pos);

  void setBounds(int pos, int len);

  PSVinteger isSubString(PSViewString *str);

  PSViewString *subString(PSVinteger start, PSVinteger num_chars);

  PSViewString *split(int pos);

  int compare(const PSViewString &str) const;
  int compareN(const PSViewString &str, PSVinteger n) const;

  friend int operator==(const PSViewString &string1, const PSViewString &string2);
};

#endif
##concat##CPSViewStringToken.h
class PSViewStringToken : public PSViewToken {
 private:
  CAutoPtr<PSViewString> string_;

 public:
  PSViewStringToken(CPSView *psview, PSVinteger max_length);
  PSViewStringToken(CPSView *psview, const std::string &str);
  PSViewStringToken(CPSView *psview, PSViewString *str);
  PSViewStringToken(const PSViewStringToken &string_token);
  PSViewStringToken(const PSViewStringToken &string_token, int len);
  PSViewStringToken(const PSViewStringToken &string_token, int pos, int len);

  //----

  // virtual functions

 ~PSViewStringToken();

  PSViewStringToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  PSViewStringToken *split(PSVinteger pos);

  int compare(PSViewToken *token) const;

  int compareN(const PSViewStringToken *str, PSVinteger n) const;

  PSVinteger isSubString(PSViewStringToken *token);

  PSViewStringToken *subString(PSVinteger start, PSVinteger num_chars);

  void setString(const std::string &str);

  void setChar(int pos, char c);

  void setChars(const std::string &str, int pos);

  void setBounds(PSVinteger pos, PSVinteger len);

  int getLength() const;

  int getChar(int i) const;
};
##concat##CPSViewTextFile.h
class PSViewTextFile : public PSViewFile {
 private:
  std::string         name_;
  std::string         mode_;
  PSViewFileModeType  mode_type_;
  FILE               *fp_;
  int                 size_;
  uint                pos_;
  std::vector<char>   buffer_;
  uint                buffer_pos_;
  uint                buffer_num_;
  uint                buffer_size_;

 public:
  PSViewTextFile(CPSView *psview, const std::string &name, const std::string &mode);
  PSViewTextFile(const PSViewTextFile &text_file);
 ~PSViewTextFile();

  int compare(PSViewTextFile *text_file);

  void flush();

  bool isReadable() const;
  bool isWritable() const;
  bool isValid() const;

  int size();
  int bytesUsed();
  int bytesAvailable();

  bool setPosition(uint pos);
  bool getPosition(uint *pos);

  std::string getFileName();

  int readChar();
  int lookChar();

  void unreadChars(const std::vector<int> &chars);

  bool loadBuffer();

  bool writeChar(int c);

  void reset();

  void close();

 private:
  void init();

 private:
  PSViewTextFile &operator=(const PSViewTextFile &rhs);
};
##concat##CPSViewTextFileToken.h
class PSViewTextFileToken : public PSViewFileToken {
 private:
  CAutoPtr<PSViewTextFile> text_file_;

 public:
  PSViewTextFileToken(CPSView *psview, const std::string &filename, const std::string &mode);
  PSViewTextFileToken(const PSViewTextFileToken &text_file_token);

  //----

  // virtual functions

  ~PSViewTextFileToken();

  PSViewTextFileToken *dup() const;

  const PSViewName &getName();

  void print();

  std::string toString();

  void executeToken();

  int compare(PSViewToken *token);

  //----

  void         flush();
  PSViewToken *readToken();
  bool         isValid() const;
  uint         bytesAvailable();
  PSVboolean   getPosition(uint *pos);
  PSVboolean   setPosition(uint pos);
  std::string  getFileName();
  int          readChar();
  PSVboolean   writeChar(PSVchar c);
  void         reset();
  void         close();

  PSViewTextFile *getTextFile() { return text_file_; }
};
##concat##CPSViewToken.h
#ifndef PSVIEW_TOKEN_H
#define PSVIEW_TOKEN_H

enum PSViewTokenType {
  PSVIEW_TOKEN_TYPE_NONE,
  PSVIEW_TOKEN_TYPE_BOOLEAN,
  PSVIEW_TOKEN_TYPE_FONT_ID,
  PSVIEW_TOKEN_TYPE_INTEGER,
  PSVIEW_TOKEN_TYPE_MARK,
  PSVIEW_TOKEN_TYPE_NAME,
  PSVIEW_TOKEN_TYPE_NULL,
  PSVIEW_TOKEN_TYPE_OPERATOR,
  PSVIEW_TOKEN_TYPE_REAL,
  PSVIEW_TOKEN_TYPE_SAVE,
  PSVIEW_TOKEN_TYPE_ARRAY,
  PSVIEW_TOKEN_TYPE_DICTIONARY,
  PSVIEW_TOKEN_TYPE_FILE,
  PSVIEW_TOKEN_TYPE_GSTATE,
  PSVIEW_TOKEN_TYPE_PACKED_ARRAY,
  PSVIEW_TOKEN_TYPE_STRING
};

enum PSViewTokenAccessType {
  PSVIEW_TOKEN_ACCESS_TYPE_NONE,
  PSVIEW_TOKEN_ACCESS_TYPE_READ_ONLY,
  PSVIEW_TOKEN_ACCESS_TYPE_READ_WRITE,
  PSVIEW_TOKEN_ACCESS_TYPE_EXECUTE_ONLY
};

enum PSViewTokenCompositeType {
  PSVIEW_TOKEN_COMPOSITE,
  PSVIEW_TOKEN_NON_COMPOSITE
};

enum PSViewTokenExecutableType {
  PSVIEW_TOKEN_EXECUTABLE,
  PSVIEW_TOKEN_LITERAL
};

class PSViewTokenMgr {
 private:
  CPSView     *psview_;
  bool         packing_;
  PSViewToken *last_execute_token_;

 public:
  PSViewTokenMgr(CPSView *psview);

  CPSView *getPSView() const { return psview_; }

  int getPacking() const { return packing_; }

  void setPacking(int packing);

  PSViewToken *getLastExecuteToken() const { return last_execute_token_; }

  void setLastExecuteToken(PSViewToken *token);

  const PSViewName &getLBraceName();
  const PSViewName &getRBraceName();
};

class PSViewToken {
 protected:
  CPSView                   *psview_;
  PSViewTokenType            type_;
  PSViewTokenCompositeType   composite_;
  PSViewMemory              *memory_;
  PSViewTokenExecutableType  executable_;
  PSViewTokenAccessType      access_;

 protected:
  PSViewToken(CPSView *psview, PSViewTokenType type, PSViewTokenCompositeType composite,
              PSViewTokenExecutableType executable, PSViewTokenAccessType access);

  PSViewToken(const PSViewToken &token);

  PSViewToken &operator=(const PSViewToken &token);

 public:
  // virtual functions

  virtual ~PSViewToken();

  virtual PSViewToken *dup() const = 0;

  virtual int compare(PSViewToken *token);

  virtual void executeToken() = 0;

  virtual const PSViewName &getName() = 0;

  virtual void print() = 0;

  virtual std::string toString() = 0;

  //----

  CPSView *getPSView() const { return psview_; }

  PSViewTokenType getType() const;

  PSVboolean isType(PSViewTokenType type) const;

  PSVboolean isExecutable();
  PSVboolean getWritable();
  PSVboolean getReadable();
  PSVboolean getGlobal();
  PSVboolean getLocal();
  PSVboolean isLiteral();

  void setExecutable();
  void setLiteral();
  void setReadWrite();
  void setReadOnly();
  void setExecuteOnly();
  void setNoAccess();

  int getMemoryDepth();

  PSVboolean isBoolean();
  PSVboolean isFontId();
  PSVboolean isInteger();
  PSVboolean isName();
  PSVboolean isMark();
  PSVboolean isNull();
  PSVboolean isOperator();
  PSVboolean isReal();
  PSVboolean isSave();
  PSVboolean isComposite();
  PSVboolean isArray();
  PSVboolean isDictionary();
  PSVboolean isFile();
  PSVboolean isGState();
  PSVboolean isPackedArray();
  PSVboolean isString();
  PSVboolean isNumber();
  PSVboolean isProcedure();

  PSVboolean getBooleanValue();
  PSVinteger getIntegerValue();
  PSVreal    getRealValue();

  PSViewToken *toName();

  std::string getTypeName();

  void execute();

  PSVboolean  isMatrix();
  CMatrix2D  *getMatrix();
  void        setMatrix(CMatrix2D *matrix);
};

#endif
##concat##CPSViewTypes.h
typedef int          PSVboolean;
typedef long         PSVfont_id;
typedef long         PSVinteger;
typedef int          PSVmark;
typedef int          PSVnull;
typedef double       PSVreal;
typedef uint PSVchar;

class PSViewName;
class PSViewToken;
class PSViewArrayToken;
class PSViewNameToken;
class PSViewStringToken;
class PSViewGStateToken;
class PSViewPath;
class PSViewOperatorMgr;

typedef void  (*PSViewOperatorProc)(PSViewOperatorMgr *);
##concat##CQPSView.h
#ifndef CQ_PSVIEW_H
#define CQ_PSVIEW_H

#include <QWidget>

class CQPSViewRenderer;
class CPSView;

class CQPSView : public QWidget {
  Q_OBJECT

 public:
  CQPSView(QWidget *parent=0);
 ~CQPSView();

  void loadFile(const QString &fileName);

  void paintEvent(QPaintEvent *);

 private:
  CQPSViewRenderer *renderer_;
  CPSView          *psview_;
};

#endif
##concat##CQPSViewRenderer.h
#ifndef CQPSVIEW_RENDERER_H
#define CQPSVIEW_RENDERER_H

#include <CPSView.h>
#include <CDisplayTransform2D.h>

#include <QImage>
#include <QPainter>
#include <QBrush>
#include <QPen>

class CQPSViewRenderer : public CPSViewRenderer {
 public:
  CQPSViewRenderer();

  CQPSViewRenderer *dup();

  void beginDraw();
  void endDraw();

  void setSize(int width, int height);

  void clear(const CRGBA &bg);

  void setViewMatrix(const CMatrix2D &m);

  void setPen(const CPen &pen);
  void setBrush(const CBrush &brush);

  void pathInit();
  void pathMoveTo(const CPoint2D &p);
  void pathLineTo(const CPoint2D &p);
  void pathArc(const CPoint2D &p, double r1, double r2, double a1, double a2);
  void pathBezier2To(const CPoint2D &p1, const CPoint2D &p2);
  void pathBezier3To(const CPoint2D &p1, const CPoint2D &p2, const CPoint2D &p3);
  void pathClose();
  void pathStroke();
  void pathFill();
  void pathClip();

  //void pathClipPath(PathBuilder &builder);

  QImage getQImage() const { return qimage_; }

 private:
  QImage           qimage_;
  QPainter        *painter_;
  QPainterPath    *path_;
  QBrush           brush_;
  QPen             pen_;
  QFont            qfont_;
  CFillType        fillType_;
  double           flatness_;
  CMatrix2D        viewMatrix_;
  bool             antiAlias_;
  CDisplayRange2D  range_;
  QTransform       transform_;
  QTransform       itransform_;
};

#endif
##concat##CSharedMem.h
#ifndef CSHARED_MEM_H
#define CSHARED_MEM_H

template<class T>
class CSharedMemData {
 private:
  T   *memory_;
  int  size_;
  int  ref_count_;

 public:
  CSharedMemData(int size) :
   memory_(NULL), size_(size), ref_count_(1) {
    memory_ = new T [size_];
  }

 ~CSharedMemData() {
   if (ref_count_ != 0)
      CTHROW("Bad Delete");

    delete [] memory_;
  }

  const T *getData(int pos) {
    if (pos < 0 || pos > size_)
      CTHROW("Bad Subscript");

    return &memory_[pos];
  }

  const T &getValue(int pos) {
    if (pos < 0 || pos > size_)
      CTHROW("Bad Subscript");

    return memory_[pos];
  }

  void setData(int pos, const T *data, int len) {
    if (pos < 0 || pos + len - 1 > size_)
      CTHROW("Bad Subscript");

    for (int i = 0; i < len; ++i)
      memory_[pos + i] = data[i];
  }

  void setValue(int pos, const T &value) {
    if (pos < 0 || pos > size_)
      CTHROW("Bad Subscript");

    memory_[pos] = value;
  }

  void addRef() {
    ++ref_count_;
  }

  void deleteRef() {
    if (ref_count_ <= 0)
      CTHROW("Bad Ref Count");

    --ref_count_;

    if (ref_count_ == 0)
      delete this;
  }

 private:
  CSharedMemData(const CSharedMemData &rhs);
  CSharedMemData &operator=(const CSharedMemData &rhs);
};

template<class T>
class CSharedMem {
 private:
  int                start_;
  int                len_;
  CSharedMemData<T> *mem_;

 public:
  CSharedMem(int len) :
   start_(0), len_(len), mem_(NULL) {
    mem_ = new CSharedMemData<T>(len);
  }

  CSharedMem(CSharedMem *mem, int start, int len) :
   start_(mem->start_ + start), len_(len), mem_(mem->mem_) {
    if (start < 0 || start > mem->len_ ||
        len   < 0 || len   > mem->len_)
      CTHROW("Bad Subscript");

    mem_->addRef();
  }

  CSharedMem(CSharedMem *mem, int start) :
   start_(mem->start_ + start), len_(mem->len_ - start), mem_(mem->mem_) {
    if (start < 0 || start > mem->len_)
      CTHROW("Bad Subscript");

    mem_->addRef();
  }

  CSharedMem(CSharedMem *mem) :
   start_(mem->start_), len_(mem->len_), mem_(mem->mem_) {
    mem_->addRef();
  }

 ~CSharedMem() {
    mem_->deleteRef();
  }

  const T *getData() {
    return mem_->getData(start_);
  }

  const T &getValue(int pos) {
    return mem_->getValue(start_ + pos);
  }

  void setData(int pos, const T *data, int len) {
    mem_->setData(start_ + pos, data, len);
  }

  void setData(const T *data, int len) {
    mem_->setData(start_, data, len);
  }

  void setValue(int pos, const T &value) {
    mem_->setValue(start_ + pos, value);
  }

  void setBounds(int pos, int len) {
    if (pos < 0 || pos       > len_ ||
        len < 0 || pos + len > len_)
      CTHROW("Bad Indices");

    start_ = start_ + pos;
    len_   = len;
  }

  int getStart() const { return start_; }
  int getLen() const { return len_; }

 private:
  CSharedMem(const CSharedMem &rhs);
  CSharedMem &operator=(const CSharedMem &rhs);
};

#endif
